//Discord initialisation
const Discord = require("discord.js");
const { prefix, token } = require('./config.json');
const client = new Discord.Client({
	intents: ["GUILDS", "GUILD_MESSAGES", "GUILD_PRESENCES", "GUILD_MEMBERS"] 
});

const Canvas = require("canvas");

//Node.js imports
var fs = require('fs'),
	path = require('path'),
	_ = require('underscore');
var createGraph = require('ngraph.graph');
var pathfinding_bn = require('ngraph.path');
	
var backup_array = fs.readdirSync("./backups/");
var open_maps = {
};
var open_map_id = 0;

backup_array.sort(function(a, b) {
	return fs.statSync("./backups/" + a).mtime.getTime() - fs.statSync("./backups/" + b).mtime.getTime();
});
backup_array = backup_array.reverse();

console.log("[Triumph & Tragedy]: Backup Array: " + backup_array);

//Other imports	
function getMostRecentFile (dir) {
    var files = fs.readdirSync(dir);

    // use underscore for max()
    return _.max(files, function (f) {
        var fullpath = path.join(dir, f);

        // ctime = creation time is used
        // replace with mtime for modification time
        return fs.statSync(fullpath).ctime;
    });
}

function returnChannel (arg0) {
	return client.channels.cache.get(arg0);
}

var returnChannels = {
	send: function (arg0_channels, arg1_message) {
		for (var i = 0; i < arg0_channels.length; i++) {
			try {
				returnChannel(arg0_channels[i]).send(arg1_message);
			} catch {}
		}
	}
};

Array.prototype.remove = function() {
    var what, a = arguments, L = a.length, ax;
    while (L && this.length) {
        what = a[--L];
        while ((ax = this.indexOf(what)) !== -1) {
            this.splice(ax, 1);
        }
    }
    return this;
};

function readConfig () {
	let rawsettings = fs.readFileSync('settings.txt');
	eval(rawsettings.toString());
}

let rawconfig = fs.readFileSync('config.js');
eval(rawconfig.toString());

//Bot settings
{
	bot_prefix = "$";
	start_date = new Date(2020, 03, 26, 16, 09);
	turn_timer = 60;
	announcements_channel = "701470100674576475";
	authorised_role = "";
}

readConfig();

let rawprovinces = fs.readFileSync('./maps/provinces.js');
provinces = JSON.parse(rawprovinces);

//Dijkstra algorithm optimisation, pre-add nodes and edges

var graph = createGraph();
var all_provinces = Object.keys(provinces);

setTimeout(function(){
	for (var i = 0; i < all_provinces.length; i++) {
		if (all_provinces[i].match(/^[0-9]+$/) && all_provinces[i].length > 0) {
			//Add owners and other things
			provinces[all_provinces[i]].province_obj = getProvince(all_provinces[i]);
			provinces[all_provinces[i]].owner = getProvince(all_provinces[i], "owner");
			for (var x = 0; x < provinces[all_provinces[i]].adjacencies.length; x++) {
				graph.addLink(all_provinces[i], provinces[all_provinces[i]].adjacencies[x], {weight: 1});
			}
		}
	}
}, 500);

let rawdata = fs.readFileSync('database.js');
let main;
var original_svg;
var colonial_svg;
var supply_svg;
var backup_loaded = false;

var override_id;

process.on('unhandledRejection', error => {
	console.error('Unhandled promise rejection:', error);
});

function loadMostRecentSave () {
	//ABRS - Automated Backup and Restoration System (ABRS)
	if (rawdata.toString().length != 0) {
		main = JSON.parse(rawdata);
	} else {
		for (var i = 0; i < backup_array.length; i++) {
			if (backup_loaded == false) {
				let current_backup = fs.readFileSync("./backups/" + backup_array[i]);
				if (current_backup.toString().length != 0) {
					var is_valid_json = false;
					
					try {
						JSON.parse(current_backup);
						is_valid_json = true;
					} catch (error) {
						is_valid_json = false;
					}
					
					if (is_valid_json) {
						console.log("Going through backup file '" + backup_array[i] + "' ...");
						fs.copyFile("./backups/" + backup_array[i], "database.js", (err) => {
							if (err) throw err;
						});
						setTimeout(function(){
							rawdata = fs.readFileSync('database.js');
							main = JSON.parse(rawdata);
						},1000);
						backup_loaded = true;
						var file_string = backup_array[i];
						setTimeout(function(){
							returnChannels.send(announcements_channel, "A backup from **" + file_string + "** was automatically restored.");
							original_svg = fs.readFileSync("./maps/" + config.map_definition, "utf8");
						},5000);
					}
				}
			}
		}
	}

	//Load political SVG
	if (fs.existsSync("./maps/political_map.svg")) {
		if (fs.readFileSync("./maps/political_map.svg", "utf8").toString().length > 0 && backup_loaded == false) {
			original_svg = fs.readFileSync("./maps/political_map.svg", "utf8");
		} else {
			original_svg = fs.readFileSync("./maps/" + config.map_definition, "utf8");
		}
	} else {
		original_svg = fs.readFileSync("./maps/" + config.map_definition, "utf8");
		fs.closeSync(fs.openSync("./maps/political_map.svg", 'w'));
		console.log("Political map file created!");
	}
	
	//Load colonial SVG
	if (fs.existsSync("./maps/colonial_map.svg")) {
		if (fs.readFileSync("./maps/colonial_map.svg", "utf8").toString().length > 0 && backup_loaded == false) {
			colonial_svg = fs.readFileSync("./maps/colonial_map.svg", "utf8");
		} else {
			colonial_svg = fs.readFileSync("./maps/" + config.map_definition, "utf8");
		}
	} else {
		colonial_svg = fs.readFileSync("./maps/" + config.map_definition, "utf8");
		fs.closeSync(fs.openSync("./maps/colonial_map.svg", 'w'));
		console.log("Colonial map file created!");
	}
	
	//Load supply limit SVG
	if (fs.existsSync("./maps/supply_limit_map.svg")) {
		if (fs.readFileSync("./maps/supply_limit_map.svg", "utf8").toString().length > 0 && backup_loaded == false) {
			supply_svg = fs.readFileSync("./maps/supply_limit_map.svg", "utf8");
		} else {
			supply_svg = fs.readFileSync("./maps/" + config.map_definition, "utf8");
		}
	} else {
		supply_svg = fs.readFileSync("./maps/" + config.map_definition, "utf8");
		fs.closeSync(fs.openSync("./maps/supply_limit_map.svg", 'w'));
		console.log("Supply Limit map file created!");
	}
}

loadMostRecentSave();
if (!main.users.global) setTimeout(function(){
	initGlobal();
	global.command_queue = (main.users.global.command_queue) ? main.users.global.command_queue : [];
}, 1000);
if (main.users.global) global.command_queue = (main.users.global.command_queue) ? main.users.global.command_queue : [];

client.once('ready', () => {
	console.log("[Triumph & Tragedy] is ready. Hello!");
});

client.login(bot_token); 

client.on('ready', () => {
	console.log("[Triumph & Tragedy] Current bot token is: " + bot_token);
	console.log("[Triumph & Tragedy] Logged into user account: " + client.user.username);
	client.user.setPresence({ activity: { name: "Triumph & Tragedy"}, status: 'online'}).then(console.log).catch(console.error);
});

function ceilRandomNumber (min, max) {
	return Math.ceil(Math.random() * (max - min) + min); 
}
function randomNumber(min, max) {  
	return Math.round(Math.random() * (max - min) + min); 
}

var localisation = ["MISSING_LOC_STRING"];
var ignore_news = false;

function getLoc (index) {
	var loc_element = 0;
	if (index != undefined) {
		loc_element = index;
	}
	
	return localisation[(localisation.length-1)-loc_element];
}

user = "";
input = "";

building_list = [];
news = [];

{
	//Config logic
	{
		//Config framework functions
		{
			function unique (a) {
				var seen = {};
				return a.filter(function(item) {
					return seen.hasOwnProperty(item) ? false : (seen[item] = true);
				});
			}
		}
		
		var all_building_categories = [];
			
		config.pop_array = Object.keys(config.pops);
		config.valid_technologies = Object.keys(config.technology);
		config.units = Object.keys(config.unit_stats);
		config.buildings = Object.keys(config.building_stats);
		
		config.total_default_techs = 0;
		
		if (config.additional_research != undefined) {
			if (config.additional_research != 0) {
				for (var i = 0; i < config.valid_technologies.length; i++) {
					if (config.technology[config.valid_technologies[i]].research_cost <= config.additional_research) {
						config.total_default_techs++;
					}
				}
			}
		}
		
		//AI Config
		{
			var all_ai_types = Object.keys(config.ai_types);
			for (var i = 0; i < all_ai_types.length; i++) {
				var local_type = config.ai_types[all_ai_types[i]];
				
				//Convert all province arguments to strings
				//cities
				try {
					var all_city_categories = Object.keys(local_type.cities);
					for (var x = 0; x < all_city_categories.length; x++) {
						var local_category = local_type.cities[all_city_categories[x]];
						if (!Array.isArray(local_category)) {
							var local_cities_category = Object.keys(local_category);
							
							for (var y = 0; y < local_cities_category.length; y++) {
								local_category[local_cities_category[y]] = local_category[local_cities_category[y]].toString();
							}
						}
					}
					
					setTimeout(function(){
						try {
							//Auto-fill generic names from all city categories
							for (var x = 0; x < all_city_categories.length; x++) {
								var local_category = Object.keys(local_type.cities[all_city_categories[x]]);
								if (!Array.isArray(local_type.cities[all_city_categories[x]])) local_type.cities.generic_names = local_category.concat(local_type.cities.generic_names);
							}
							
							//Make sure generic_names contains only unique names
							local_type.cities.generic_names = unique(local_type.cities.generic_names);
						} catch (e) {
							console.log(e);
						}
					}, 100);
				} catch {}
				
				//colonial_preferred_provinces
				try {
					var all_colonial_categories = Object.keys(local_type.colonial_preferred_provinces);
					for (var x = 0; x < all_colonial_categories.length; x++) {
						var local_colonial_array = local_type.colonial_preferred_provinces[all_colonial_categories[x]];
						
						for (var y = 0; y < local_colonial_array.length; y++) {
							local_colonial_array[y] = local_colonial_array[y].toString();
						}
					}
				} catch {}
				
				//preferred_provinces
				try {
					var all_preferred_provinces = Object.keys(local_type.preferred_provinces);
					for (var x = 0; x < all_preferred_provinces.length; x++) {
						var local_provinces_array = local_type.preferred_provinces[all_preferred_provinces[x]];
						
						for (var y = 0; y < local_provinces_array.length; y++) {
							local_provinces_array[y] = local_provinces_array[y].toString();
						}
					}
				} catch {}
			}
		}
		
		//Buildings
		{
			//Initialise all_building_categories - Global Reference Array
			for (var i = 0; i < config.buildings.length; i++) {
				var local_building = config.building_stats[config.buildings[i]];
				if (local_building.category) {
					all_building_categories.push(local_building.category);
				}
			}
			
			if (!config.building_categories || config.building_categories.length == 0) {
				config.building_categories = unique(all_building_categories).sort();
			}
			
			//Initialise all building categories - Local Reference Arrays
			for (var i = 0; i < config.building_categories.length; i++) {
				//Make sure that array is undefined by default before creating a new one
				if (!config[config.building_categories[i]]) {
					var local_building_category_array = (!config[config.building_categories[i]]) ? [] : config[config.building_categories[i]];
					
					//Go through all buildings and add them before sorting
					for (var i = 0; i < config.buildings.length; i++) {
						var local_building = config.building_stats[config.buildings[i]];
						
						//Make sure category is defined
						if (local_building.category) {
							if (local_building.category == config.building_categories[i]) {
								local_building_category_array.push(local_building.category);
							}
						}
					}
					
					//Sort new reference array in alphabetical order
					local_building_category_array = local_building_category_array.sort();
				}
			}
		}
		
		//Market
		{
			config.resource_buy_list = [];
			for (var i = 0; i < config.resource_list.length; i++) {
				config.resource_buy_list.push(config.resource_list[i][0]);
			}
		}
		
		//Units
		{
			for (var i = 0; i < config.units.length; i++) {
				//Sort all craft costs
				config.unit_stats[config.units[i]].costs.sort(function(a,b){ return b[0] - a[0] });
				
				//Set manpower_cost
				for (var x = 0; x < config.unit_stats[config.units[i]].costs.length; x++) {
					if (config.unit_stats[config.units[i]].costs[x][1] == "soldiers") {
						if (config.unit_stats[config.units[i]].quantity != undefined) {
							config.unit_stats[config.units[i]].manpower_cost = config.unit_stats[config.units[i]].costs[x][0]/config.unit_stats[config.units[i]].quantity;
						}
					}
				}
			}
		}
	
		//Year
		setTimeout(function(){
			if (main.roundCount == 0 || main.year < config.starting_year) {
				main.year = config.starting_year;
			}
		},5000);
	}
	
	//AI functions
	{
		function generateBuildingMatrix (arg0_user) {
			//Convert from parameters
			var user_id = arg0_user;
			var usr = (main.users[arg0_user]) ? main.users[arg0_user] : undefined;
			
			//Declare instance variables, functions
			var building_matrix = [];
			var combined_building_matrix = []; //building_matrix/other_building_matrix merger
			var other_building_matrix = [];
			
			function changeBuildingValue (arg0_building, arg1_amount) {
				//Convert from parameters
				var building_name = arg0_building;
				var amount = arg1_amount;
				
				//Declare instance variables
				var index_found = [false, -1];
				for (var i = 0; i < building_matrix.length; i++) {
					index_found = (building_matrix[i][0] == building_name) ? [true, i] : index_found;
				}
				
				if (index_found[0]) {
					building_matrix[index_found[1]][1] += amount;
				} else {
					building_matrix.push([building_name, amount]);
				}
			}
			function changeOtherBuildingValue (arg0_building, arg1_amount) {
				//Convert from parameters
				var building_name = arg0_building;
				var amount = arg1_amount;
				
				//Declare instance variables
				var index_found = [false, -1];
				for (var i = 0; i < other_building_matrix.length; i++) {
					index_found = (other_building_matrix[i][0] == building_name) ? [true, i] : index_found;
				}
				
				if (index_found[0]) {
					other_building_matrix[index_found[1]][1] += amount;
				} else {
					other_building_matrix.push([building_name, amount]);
				}
			}
			
			if (usr) {
				var average_building_cost;
				var average_goods_importance;
				var demand_per_turn = [];
				var goods_importance = [];
				var goods_matrix = generateGoodsMatrix(user_id);
				var production_chains = generateProductionChains(user_id);
				var total_constructions = 0; //How many buildings should be attempted to be constructed this turn?
				var total_cost = 0;
				var total_goods_importance = 0;
				var user_production = getProduction(user_id, "all", true);
				
				//Initialise goods_importance array
				var all_goods_keys = Object.keys(goods_matrix);
				for (var i = 0; i < all_goods_keys.length; i++) goods_importance.push([all_goods_keys[i], goods_matrix[all_goods_keys[i]]]);
				goods_importance.sort(function (a, b) { return b[1]-a[1]; });
				
				//Begin queueing up construction orders for resource-producing buildings
				for (var i = 0; i < goods_importance.length; i++) {
					var local_production = production_chains[goods_importance[i][0]];
					var needed_buildings = [];
					var needed_goods = Object.keys(local_production.production_process);
						needed_goods = needed_goods.reverse();
					
					//Iterate over all required goods, starting from the bottom up: fetch needed_buildings
					for (var x = 0; x < needed_goods.length; x++) {
						var goods_average;
						try {
							goods_average = Math.ceil((user_production[goods_importance[i][0]][0]+user_production[goods_importance[i][0]][1])/2);
						} catch {
							goods_average = 0;
						}
						
						//The ones toward the bottom come first if they don't have a surplus!
						if (goods_average <= 0) {
							try {
								changeBuildingValue(local_production.production_process[needed_goods[x]][0], 1);
							} catch {}
						}
						
					}
					
					//If no deficits are found, build at the top
					try {
						changeBuildingValue(local_production.production_process[goods_importance[i][0]][0], 1);
					} catch {}
					
					//Used for calculating average good importance
					total_goods_importance += goods_importance[i][1];
				}
				
				//Calculate other metrics
				average_goods_importance = Math.ceil(total_goods_importance/goods_importance.length);
				total_constructions = Math.ceil(getAverageGoods(user_id)/getAverageBuildingCost(user_id));
				total_constructions = (total_constructions < 1) ? 1 : total_constructions; 
				
				//Calculate other_building_matrix for all other buildings
				for (var i = 0; i < usr.available_buildings.length; i++) {
					var local_building_score = getBuildingScore(user_id, usr.available_buildings[i]);
					if (local_building_score) changeOtherBuildingValue(usr.available_buildings[i], local_building_score);
				}
				
				//Sort other_building_matrix
				other_building_matrix.sort(function (a, b) { return b[1]-a[1]; });
				
				//All entries are converted into percentages of their respective arrays before being adjusted to total_constructions.
				var total_economic_score = 0;
				var total_non_economic_score = 0;
				
				for (var i = 0; i < building_matrix.length; i++) total_economic_score += building_matrix[i][1];
				for (var i = 0; i < other_building_matrix.length; i++) total_non_economic_score += other_building_matrix[i][1];
				
				//Convert to percentages
				for (var i = 0; i < building_matrix.length; i++) building_matrix[i][1] = building_matrix[i][1]/total_economic_score;
				for (var i = 0; i < other_building_matrix.length; i++) other_building_matrix[i][1] = other_building_matrix[i][1]/total_non_economic_score;
				
				//Combine into single array, every 4th build query is replaced by one from other_building_matrix
				var abandoned_index = 0;
				var other_buildings_index = 0;
				for (var i = 0; i < Math.max(building_matrix.length, other_building_matrix.length); i++) {
					//Make sure that building_matrix is defined, otherwise declare 'abandoned_index'
					if (building_matrix[i]) {
						combined_building_matrix.push(building_matrix[i]);
						if (i % 4 == 0 && i != 0) {
							if (other_building_matrix[i/4]) combined_building_matrix.push(other_building_matrix[i/4]);
							other_buildings_index++;
						}
					} else {
						abandoned_index = other_buildings_index;
					}
				}
				for (var i = abandoned_index; i < other_building_matrix.length; i++) {
					var already_in_index = false;
					for (var x = 0; x < combined_building_matrix.length; x++) if (combined_building_matrix[x][0] == other_building_matrix[i][0]) already_in_index = true;
					if (!already_in_index) combined_building_matrix.push(other_building_matrix[i]);
				}
				
				//Convert combined index to percentages
				var combined_building_total = 0;
				for (var i = 0; i < combined_building_matrix.length; i++) combined_building_total += combined_building_matrix[i][1];
				for (var i = 0; i < combined_building_matrix.length; i++) {
					combined_building_matrix[i][1] = combined_building_matrix[i][1]/combined_building_total;
				}
				
				//Finish processing
				for (var i = 0; i < combined_building_matrix.length; i++) combined_building_matrix[i][1] = Math.ceil(combined_building_matrix[i][1]*total_constructions);
			}
			
			//Return statement
			return combined_building_matrix;
		}
		
		function generateBuyingMatrix (arg0_user) { //This basically just translates per_turn_demand into an array
			//Convert from parameters
			var user_id = arg0_user;
			var usr = (main.users[arg0_user]) ? main.users[arg0_user] : undefined;
			
			//Declare instance variable
			var buy_matrix = [];
			
			//Only start generating a matrix if user is defined
			if (usr) {
				try {
					var current_demand = usr.ai.per_turn_demand;
					var all_demand_keys = Object.keys(current_demand);
					
					//Check if user needs food
					if (usr.inventory.food < Math.ceil(usr.population/config.population_food_requirement)) {
						var food_required = Math.ceil(usr.population/config.population_food_requirement)-usr.inventory.food;
						buy_matrix.push(["food", food_required]);
					}
					
					for (var i = 0; i < all_demand_keys.length; i++) buy_matrix.push([all_demand_keys[i], current_demand[all_demand_keys[i]]]);
					
					//Sort buy_matrix
					buy_matrix.sort((a, b) => b[1]-a[1]);
					
					//Return statement
					return buy_matrix;
				} catch {}
			}
		}
		
		function generateCityMatrix (arg0_user) {
			//Convert from parameters
			var user_id = arg0_user;
			var usr = main.users[arg0_user];
			
			//Declare instance variables, functions
			var city_matrix = []; //[province, city_score]
			
			function changeProvinceScore (arg0_province, arg1_amount) {
				//Convert from parameters
				var province_id = arg0_province;
				var amount = arg1_amount;
				
				//Declare instance variables
				var province_exists = [false, ""];
				
				for (var i = 0; i < city_matrix.length; i++) {
					province_exists = (city_matrix[i][0] == province_id) ? [true, i] : province_exists;
				}
				
				//Modify element now
				if (amount != 0) {
					if (province_exists[0]) {
						city_matrix[province_exists[1]][1] += amount;
					} else {
						city_matrix.push([province_id, amount]);
					}
				}
			}
			
			//Try/catch for undefined error trapping
			try {
				var ai_type = config.ai_types[usr.ai.ai_template];
				if (usr.type == "ai") {
					//Iterate through entire pops array
					for (var i = 0; i < usr.pops.pop_array.length; i++) {
						var local_province = usr.pops[usr.pops.pop_array[i]];
						var local_province_id = usr.pops.pop_array[i];
						
						//Begin adding remoteness scores
						var nearest_city_distance = getNearestCity(user_id, local_province_id);
						
						if (nearest_city_distance > 1) {
							var local_remoteness_score = nearest_city_distance*config.remoteness_score_per_step;
							if (local_remoteness_score > config.remoteness_max_distance*config.remoteness_score_per_step) local_remoteness_score = config.remoteness_max_distance*config.remoteness_score_per_step;
							
							//Change province score
							changeProvinceScore(local_province_id, local_remoteness_score);
						}
						
						//Begin adding conurbation scores
						if (!isUrban(local_province_id)) {
							//-1 is added in order to ensure it functions properly
							var local_conurbation_score = (config.conurbation_max_distance-(nearest_city_distance-1))*config.conurbation_score_per_step;
							if (local_conurbation_score > 0) changeProvinceScore(local_province_id, local_conurbation_score);
						}
					}
			
					//Trim out all provinces with an importance score of zero or less
					var zero_scores = [];
					for (var i = 0; i < city_matrix.length; i++) {
						if (city_matrix[i][1] <= 0) zero_scores.push(city_matrix[i]);
					}
					
					for (var i = 0; i < zero_scores.length; i++) {
						for (var x = 0; x < city_matrix.length; x++) {
							if (city_matrix[x] == zero_scores[i]) city_matrix.splice(x, 1);
						}
					}
				}
			} catch (e) {
				console.log(e);
			}
			
			//Sort matrix by province score, ascending order
			city_matrix.sort((a, b) => b[1]-a[1]);
			
			//Return city matrix
			return city_matrix;
		}
		
		function generateColonisationMatrix (arg0_user) {
			//Convert from parameters
			var user_id = arg0_user;
			var usr = (main.users[arg0_user]) ? main.users[arg0_user] : undefined;
			
			//Declare instance variables, functions
			var colonisation_matrix = []; //[province, colonisation_score]
			
			function changeProvinceScore (arg0_province, arg1_amount) {
				//Convert from parameters
				var province_id = arg0_province;
				var amount = arg1_amount;
				
				//Declare instance variables
				var province_exists = [false, ""];
				
				for (var i = 0; i < colonisation_matrix.length; i++) {
					province_exists = (colonisation_matrix[i][0] == province_id) ? [true, i] : province_exists;
				}
				
				//Modify element now
				if (amount != 0) {
					if (province_exists[0]) {
						colonisation_matrix[province_exists[1]][1] += amount;
					} else {
						colonisation_matrix.push([province_id, amount]);
					}
				}
			}
			
			//Try/catch for undefined error trapping
			try {
				var ai_type = config.ai_types[usr.ai.ai_template];
				if (usr.type == "ai") {
					//Home Provinces AI
					{
						//Capital importance
						for (var i = 0; i < config.capital_importance; i++) {
							var current_province_range = getAllProvincesInRange(usr.capital_id.toString(), i);
							
							//Increment importance for current_province_range
							for (var x = 0; x < current_province_range.length; x++) {
								changeProvinceScore(current_province_range[x], 1);
							}
						}
						
						//Increment importance for preferred_provinces
						if (ai_type.preferred_provinces[config.map_type]) {
							for (var i = 0; i < ai_type.preferred_provinces[config.map_type].length; i++) {
								var local_province_id = ai_type.preferred_provinces[config.map_type][i];
								
								//Increase importance of preferred_provinces on map_type
								changeProvinceScore(local_province_id, config.preferred_provinces_importance);
							}
						}
						
						//Increment importance for preferred cities (if adjacent to any province currently owned by usr.id)
						if (ai_type.cities[config.map_type]) {
							var local_city_keys = Object.keys(ai_type.cities[config.map_type]);
							for (var i = 0; i < local_city_keys.length; i++) {
								var local_province_id = ai_type.cities[config.map_type][local_city_keys[i]];
								var is_adjacent_to_owner = false;
								
								//Check to see if the local_province_id is adjacent to owner
								try {
									for (var x = 0; x < provinces[local_province_id].adjacencies.length; x++) {
										//Get province owner
										var current_province_owner = getProvince(provinces[local_province_id].adjacencies[x], "owner");
										is_adjacent_to_owner = (current_province_owner == usr.id) ? true : is_adjacent_to_owner;
									}
								} catch {}
								
								if (is_adjacent_to_owner) changeProvinceScore(local_province_id, config.preferred_city_importance);
							}
						}
						
						//Recently colonised provinces in zone of interest importance
						//[province_id, user_id, turns_since_colonisation], only logs within zone of interest
						for (var i = 0; i < usr.ai.recently_colonised_provinces.length; i++) {
							var local_element = usr.ai.recently_colonised_provinces[i];
							var local_score = (local_element[2] <= config.adjacency_importance_turns) ? 1 : 0;
							
							//Check to see if user has more average resources
							if (returnAverageResources(local_element[1])*0.5 > returnAverageResources(usr.id) && local_element[2] <= config.power_importance_turns) {
								local_score += config.power_importance;
							}
							
							//Check to see if user is on poor terms or otherwise
							var get_relations_index = -1;
							for (var x = 0; x < usr.relations.length; x++) {
								if (usr.relations[x][1] == local_element[1]) {
									get_relations_index = (usr.relations[x][0] <= -15 || usr.relations[x][2][1] <= -15) ? x : get_relations_index;
								}
							}
							//Rivalries and poor relations
							if ((main.users[local_element[1]].rivals.includes(usr.id) || usr.rivals.includes(local_element[1])) || get_relations_index != -1) local_score += config.rival_importance;
							
							//Change province score
							var has_local_capital = false;
							for (var x = 0; x < main.user_array.length; x++) {
								if (main.user_array[x] != user_id) {
									var local_user = main.users[main.user_array[x]];
									var local_distance = moveTo(local_user.capital_id.toString(), local_element[0]).length;
									
									has_local_capital = (local_distance <= config.ignore_adjacency_for_capital_distance) ? true : has_local_capital;
								}
							}
							
							if (!has_local_capital) changeProvinceScore(local_element[0], local_score);
						}
					}
					
					//Imperial Provinces AI
					{
						//Check to make sure that AI is imperialist
						if (usr.ai.imperial_ai) {
							var current_target_provinces = []; //[province_id, importance_modifier]
							
							//Does the AI user type have any preferred colonial provinces?
							if (ai_type.colonial_preferred_provinces[config.map_type]) {
								for (var i = 0; i < ai_type.colonial_preferred_provinces[config.map_type].length; i++) {
									var local_province = ai_type.colonial_preferred_provinces[config.map_type][i];
								
									//Check if any other country's capital is within 20 provinces distance of this province, if so remove it from the list
									if (!isInVicinityOfAnotherCapital(local_province, config.imperial_ignore_border_distance)) {
										current_target_provinces.push([local_province, config.preferred_colonial_provinces_importance+config.imperial_importance]);
									}
								}
							} else {
								//If not, generate random ones based on the AI template's expansionism modifier
								var province_generation_amount = Math.ceil((returnSafeNumber(ai_type.expansionism)*100)*config.expansionism_fraction);
								for (var i = 0; i < province_generation_amount; i++) {
									//Declare instance variables
									var iteration_count = 0;
									var province_found = [false, ""];
									
									while (true) {
										//Abort after 10 failed iterations
										if (iteration_count < 10) {
											//Pick a province, any province
											var picked_random_province = randomNumber(config.min_provinces, config.max_provinces).toString();
											
											//Check if picked random province is taken by another nation
											province_found = (!getProvince(picked_random_province)) ? [true, picked_random_province] : province_found;
											province_found = (isInVicinityOfAnotherCapital(local_province, config.imperial_ignore_border_distance)) ? false : province_found;
											
											//Break if valid province is found
											if (province_found[0]) break;
										} else {
											break;
										}
									}
									
									//Push province to current_target_provinces
									var adjacency_importance = Math.max((provinces[province_found[1]].adjacencies.length/config.adjacency_high_count)*config.imperialism_adjacency_province, 0);
									
									if (province_found[0]) current_target_provinces.push([province_found[1], adjacency_importance]);
								}
							}
							
							//Begin sorting current_target_provinces, and adding them to colonisation_matrix
							for (var i = 0; i < current_target_provinces.length; i++) {
								try {
									changeProvinceScore(current_target_provinces[i][0], current_target_provinces[i][1]);
								} catch {}
							}
						}
					}
					
					//Modify by expansionism
					var colonisation_province_limit = config.expansionism_fraction*config.max_provinces*returnSafeNumber(ai_type.expansionism, 1); //Let's say they're willing to take 80 provinces
					var expansionism_willingness = 1-(usr.provinces/colonisation_province_limit);
					
					for (var i = 0; i < colonisation_matrix.length; i++) {
						colonisation_matrix[i][1] = colonisation_matrix[i][1]*expansionism_willingness;
					}
					
					//Trim out all provinces with an importance score of zero or less, or that are already colonised
					var zero_scores = [];
					for (var i = 0; i < colonisation_matrix.length; i++) {
						if (colonisation_matrix[i][1] <= 0) zero_scores.push(colonisation_matrix[i]);
						if (getProvince(colonisation_matrix[i][0], "owner")) zero_scores.push(colonisation_matrix[i]);
					}
					
					for (var i = 0; i < zero_scores.length; i++) {
						for (var x = 0; x < colonisation_matrix.length; x++) {
							if (colonisation_matrix[x] == zero_scores[i]) colonisation_matrix.splice(x, 1);
						}
					}
				}
			} catch {}
			
			//Automatically sort colonisation_matrix by province score
			colonisation_matrix.sort((a, b) => b[1]-a[1]);
			
			//Return statement
			return colonisation_matrix;
		}
		
		function generateColonistMatrix (arg0_user) {
			//Convert from parameters
			var user_id = arg0_user;
			var usr = (main.users[arg0_user]) ? main.users[arg0_user] : undefined;
			
			//Declare instance variables
			var crafting_matrix = []; //[[colonial_unit, crafting_amount]]
			var ranked_colonial_units = []; //Sorts available colonial units by highest colonise_provinces
			
			var temp_crafting_obj = {}; //Temporary crafting object used for holding units
			
			//Only begin processing if user has AI
			if (usr) {
				try {
					var local_user = JSON.parse(JSON.stringify(usr));
					
					//Initialise ranked_colonial_units
					for (var i = 0; i < usr.available_units.length; i++) {
						var local_unit = config.unit_stats[usr.available_units[i]];
						if (local_unit.colonise_provinces) ranked_colonial_units.push([usr.available_units[i], local_unit.colonise_provinces]);
					}
					//Sort ranked_colonial_units
					ranked_colonial_units.sort((a, b) => b[1]-a[1]);
					
					//After initialisation, begin looking through ranked_colonial_units
					function fetchAvailableColonialUnit () { //This function returns 1 colonial unit at a time, but is undefined if one can't be found. Subtracts from local_user object.
						//Declare instance variables
						var available_colonial_unit = "";
						
						for (var i = ranked_colonial_units.length-1; i >= 0; i--) { //Loop through backwards to get the highest available colonial unit
							var local_unit_cost = getCraftingCost(user_id, ranked_colonial_units[i][0], 1);
							var all_costs = Object.keys(local_unit_cost);
							var checks_met = 0;
							
							var available_expeditions = local_user.modifiers.maximum_expeditions-local_user.expeditions.length;
							var total_colonial_units = 0; //How many colonial units are in this user's possession?
							for (var x = 0; x < ranked_colonial_units.length; x++) {
								total_colonial_units += local_user.military[ranked_colonial_units[x][0]];
							}
							
							//Check that user has slots available, barring current colonial units
							if (available_expeditions-total_colonial_units > 0) {
								//Check that user has resources
								for (var x = 0; x < all_costs.length; x++) {
									var local_cost = [local_unit_cost[all_costs[x]], all_costs[x]];
									
									if (config.pop_array.includes(local_cost[1])) { //Pop handler
										var available_manpower = local_user[local_cost[1]]-local_user["used_" + local_cost[1]];
										if (available_manpower >= local_cost[0]) {
											checks_met++;
										}
									} else if (config.materials.includes(local_cost[1])) { //Goods handler
										if (local_user.inventory[local_cost[1]] >= local_cost[0]) {
											checks_met++;
										}
									} else { //Catch-all
										if (local_user[local_cost[1]] >= local_cost[0]) {
											checks_met++;
										}
									}
								}
								console.log("Checks Met: " + checks_met);
								console.log("Costs Length: " + all_costs.length);
								if (checks_met >= all_costs.length) {
									//Restore all costs of previous available_colonial_unit if there was one
									if (available_colonial_unit != "") {
										var previous_unit_cost = getCraftingCost(user_id, available_colonial_unit, 1);
										var all_previous_costs = Object.keys(previous_unit_cost);
										
										for (var x = 0; x < all_previous_costs.length; x++) {
											var local_cost = [previous_unit_cost[all_previous_costs[x]], all_previous_costs[x]];
											if (config.pop_array.includes(local_cost[1])) {
												local_user["used_" + local_cost[1]] += local_cost[0];
											} else if (config.materials.includes(all_previous_costs[x][1])) {
												local_user.inventory[local_cost[1]] -= local_cost[0];
											} else {
												local_user[local_cost[1]] -= local_cost[0];
											}
										}
									}
									
									//Set valid colonial unit
									available_colonial_unit = ranked_colonial_units[i][0];
									
									//Remove all costs from analogue user
									for (var x = 0; x < all_costs.length; x++) {
										var local_cost = [local_unit_cost[all_costs[x]], all_costs[x]];
										if (config.pop_array.includes(local_cost[1])) {
											local_user["used_" + local_cost[1]] += local_cost[0];
										} else if (config.materials.includes(local_cost[1])) {
											local_user.inventory[local_cost[1]] -= local_cost[0];
										} else {
											local_user[local_cost[1]] -= local_cost[0];
										}
									}
								}
							}
						}
						
						//Return available_colonial_unit if valid
						return (available_colonial_unit != "") ? available_colonial_unit : undefined;
					}
					
					//While loop to max out temp_crafting_obj
					while (true) {
						var available_colonial_unit = fetchAvailableColonialUnit();
						if (available_colonial_unit) {
							//Add to temp_crafting_obj
							temp_crafting_obj[available_colonial_unit] = (temp_crafting_obj[available_colonial_unit]) ? temp_crafting_obj[available_colonial_unit]+1 : 1;
						} else {
							//Break loop if no available colonial unit could be found
							break;
						}
					}
					
					//Translate temp_crafting_obj to array
					var all_temp_keys = Object.keys(temp_crafting_obj);
					for (var i = 0; i < all_temp_keys.length; i++) crafting_matrix.push([all_temp_keys[i], temp_crafting_obj[all_temp_keys[i]]]);
					
					//Sort crafting_matrix
					crafting_matrix.sort((a, b) => b[1]-a[1]);
					
					//Return crafting matrix
					return crafting_matrix;
				} catch (e) {
					console.log(e);
				}
			}
		}
		
		function generateGoodsMatrix (arg0_user) {
			//Convert from parameters
			var user_id = arg0_user;
			var usr = (main.users[arg0_user]) ? main.users[arg0_user] : undefined;
			
			//Declare instance variables, functions
			var goods_matrix = {};
			
			function changeGoodsScore (arg0_good_type, arg1_amount) {
				//Convert from parameters
				var good_type = arg0_good_type;
				var amount = arg1_amount;
				
				//Change score
				goods_matrix[good_type] = (goods_matrix[good_type]) ? goods_matrix[good_type] + amount : amount;
			}
			
			//Loop through all available buildings and units
			try {
				//Buildings
				for (var i = 0; i < usr.available_buildings.length; i++) {
					var current_building_demand = getBuildingCost(user_id, usr.available_buildings[i]);
					var current_building_keys = Object.keys(current_building_demand);
					
					for (var x = 0; x < current_building_keys.length; x++) {
						var current_resource_name = current_building_keys[x];
						var current_resource_amount = current_building_demand[current_building_keys[x]];
						
						//Make sure good is not pop, money, or CP
						if (!config.pop_array.includes(current_resource_name) && current_resource_name != "money" && current_resource_name.indexOf("_cp") == -1) {
							//Add resource score up to a maximum of 10
							current_resource_amount = (current_resource_amount > config.maximum_good_importance_from_building) ? config.maximum_good_importance_from_building : current_resource_amount;
							changeGoodsScore(current_resource_name, current_resource_amount);
						}
					}
				}
				
				//Units
				for (var i = 0; i < usr.available_units.length; i++) {
					var current_unit_demand = getCraftingCost(user_id, usr.available_units[i]);
					var current_unit_keys = Object.keys(current_unit_demand);
					
					for (var x = 0; x < current_unit_keys.length; x++) {
						var current_resource_name = current_unit_keys[x];
						var current_resource_amount = current_unit_demand[current_unit_keys[x]];
						
						//Make sure good is not pop, money, or CP
						if (!config.pop_array.includes(current_resource_name) && current_resource_name != "money" && current_resource_name.indexOf("_cp") == -1) {
							//Add resource score up to a maximum of 10
							current_resource_amount = (current_resource_amount > config.maximum_good_importance_from_building) ? config.maximum_good_importance_from_building : current_resource_amount;
							changeGoodsScore(current_resource_name, current_resource_amount);
						}
					}
				}
				
				//Modify by current economic surplus/deficit scores
				for (var i = 0; i < config.materials.length; i++) {
					var current_production = getProduction(user_id, config.materials[i], true);
					if (current_production) {
						//Modify current score
						var average_output = Math.ceil((current_production[0]+current_production[1])/2);
						if (average_output <= 0) changeGoodsScore(config.materials[i], average_output*config.deficit_importance);
						if (average_output > 0) changeGoodsScore(config.materials[i], average_output*config.surplus_importance);
					}
				}
				
				//Return statement
				return goods_matrix;
			} catch {}
		}
	
		function generateProductionChains (arg0_user) {
			//Convert from parameters
			var user_id = arg0_user;
			var usr = (main.users[arg0_user]) ? main.users[arg0_user] : undefined;
			
			//Declare instance variables
			var production_chains = {};
			
			/*
				OBJECT DATA STRUCTURE: Data inaccurate and given for example only.
				artillery: {
					//production_process: [[]] //3-step process involving iron, coal > steel > artillery
					
					//Cheapest building found from ((total_average_building_cost-average_building_cost)+(average_resource_cost)+(fiscal_cost/(average_resource_cost/fiscal_cost)))*(average_resource_output_of_required_materials)
					//Object would return [score, [required_material_one, required_material_two]]
					
					//This would repeat as an iterative process until all resources were covered by one building or another, all relevant buildings would be added initially - highest scores would be attempted to be built first, with lower scores being built later if higher scores failed
					
					building_scores: {
						iron_mines: [43, ["iron"], []], //[score, production_array, consumption_array]
						coal_mines: [20, ["coal"], []],
						steelworks: [35, ["steel"], ["iron", "coal"]],
						foundries: [15, ["steel"], ["iron", "coal"]],
						artillery_factories: [20, ["artillery"], ["steel"]]
					}
				}
			*/
			
			if (usr) {
				try {
					for (var i = 0; i < config.materials.length; i++) {
						var cheapest_production = {}; //Used for storing the cheapest production counts for this processed good. (See production_process for more information)
						var good_obj = {};
							good_obj.building_scores = {};
						var is_processed_material = false;
						
						//1. Figure out if the material is a processed good or not
						for (var x = 0; x < config.buildings.length; x++) {
							var building_obj = config.building_stats[config.buildings[x]];
							var includes_material = false;
							
							if (building_obj.produces && building_obj.cost_per_turn) {
								for (var y = 0; y < building_obj.produces.length; y++) {
									includes_material = (building_obj.produces[y][1] == config.materials[i]) ? true : includes_material;
								}
								if (includes_material) is_processed_material = true;
							}
						}
						
						//2. Check all buildings to see whether good is a processed material/score all buildings
						for (var x = 0; x < config.buildings.length; x++) {
							var building_obj = config.building_stats[config.buildings[x]];
							var building_score = 0;
							
							if (building_obj.produces) {
								for (var y = 0; y < building_obj.produces.length; y++) {
									includes_material = (building_obj.produces[y][1] == config.materials[i]) ? true : includes_material;
								}
							}
							
							//Make sure that the actual material is included in production
							if (building_obj.produces) {
								var average_building_cost;
								var average_resource_cost;
								var building_consumption_array = [];
								var building_production_array = [];
								var fiscal_cost = 0;
								var has_resource_cost = false;
								var total_building_cost = 0;
								var total_building_fields = 0;
								var total_output = 0;
								var total_output_fields = 0;
								var total_resource_cost = 0;
								var total_resource_fields = 0;
								
								//Check if building has build cost
								if (building_obj.costs) {
									for (var y = 0; y < building_obj.costs.length; y++) {
										var building_cost_modifier = (config.pop_array.includes(building_obj.costs[y][1])) ? 1 : usr.modifiers.building_cost;
										//Include inventory in calculations as a total fraction of importance (less availability means a lower score)
										if (config.materials.includes(building_obj.costs[y][1])) {
											total_building_cost += Math.ceil(usr.inventory[building_obj.costs[y][1]]/(building_obj.costs[y][0]*building_cost_modifier));
											total_building_fields++;
										}
									}
								}
								
								//Check if building has resource cost (this is how we know it's a processing facility)
								if (building_obj.cost_per_turn) {
									for (var y = 0; y < building_obj.cost_per_turn.length; y++) {
										has_resource_cost = (config.materials.includes(building_obj.cost_per_turn[y][1])) ? true : has_resource_cost;
										
										//Add to either fiscal or total_resource_cost
										if (config.materials.includes(building_obj.cost_per_turn[y][1])) {
											if (Array.isArray(building_obj.cost_per_turn[y][0])) {
												total_resource_cost += Math.ceil((building_obj.cost_per_turn[y][0][0]+building_obj.cost_per_turn[y][0][1])/2);
											} else {
												total_resource_cost += Math.ceil(building_obj.cost_per_turn[y][0]);
											}
											
											building_consumption_array.push(building_obj.cost_per_turn[y][1]);
											total_resource_fields++;
										} else if (building_obj.cost_per_turn[y][1] == "money") {
											if (Array.isArray(building_obj.cost_per_turn[y][0])) {
												fiscal_cost += Math.ceil((building_obj.cost_per_turn[y][0][0]+building_obj.cost_per_turn[y][0][1])/2);
											} else {
												fiscal_cost += Math.ceil(building_obj.cost_per_turn[y][0]);
											}
										}
									}
								}
								
								//Get output metrics
								var building_production = getBuildingProduction(user_id, config.buildings[x]);
								var building_production_keys = Object.keys(building_production);
								for (var y = 0; y < building_production_keys.length; y++) {
									var production_good = building_production[building_production_keys[y]];
									
									if (config.materials.includes(building_production_keys[y])) {
										total_output += Math.ceil((production_good[0]+production_good[1])/2);
										total_output_fields++;
										building_production_array.push(building_production_keys[y]);
									}
								}
								
								//Set average_building_cost, average_resource_cost
								average_building_cost = (total_building_fields != 0) ? Math.ceil(total_building_cost/total_building_fields) : 0;
								average_resource_cost = (total_resource_fields != 0) ? Math.ceil(total_resource_cost/total_resource_fields) : 0;
								average_resource_output = (total_output_fields != 0) ? Math.ceil(total_output/total_output_fields) : 0;
								//Set building_score
								building_score += returnSafeNumber(average_resource_cost, 1);
								building_score += returnSafeNumber((fiscal_cost/(average_resource_cost/fiscal_cost)), 1);
								building_score = returnSafeNumber(building_score*average_resource_output, 1);
								
								building_consumption_array = unique(building_consumption_array);
								building_production_array = unique(building_production_array);
								
								good_obj.building_scores[config.buildings[x]] = [building_score, building_production_array, building_consumption_array];
							}
						}
						
						//3. Compile list of required materials for processed good production
						var current_materials = [[config.materials[i], 0]];
						var depth = 1;
						var has_all_materials = false;
						
						while (true) {
							//Pretend this is a first layer search
							var all_production_buildings = Object.keys(good_obj.building_scores);
							for (var x = 0; x < all_production_buildings.length; x++) {
								if (usr.available_buildings.includes(all_production_buildings[x])) {
									var local_building = good_obj.building_scores[all_production_buildings[x]];
									var produces_required_material = false;
									
									for (var y = 0; y < current_materials.length; y++) {
										produces_required_material = (local_building[1].includes(current_materials[y][0])) ? true : produces_required_material;
									}
									
									//If it produces the required material, then we're going to need to append whatever's in its consumption array to current_materials, if possible
									if (produces_required_material) {
										//console.log("IT PRODUCES THE REQUIRED MATERIAL!");
										for (var y = 0; y < local_building[2].length; y++) {
											var material_included = false;
											for (var z = 0; z < current_materials.length; z++) {
												if (current_materials[z][0] == local_building[2][y]) material_included = true;
											}
											
											if (!material_included) current_materials.push([local_building[2][y], depth]);
										}
									}
								}
							}
							
							depth++;
							if (depth > 20) break;
						}
						
						//Sort current_materials by depth, ascending order
						current_materials.sort((a, b) => a[1]-b[1]);
						
						//Remove all building_scores that don't contain a useful material
						var unprocessed_building_scores = Object.keys(good_obj.building_scores);
						for (var x = 0; x < unprocessed_building_scores.length; x++) {
							var has_useful_material = false;
							var local_building_score = good_obj.building_scores[unprocessed_building_scores[x]];
							
							for (var y = 0; y < current_materials.length; y++) {
								if (local_building_score[1].includes(current_materials[y][0])) has_useful_material = true;
							}
							
							if (!has_useful_material || !usr.available_buildings.includes(unprocessed_building_scores[x])) delete good_obj.building_scores[unprocessed_building_scores[x]];
						}
						
						//4. Log everything to production_process now that it's done!
						for (var x = 0; x < current_materials.length; x++) {
							var all_building_scores = Object.keys(good_obj.building_scores);
							var material_producing_buildings = [];
							
							//Find building_scores that produce the material needed and push to material_producing_buildings
							for (var y = 0; y < all_building_scores.length; y++) {
								var local_building_score = good_obj.building_scores[all_building_scores[y]];
								if (local_building_score[1].includes(current_materials[x][0])) material_producing_buildings.push(all_building_scores[y]);
							}
							
							//Find the highest scoring building for this material and place it in the cheapest_production object - WIP
							for (var y = 0; y < material_producing_buildings.length; y++) {
								if (!cheapest_production[current_materials[x][0]]) {
									cheapest_production[current_materials[x][0]] = [material_producing_buildings[y], good_obj.building_scores[material_producing_buildings[y]][0]];
								} else {
									if (good_obj.building_scores[material_producing_buildings[y]][0] > cheapest_production[current_materials[x][0]][1]) cheapest_production[current_materials[x][0]][1] = good_obj.building_scores[material_producing_buildings[y]][0];
								}
							}
						}
						
						//Append to data object
						good_obj.production_process = cheapest_production;
						production_chains[config.materials[i]] = good_obj;
					}
					
					return production_chains;
				} catch (e) {
					console.log(e);
				}
			}
		}
		
		function generateReformsMatrix (arg0_user) { //WIP
			//Convert from parameters
			var user_id = arg0_user;
			var usr = (main.users[arg0_user]) ? main.users[arg0_user] : undefined;
			
			//Declare instance variables, functions
		}
		
		function generateSellingMatrix (arg0_user) {
			//Convert from parameters
			var user_id = arg0_user;
			var usr = (main.users[arg0_user]) ? main.users[arg0_user] : undefined;
			
			//Declare instance variables, functions
			var selling_matrix = [];
			
			function changeSellingScore (arg0_good_type, arg1_amount) {
				//Convert from parameters
				var good_type = arg0_good_type;
				var amount = arg1_amount;
				
				//Declare instance variables
				var index_found = [false, -1];
				
				for (var i = 0; i < selling_matrix.length; i++) {
					index_found = (selling_matrix[i][0] == good_type) ? [true, i] : index_found;
				}
				
				if (index_found[0]) {
					selling_matrix[index_found[1]][1] += amount;
				} else {
					selling_matrix.push([good_type, amount]);
				}
			}
			
			//Make sure user isn't undefined before giving a matrix
			if (usr) {
				var user_production = getProduction(user_id, "all", false);
				var goods_importance = generateGoodsMatrix(user_id);
				
				for (var i = 0; i < config.resource_buy_list.length; i++) {
					var local_value = usr.inventory[config.resource_buy_list[i]];
					var resource_name = config.resource_buy_list[i];
					
					//Set selling score, but only if a surplus of the material is currently supplied
					if (local_value > 0) {
						var current_market_price = main.users.global[resource_name + "_sell_price"];
						var next_turn_surplus;
						
						//Declare next_turn_surplus based on config modifiers
						if (user_production) {
							next_turn_surplus = (user_production[resource_name]) ? Math.ceil((user_production[resource_name][0]+user_production[resource_name][1])/2) : 0;
						} else {
							next_turn_surplus = 0;
						}
						
						next_turn_surplus = ((next_turn_surplus == 0 && usr.country_age < config.ignore_surplus_in_market) || config.ignore_surplus_in_market == 0) ? 1 : next_turn_surplus;
						
						if (next_turn_surplus > 0 || usr.country_age < config.ignore_surplus_in_market) {
							var safe_importance = goods_importance[resource_name];
							if (safe_importance == 0 || safe_importance == undefined) safe_importance = 1;
							changeSellingScore(resource_name, ((current_market_price/safe_importance)*local_value*next_turn_surplus));
						}
					}
				}
				
				//Sort selling array
				selling_matrix.sort((a, b) => b[1]-a[1]);
				
				//Return statement
				return selling_matrix;
			}
		}
		
		function generateTechnologyMatrix (arg0_user) {
			//Convert from parameters
			var user_id = arg0_user;
			var usr = (main.users[arg0_user]) ? main.users[arg0_user] : undefined;
			
			//Declare instance variables, functions
			var available_techs = [];
			var technology_matrix = [];
			
			function changeTechScore (arg0_tech_name, arg1_amount) {
				//Convert from parameters
				var tech_name = arg0_tech_name;
				var amount = arg1_amount;
				
				//Declare instance variables
				var index_found = [false, -1];
				
				for (var i = 0; i < technology_matrix.length; i++) {
					index_found = (technology_matrix[i][0] == tech_name) ? [true, i] : index_found;
				}
				
				if (index_found[0]) {
					technology_matrix[index_found[1]][1] += amount;
				} else {
					technology_matrix.push([tech_name, amount]);
				}
			}
			
			//Make sure user is at least defined
			if (usr) {
				//Try/catch block for user error trapping
				try {
					//Fetch available_techs
					for (var i = 0; i < config.valid_technologies.length; i++) {
						var tech_available = false;
						
						if (config.technology[config.valid_technologies[i]].prerequisite_techs) {
							var prerequisite_checks = 0;
							for (var x = 0; x < config.technology[config.valid_technologies[i]].prerequisite_techs.length; x++) {
								for (var y = 0; y < usr.researched_technologies.length; y++) {
									if (config.technology[config.valid_technologies[i]].prerequisite_techs[x] == usr.researched_technologies[y]) {
										prerequisite_checks++;
									}
								}
							}
							
							if (prerequisite_checks == config.technology[config.valid_technologies[i]].prerequisite_techs.length) {
								tech_available = true;
							}
						} else { //No prerequisite checks found, so must be a starting tech
							tech_available = true;
						}
						
						//Check if user has already researched tech/is researching tech
						for (var x = 0; x < usr.researched_technologies.length; x++) {
							tech_available = (usr.researched_technologies[x] == config.valid_technologies[i]) ? false : tech_available;
						}
						for (var x = 0; x < usr.researching.length; x++) {
							try {
								tech_available = (usr.researching[x][1] == config.valid_technologies[i]) ? false : tech_available;
							} catch {}
						}
						
						//Append to valid tech dump for later categorisation
						if (tech_available) {
							available_techs.push(config.valid_technologies[i]);
						}
					}
					
					//Rank available techs
					for (var i = 0; i < available_techs.length; i++) {
						//Get lines of code per tech
						var tech_importance = 1;
						var local_tech = config.technology[available_techs[i]];
						
						//Fetch tech importance based on lines of code
						if (local_tech.unlocks) tech_importance += local_tech.unlocks.toString().split(";").length;
						
						//Ahead of time penalty calculations
						var aot_penalty = 0;
						var final_aot_penalty = 1;
						var has_aot_penalty = false;
						for (var x = 0; x < config.ahead_of_time.length; x++) {
							if (main.year >= config.ahead_of_time[x][0] && main.year < config.ahead_of_time[x][1]) {
								aot_penalty = 2/config.ahead_of_time[x][2];
							}
						}
						
						if (local_tech.year) {
							var aot_years = 0;
							
							if (main.year < local_tech.year) {
								has_aot_penalty = true;
								aot_years = local_tech.year-main.year;
								final_aot_penalty = (aot_years*aot_penalty)+1;
							}
						}
						
						var total_research_cost = Math.round(local_tech.research_cost*final_aot_penalty);
								
						changeTechScore(available_techs[i], (tech_importance*1000)/returnSafeNumber(total_research_cost, 1));
					}
					
					//Sort technology_matrix
					technology_matrix.sort((a, b) => b[1]-a[1]);
					
					//Return statement
					return technology_matrix;
				} catch (e) {
					console.error(e);
				}
			}
		}
	}
	
	//Operating functions
	{
		function addCommand (arg0_id, arg1_string, arg2_function, arg3_conditional) {
			//Convert from parameters
			var user_id = arg0_id;
			var current_command = arg1_string;
			var execute_function = arg2_function;
			var conditional_function = arg3_conditional;
			
			command_queue.push([user_id, current_command, execute_function, conditional_function]);
			main.users.global.command_queue = command_queue;
		}
		
		function arabicise (arg0_number) {
			//Convert from parameters
			var num = arg0_number;
			
			//Declare instance variables and reference arrays
			var array = num.split(""),
				conversion = { M: 1000, D: 500, C: 100, L: 50, X: 10, V: 5, I: 1, m: 1000, d: 500, c: 100, l: 50, x: 10, v: 5, i: 1 },
				total = 0,
				current,
				current_value,
				next,
				next_value;
			
			//Loop through provided number string
			for (var i = 0; i < array.length; i++) {
				current = array[i];
				current_value = conversion[current];
				
				next = array[i+1];
				next_value = conversion[next];
				
				if (current_value < next_value) {
					total -= current_value;
				} else {
					total += current_value;
				}
			}
			
			//Return statement
			return total;
		}
		
		function checkVassals (arg0_overlord, arg1_vassal) {
			//Convert from parameters
			var overlord_id = arg0_overlord;
			var vassal_id = arg1_vassal;
			
			return main.users[overlord_id].vassals.includes(vassal_id);
		}
		
		function cityNameUsed (arg0_name) {
			//Convert from parameters
			var city_name = arg0_name;
			
			//Declare instance variables
			var is_used = false;
							
			for (var i = 0; i < main.user_array.length; i++) {
				if (main.users[main.user_array[i]].cities.city_array.length > 0) {
					for (var x = 0; x < main.users[main.user_array[i]].cities.city_array.length; x++) {
						if (main.users[main.user_array[i]].cities[main.users[main.user_array[i]].cities.city_array[x]].name.toLowerCase() == city_name.toLowerCase()) {
							is_used = true;
						}
					}
				}
			}
			
			//Return statement
			return is_used;
		}
		
		function deleteElement (arg0_array, arg1_element, arg2_mode) {
			for (var i = 0; i < arg0_array.length; i++) {
				if (arg0_array[i] == arg1_element) {
					arg0_array.splice(i, 1);
				}
			}
			if (arg2_mode != undefined) {
				var usr = arg2_mode[0];
				if (arg2_mode[1] == "obsolete_units") {
					if (usr.obsolete_units == undefined) {
						usr.obsolete_units = [arg1_element];
					} else {
						var already_in_array = false;
						for (var i = 0; i < usr.obsolete_units.length; i++) {
							if (usr.obsolete_units[i] == arg1_element) {
								already_in_array = true;
							}
						}
						if (already_in_array == false) {
							usr.obsolete_units.push(arg1_element);
						}
					}
				}
			}
		}
		
		function deordinalise (arg0_string) {
			//Convert from parameters, add reference arrays
			var deordinalised_string = arg0_string;
			var ordinals = ["st", "nd", "rd", "th"];
			
			//Split up into multiple chunks
			deordinalised_string = (deordinalised_string.includes(" ")) ? deordinalised_string.split(" ") : [deordinalised_string];
			
			//Remove stray ordinals
			for (var i = 0; i < deordinalised_string.length; i++) {
				for (var x = 0; x < ordinals.length; x++) {
					if (deordinalised_string[i].indexOf(ordinals[x]) == 0) {
						deordinalised_string[i] = deordinalised_string[i].replace(ordinals[x], "");
					}
				}
				if (deordinalised_string[i] == "") {
					deordinalised_string.splice(i, 1);
				}
			}
			
			//Iterate over to purge ordinals
			for (var i = 0; i < deordinalised_string.length; i++) {
				//Look for ordinal
				var ordinal_found = false;
				for (var x = 0; x < ordinals.length; x++) {
					if (deordinalised_string[i].indexOf(ordinals[x]) != -1) {
						ordinal_found = true;
					}
				}
				
				var total_ordinal_amount = (ordinal_found) ? 2 : 0;
				var ordinal_percentage = total_ordinal_amount/deordinalised_string[i].length;
				
				if (ordinal_percentage > 0.50) { //Ordinal makes up majority of string, so delete
					deordinalised_string.splice(i, 1);
				}
			}
			
			return deordinalised_string.join(" ").trim();
		}
			
		function distribute (length, value) {
			if (length <= 1)
				return [value];
			var half = Math.floor(length / 2),
				dist = Math.floor(Math.random() * value);
			return distribute(half, dist).concat(distribute(length-half, value-dist));
		}
		
		function equalsIgnoreCase (arg0, arg1) {
			if (arg0.toLowerCase() == (bot_prefix + arg1).toLowerCase()) {
				return true;
			} else {
				return false;
			}
		}
		
		function generateID () {
			var return_id;
			while (true) {
				var current_id = randomNumber(0, 100000000);
				
				if (!main.user_array.includes(current_id.toString())) {
					return_id = current_id.toString();
					break;
				}
			}
			
			//Return statement
			return return_id;
		}
		
		function getAllProvincesInRange (arg0_province, arg1_range) {
			//Convert from parameters
			var province_id = arg0_province.toString();
			var range = arg1_range;
			
			var province_cache = [province_id];
			var new_province_cache = [];
			
			for (var i = 0; i < range; i++) {
				for (var x = 0; x < province_cache.length; x++) {
					var local_prov = provinces[province_cache[x]];
					
					if (local_prov) {
						for (var y = 0; y < local_prov.adjacencies.length; y++) {
							var is_included = false;
							for (var z = 0; z < province_cache.length; z++) {
								if (local_prov.adjacencies[y] == province_cache[z]) {
									is_included = true;
								}
							}
							
							if (!is_included) {
								new_province_cache.push(local_prov.adjacencies[y]);
							}
						}
					}
				}
				for (var x = 0; x < new_province_cache.length; x++) {
					province_cache.push(new_province_cache[x]);
				}
				new_province_cache = [];
			}
			
			return province_cache;
		}
		
		function getArmiesInProvince (arg0_province, arg1_user) {
			//Convert from parameters
			var province_id = arg0_province;
			var usr = (arg1_user) ? main.users[arg1_user] : undefined;
			
			//Declare instance variables
			var army_array = [];
			
			//Iterate over all users and their respective armies
			if (!usr) {
				for (var i = 0; i < main.user_array.length; i++) {
					var local_user = main.users[main.user_array[i]];
					for (var x = 0; x < local_user.armies.army_array.length; x++) {
						var local_army = local_user.armies[local_user.armies.army_array[x]];
						if (local_army.province.toString() == province_id) {
							army_array.push(local_army);
						}
					}
				}
			} else {
				for (var i = 0; i < usr.armies.army_array.length; i++) {
					var local_army = usr.armies[usr.armies.army_array[i]];
					if (local_army.province.toString() == province_id) {
						army_array.push(local_army);
					}
				}
			}
			
			//Return statement
			return (army_array.length > 0) ? army_array : undefined;
		}
		
		function getArmy (arg0_user, arg1_name) {
			//Convert from parameters
			var user_id = arg0_user;
			var army_name = arg1_name;
			
			//Declare instance variables
			var army_exists = [false, ""];
				
			//Check if main user is undefined or not
			if (main.users[arg0_user] != undefined) {
				//Declare local variables
				var usr = main.users[arg0_user];
				
				//Iterate over all armies - soft match
				for (var i = usr.armies.army_array.length; i--;) {
					var local_army = usr.armies[usr.armies.army_array[i]];
					if (local_army.name.toLowerCase().indexOf(army_name.toLowerCase()) != -1) {
						army_exists = [true, local_army];
					}
				}
				
				//Iterate over all armies - hard match
				for (var i = usr.armies.army_array.length; i--;) {
					var local_army = usr.armies[usr.armies.army_array[i]];
					if (local_army.name.toLowerCase() == army_name.toLowerCase()) {
						army_exists = [true, local_army];
					}
				}
			}
			
			//Return statement
			return (army_exists[0]) ? army_exists[1] : undefined;
		}
		
		function getAvailableBuildingSlot (arg0_user, arg1_building_type) {
			//Convert from parameters
			var user_id = arg0_user;
			var usr = (main.users[arg0_user]) ? main.users[arg0_user] : undefined;
			var building_category = config.building_stats[arg1_building_type].category;
			var building_name = arg1_building_type;
			var building_obj = config.building_stats[arg1_building_type];
			
			//Declare instance variables
			var buildings_under_construction = 0;
			if (usr) {
				var found_city = [false, "", 0];
				
				//Check for unlimited slots
				if (!building_obj.unlimited_slots) {
					for (var i = 0; i < usr.cities.city_array.length; i++) {
						var buildings_under_construction = getBuildingsUnderConstruction(user_id, usr.cities.city_array[i], building_name);
						var city_obj = usr.cities[usr.cities.city_array[i]];
						
						//Check whether slots are individual or not
						if (!isOccupied(usr.cities.city_array[i])) {
							if (!building_obj.separate_building_slots) {
								try {
									var city_building_slots = getBuildingSlots(user_id, usr.cities.city_array[i], building_category);
									found_city = (city_building_slots[0] >= 0) ? [true, usr.cities.city_array[i], city_building_slots[0]] : found_city;
								} catch {}
							} else {
								//Get total allowed building slots
								if (city_obj.buildings[building_name]+buildings_under_construction <= usr.modifiers[building_name]) found_city = [true, usr.cities.city_array[i], (usr.modifiers[building_name]-(city_obj.buildings[building_name]+buildings_under_construction))];
							}
						}
					}
				} else {
					found_city = [true, randomElement(usr.cities.city_array), randomNumber(config.split_building_orders, config.split_building_orders*2)];
				}
				
				//Check whether a city could be found or not
				if (found_city[0]) return [found_city[1], found_city[2]];
			}
		}
		
		function getAverageBuildingCost (arg0_user) {
			//Convert from parameters
			var user_id = arg0_user;
			var usr = (main.users[arg0_user]) ? main.users[arg0_user] : undefined;
			
			//Declare instance variables
			var total_average_resource_cost = 0;
			
			try {
				//Go through all buildings and their respective costs
				for (var i = 0; i < usr.available_buildings.length; i++) {
					var building_obj = config.building_stats[usr.available_buildings[i]];
					var building_material_fields = 0;
					var building_total_resource_cost = 0;
					
					if (building_obj.costs) {
						for (var x = 0; x < building_obj.costs.length; x++) {
							var current_material = building_obj.costs[x][1];
							if (config.materials.includes(current_material)) {
								building_total_resource_cost += Math.ceil(building_obj.costs[x][0]*usr.modifiers.building_cost);
								building_material_fields++;
							}
						}
						
						if (building_material_fields > 0) total_average_resource_cost += Math.ceil(building_total_resource_cost/building_material_fields);
					}
				}
				
				//Return statement
				return Math.ceil(total_average_resource_cost/usr.available_buildings.length);
			} catch (e) {
				console.log(e);
			}
		}
		
		function getAverageBuildingOutput (arg0_user) {
			//Convert from parameters
			var user_id = arg0_user;
			var usr = (main.users[arg0_user]) ? main.users[arg0_user] : undefined;
			
			//Declare instance variables
			var total_average_resource_output = 0;
			
			try {
				//Go through all buildings and their respective outputs
				for (var i = 0; i < usr.available_buildings.length; i++) {
					var building_production = getBuildingProduction(user_id, usr.available_buildings[i]);
					var building_production_keys = Object.keys(building_production);
					var total_resource_output = 0;
					var total_resource_fields = 0;
					
					//Get building output
					for (var x = 0; x < building_production_keys.length; x++) {
						var local_value = building_production[building_production_keys[i]];
						if (config.materials.includes(building_production_keys[i])) {
							total_resource_output += Math.ceil((local_value[0]+local_value[1])/2);
							total_resource_fields++;
						}
					}
					
					//Add average resource output to total_average_resource_output
					total_average_resource_output += Math.ceil(total_resource_output/total_resource_fields);
				}
				
				return Math.ceil(total_average_resource_output/usr.available_buildings.length);
			} catch (e) {
				console.log(e);
			}
		}
		
		function getAverageGoods (arg0_user) {
			//Convert from parameters;
			var user_id = arg0_user;
			var usr = (main.users[arg0_user]) ? main.users[arg0_user] : undefined;
			
			//Declare instance variables
			var total_resources = 0;
			
			try {
				if (usr) {
					for (var i = 0; i < config.materials.length; i++) total_resources += usr.inventory[config.materials[i]];
				}
				
				//Return statement
				return Math.ceil(total_resources/config.materials.length);
			} catch {}
		}
		
		function getAverageTechnologyLevel () {
			//Declare instance variables
			var total_technology_count = 0;
			
			//Iterate over all users and add the total technology count for them
			for (var i = 0; i < main.user_array.length; i++) {
				var local_user = main.users[main.user_array[i]];
				if (main.user_array[i] != "213287117017710593") total_technology_count += local_user.researched_technologies.length;
			}
			
			//Return statement
			return Math.ceil(total_technology_count/main.user_array.length);
		}
		
		function getBalanceNextTurn (arg0_user) {
			//Convert from parameters
			var user_id = arg0_user;
			var usr = (main.users[arg0_user]) ? main.users[arg0_user] : undefined;
			
			//Declare instance variables and simulations
			try {
				var temp_usr_obj = JSON.parse(JSON.stringify(usr));
				var local_production = nextTurn(temp_usr_obj, true);
				
				//Return statement
				return usr.money-local_production.money;
			} catch {}
		}
		
		function getBuildingCost (arg0_user, arg1_building_type, arg2_amount) {
			//Convert from parameters
			var user_id = arg0_user;
			var usr = (main.users[arg0_user]) ? main.users[arg0_user] : undefined;
			var building_type = arg1_building_type;
			var amount = (arg2_amount) ? arg2_amount : 1;
			
			//Declare instance variables
			var total_building_cost = {};
			
			//Grab base building cost
			if (usr) {
				try {
					var building_obj = config.building_stats[building_type];
					
					for (var i = 0; i < building_obj.costs.length; i++) {
						//Check to make sure that this is an actual resource, and not a pop value
						var building_cost_modifier = (!config.pop_array.includes(building_obj.costs[i][1])) ? usr.modifiers.building_cost : 1;
						var current_resource_demand = building_obj.costs[i][0]*building_cost_modifier*amount;
						
						//Append to total_building_cost
						total_building_cost[building_obj.costs[i][1]] = (total_building_cost[building_obj.costs[i][1]]) ? total_building_cost[building_obj.costs[i][1]] + current_resource_demand : current_resource_demand;
						total_building_cost[building_obj.costs[i][1]] = Math.ceil(total_building_cost[building_obj.costs[i][1]]);
					}
				} catch {}
			}
			
			//Return statement
			return total_building_cost;
		}
		
		function getBuildingProduction (arg0_user, arg1_building_type, arg2_city_obj) {
			//Convert from parameters
			var user_id = arg0_user;
			var usr = (main.users[arg0_user]) ? main.users[arg0_user] : undefined;
			var building_name = arg1_building_type;
			var city_obj = arg2_city_obj;
			
			//Declare instance variables
			var production_obj = {};
			
			function changeProductionValue (arg0_key, arg1_minmax_argument, arg2_value) {
				//Convert from parameters
				var local_key = arg0_key;
				var min_max_argument = arg1_minmax_argument;
				var local_value = Math.ceil(returnSafeNumber(arg2_value));
				
				//Add to production_obj
				if (production_obj[local_key]) {
					if (min_max_argument == "minimum") {
						production_obj[local_key][0] += local_value;
					} else if (min_max_argument == "maximum") {
						production_obj[local_key][1] += local_value;
					} else { //This will just apply to both minimum and maximum now
						production_obj[local_key][0] += local_value;
						production_obj[local_key][1] += local_value;
					}
				} else {
					if (min_max_argument == "minimum") {
						production_obj[local_key] = [local_value, 0];
					} else if (min_max_argument == "maximum") {
						production_obj[local_key] = [0, local_value];
					} else { //This will just apply to both minimum and maximum now
						production_obj[local_key] = [local_value, local_value];
					}
				}
			}
			
			if (usr) {
				try {
					var building_obj = config.building_stats[building_name];
					
					//Add production
					for (var i = 0; i < building_obj.produces.length; i++) {
						var actual_resource = config.materials.includes(building_obj.produces[i][1]);
						var is_knowledge = (building_obj.produces[i][1] == "knowledge");
						
						//Get actual production efficiency
						var actual_production_efficiency = (building_obj.cost_per_turn) ? usr.modifiers.production_efficiency : 1;
						var actual_rgo_throughput = (usr.modifiers.rgo_throughput < 1) ? usr.modifiers.rgo_throughput : 1;
						
						actual_rgo_throughput = (city_obj.resource == building_obj.produces[i][1]) ? getCityRGOThroughput(city_obj.name) : actual_rgo_throughput;
						
						//This is the only modifier we care for
						actual_production_efficiency = (building_obj.cost_per_turn) ? actual_production_efficiency : actual_rgo_throughput;
						
						if (Array.isArray(building_obj.produces[i][0])) {
							if (!actual_resource) {
								changeProductionValue(building_obj.produces[i][1], "minimum", building_obj.produces[i][0][0]*actual_production_efficiency);
								changeProductionValue(building_obj.produces[i][1], "maximum", building_obj.produces[i][0][1]*actual_production_efficiency);
							} else {
								if (!is_knowledge) {
									changeProductionValue(building_obj.produces[i][1], "minimum", building_obj.produces[i][0][0]*usr.modifiers[building_obj.produces[i][1]]*actual_production_efficiency);
									changeProductionValue(building_obj.produces[i][1], "maximum", building_obj.produces[i][0][1]*usr.modifiers[building_obj.produces[i][1]]*actual_production_efficiency);
								} else {
									changeProductionValue(building_obj.produces[i][1], "minimum", building_obj.produces[i][0][0]*usr.modifiers[building_obj.produces[i][1]]);
									changeProductionValue(building_obj.produces[i][1], "maximum", building_obj.produces[i][0][1]*usr.modifiers[building_obj.produces[i][1]]);
								}
							}
						} else {
							if (!is_knowledge) {
								changeProductionValue(building_obj.produces[i][1], "all", building_obj.produces[i][0]*actual_production_efficiency);
							} else {
								changeProductionValue(building_obj.produces[i][1], "all", building_obj.produces[i][0]);
							}
						}
					}
				} catch {}
			}
			
			//Return statement
			return production_obj;
		}
		
		function getBuildingScore (arg0_user, arg1_building_type) { //Used for non-production buildings
			//Convert from parameters
			var user_id = arg0_user;
			var usr = (main.users[arg0_user]) ? main.users[arg0_user] : undefined;
			var building_name = arg1_building_type;
			var building_obj = config.building_stats[arg1_building_type];
			
			//Declare instance variables
			var average_resource_score = 0;
			var average_total_building_cost = 0;
			var building_score = 0;
			var resource_scores;
			var produces_actions = false;
			var produces_cp = false;
			var produces_housing = false;
			var produces_knowledge = false;
			var total_production_amount = 0;
			var total_resource_score = 0;
			
			//Make sure user is defined before attempting anything
			if (usr) {
				try {
					resource_scores = generateGoodsMatrix(user_id);
					var all_resource_keys = Object.keys(resource_scores);
					
					for (var i = 0; i < all_resource_keys.length; i++) {
						total_resource_score += resource_scores[all_resource_keys[i]];
					}
					
					//Set average resource importance, calculate production booleans
					average_resource_score = Math.ceil(total_resource_score/all_resource_keys.length);
					
					if (building_obj.produces) {
						for (var i = 0; i < building_obj.produces.length; i++) {
							produces_actions = (building_obj.produces[i][1] == "actions") ? true : produces_actions;
							produces_cp = (building_obj.produces[i][1].indexOf("_cp") != -1) ? true : produces_cp;
							produces_knowledge = (building_obj.produces[i][1] == "knowledge") ? true : produces_knowledge;
						}
					}
					produces_housing = (building_obj.houses > 0);
					
					//Now that everything is settled, begin getting total_building_production, count in housing
					var building_production = getBuildingProduction(user_id, building_name);
					var all_production_keys = Object.keys(building_production);
					for (var i = 0; i < all_production_keys.length; i++) if (config.materials.includes(all_production_keys[i])) total_production_amount += Math.ceil((building_production[all_production_keys[i]][0]+building_production[all_production_keys[i]][1])/2);
					if (building_obj.houses > 0) total_production_amount += Math.ceil(building_obj.houses/config.housing_scale_importance);
					
					//Count in descriptions if applicable
					if (building_obj.description) total_production_amount = building_obj.description.split(",").length;
					
					//Get building cost
					var local_building_cost = getBuildingCost(user_id, building_name, 1);
					var all_building_cost_keys = Object.keys(local_building_cost);
					var total_building_cost = 0;
					
					for (var i = 0; i < all_building_cost_keys.length; i++) if (config.materials.includes(all_building_cost_keys[i])) total_building_cost += local_building_cost[all_building_cost_keys[i]];
					
					average_total_building_cost = (building_obj.costs) ? Math.ceil(total_building_cost/building_obj.costs.length) : 0;
					
					//Declare secondary instance variables
					var score_modifier = 0;
					
					var action_importance = average_resource_score*config.action_importance;
					var cp_importance = average_resource_score*config.cp_importance;
					var housing_importance = average_resource_score*config.housing_importance;
					var knowledge_importance = average_resource_score*config.knowledge_importance;
					
					if (produces_actions) score_modifier += action_importance;
					if (produces_cp) score_modifier += cp_importance;
					if (produces_housing) score_modifier += housing_importance;
					if (produces_knowledge) score_modifier += knowledge_importance;
					
					//Return score
					if (produces_actions || produces_cp || produces_housing || produces_knowledge) {
						return Math.ceil(Math.ceil(total_production_amount/average_total_building_cost)*score_modifier);
					} else {
						return Math.ceil(total_production_amount/average_total_building_cost);
					}
				} catch (e) {
					console.log(e);
				}
			}
		}
		
		function getBuildingSlots (arg0_user, arg1_city, arg2_building_category) {
			//Convert from parameters - NOTE: 'all' is a valid parameter for arg1_city
			var user_id = arg0_user;
			var usr = (main.users[arg0_user]) ? main.users[arg0_user] : undefined;
			var city_name = arg1_city;
			var building_category = arg2_building_category;
			
			//Declare instance variables
			var check_cities = (city_name == "all") ? usr.cities.city_array : [city_name];
			var building_slot_array = []; //[spare_building_slots, total_building_slots]
			
			//Check to see if user is defined or not
			if (usr) {
				//Check to see if city exists or not
				for (var i = 0; i < check_cities.length; i++) {
					console.log(check_cities[i]);
					var city_obj = getCity(usr.cities[check_cities[i]].name); //Returns [user_id, city_debug_name, city_obj]
					if (city_obj) {
						var total_buildings_in_category = 0;
						//Now that we have a valid city object, find the total utilised number of building slots, including construction
						{
							
							for (var x = 0; x < config[building_category].length; x++) {
								var building_name = config[building_category][x];
								if (city_obj[2].buildings[building_name] > 0) {
									total_buildings_in_category += returnSafeNumber(city_obj[2].buildings[building_name], 0);
								}
								
								//under_construction array also counts
								for (var y = 0; y < usr.under_construction.length; y++) {
									if (usr.under_construction[y][1] == building_name && usr.under_construction[y][2] == city_obj[1]) {
										total_buildings_in_category += usr.under_construction[y][0];
									}
								}
							}
						}
						
						//Find the total number of building slots for the building category, return -1 if infinite (_disable_slots argument)
						{
							var total_building_slots_in_category = city_obj[2][building_category + "_building_slots"]+usr.modifiers.extra_building_slots;
							total_building_slots_in_category = (config[building_category + "_disable_slots"]) ? -1 : total_building_slots_in_category;
							
							//Set building_slot_array
							building_slot_array = [total_building_slots_in_category-total_buildings_in_category, total_building_slots_in_category];
						}
					}
				}
			}
			
			//Return statement
			return building_slot_array;
		}
		
		function getBuildingsUnderConstruction (arg0_user, arg1_city, arg2_building_type) {
			//Convert from parameters
			var user_id = arg0_user;
			var usr = (main.users[arg0_user]) ? main.users[arg0_user] : undefined;
			var city_name = arg1_city;
			var building_obj = config.building_stats[arg2_building_type];
			var building_type = arg2_building_type;
			
			//Declare instance variables
			var total_under_construction = 0;
			
			try {
				for (var i = 0; i < usr.under_construction.length; i++) {
					if (usr.under_construction[i][1] == building_type && usr.under_construction[i][2] == city_name) total_under_construction += usr.under_construction[i][0];
				}
				
				//Return statement
				return total_under_construction;
			} catch {}
		}
		
		function getCity (arg0_name, arg1_user) {
			//Convert from parameters
			var city_name = arg0_name;
			var user_id = arg1_user;
			
			//Declare instance variables
			var city_exists = [false, ""],
				actual_city_name,
				local_user_array = JSON.parse(JSON.stringify(main.user_array)),
				usr_id;
			
			//Prioritise own country first
			if (user_id) local_user_array.push(user_id);
			
			//Find city
			for (var i = 0; i < local_user_array.length; i++) {
				var local_cities = main.users[local_user_array[i]].cities;
				
				//Soft match
				for (var x = 0; x < local_cities.city_array.length; x++) {
					if (local_cities[local_cities.city_array[x]].name.toLowerCase().indexOf(city_name.toLowerCase()) != -1) {
						city_exists = [true, local_cities[local_cities.city_array[x]]];
						actual_city_name = local_cities.city_array[x];
						usr_id = main.users[local_user_array[i]].id;
					}
				}
			}
			for (var i = 0; i < local_user_array.length; i++) {
				var local_cities = main.users[local_user_array[i]].cities;
				
				//Hard match
				for (var x = 0; x < local_cities.city_array.length; x++) {
					if (local_cities[local_cities.city_array[x]].name.toLowerCase() == city_name.toLowerCase()) {
						city_exists = [true, local_cities[local_cities.city_array[x]]];
						actual_city_name = local_cities.city_array[x];
						usr_id = main.users[local_user_array[i]].id;
					}
				}
			}
			
			//Return statement
			return (city_exists[0]) ? [usr_id, actual_city_name, city_exists[1], getProvince(city_exists[1].province)] : undefined;
		}
		
		function getCityRGOThroughput (arg0_name) {
			//Convert from parameters
			var city_obj = getCity(arg0_name);
			var usr = main.users[city_obj[0]];
			
			return (usr.modifiers.rgo_throughput) + (returnSafeNumber(city_obj[3].supply_limit, config.base_supply_limit)/config.supply_limit_rgo_modifier)*0.01;
		}			
		
		function getCraftingCost (arg0_user, arg1_unit_type, arg2_amount) {
			//Convert from parameters
			var user_id = arg0_user;
			var usr = (main.users[arg0_user]) ? main.users[arg0_user] : undefined;
			var unit_type = arg1_unit_type;
			var amount = (arg2_amount) ? arg2_amount : 1;
			
			//Declare instance variables
			var total_unit_cost = {};
			
			//Grab base building cost
			if (usr) {
				try {
					var unit_obj = config.unit_stats[unit_type];
					
					for (var i = 0; i < unit_obj.costs.length; i++) {
						//Check to make sure that this is an actual resource, and not a pop value
						var current_resource_demand = 0;
						
						//Pop handler
						if (config.pop_array.includes(unit_obj.costs[i][1])) {
							current_resource_demand = unit_obj.manpower_cost*unit_obj.quantity*Math.ceil(amount);
						} else {
							//CP handler
							if (unit_obj.costs[i][1].indexOf("_cp") != -1) {
								current_resource_demand = Math.ceil(unit_obj.costs[i][0]*usr.modifiers.training_cost);
							} else {
								//Resources & Money handler
								current_resource_demand = Math.ceil(unit_obj.costs[i][0]*usr.modifiers.unit_cost);
							}
						}
						
						//Append to total_unit_cost
						total_unit_cost[unit_obj.costs[i][1]] = (total_unit_cost[unit_obj.costs[i][1]]) ? total_unit_cost[unit_obj.costs[i][1]] + current_resource_demand : current_resource_demand;
						total_unit_cost[unit_obj.costs[i][1]] = Math.ceil(total_unit_cost[unit_obj.costs[i][1]]);
					}
				} catch {}
			}
			
			//Return statement
			return total_unit_cost;
		}
		
		function getCulture (arg0_culture_name) {
			//Convert from parameters
			var culture_name = arg0_culture_name.toLowerCase();
			
			//Declare and initialise local instance variables
			var culture_found = [false, ""];
			var culture_list = [];
			
			//Fetch all unique cultures and append them to culture list
			for (var i = 0; i < main.user_array.length; i++) {
				var local_usr = main.users[main.user_array[i]];
				for (var x = 0; x < local_usr.pops.pop_array; x++) {
					var local_pop_obj = local_usr.pops[local_usr.pops.pop_array[x]];
					
					//Error trapping
					try {
						if (!culture_list.includes(local_pop_obj.culture)) culture_list.push(local_pop_obj.culture);
					} catch {}
				}
			}
			
			//Soft match first
			for (var i = 0; i < culture_list.length; i++) if (culture_list[i].toLowerCase().indexOf(culture_name) != -1) culture_found = [true, culture_list[i]];
			
			//Hard match next
			for (var i = 0; i < culture_list.length; i++) if (culture_list[i].toLowerCase() == culture_name) culture_found = [true, culture_list[i]];
			
			return (culture_found[0]) ? culture_found[1] : undefined;
		}
		
		function getNearestCity (arg0_user, arg1_province) {
			//Convert from parameters
			var user_id = arg0_user;
			var province_id = arg1_province;
			
			//Declare instance variables
			var current_closest_distance = config.max_provinces; //Set this impossibly high since we'll be using Math.min to make comparisons
			
			//Check to see which users are accepted and valid or not
			var accepted_user_array = (user_id == "all") ? main.user_array : [user_id];
			
			for (var i = 0; i < accepted_user_array.length; i++) {
				var local_user = main.users[accepted_user_array[i]];
				
				for (var x = 0; x < local_user.cities.province_array.length; x++) {
					var total_distance = moveTo(local_user.cities.province_array[x], province_id);
					try {
						if (provinces[total_distance[0]].adjacencies.length > 0) current_closest_distance = Math.min(current_closest_distance, total_distance.length);
					} catch {}
				}
			}
			
			//Return statement
			return current_closest_distance;
		}
		
		function getNumberOfNonAcceptedPops (arg0_user) {
			//Try/catch statement, regular error trapping
			try {
				//Convert from parameters
				var user_id = arg0_user,
					usr = (main.users[arg0_user]) ? main.users[arg0_user] : undefined;
					
				//Declare instance variables
				var non_accepted_pops = 0;
				
				for (var i = 0; i < usr.pops.pop_array.length; i++) {
					var prov_id = usr.pops.pop_array[i],
						prov_obj = getProvince(usr.pops.pop_array[i]);
					
					if (!usr.accepted_cultures.includes(prov_obj.culture)) {
						non_accepted_pops = non_accepted_pops + returnSafeNumber(prov_obj.population);
					}
				}
				//Return statement
				return non_accepted_pops;
			} catch {
				return undefined;
			}
		}
		
		function getMeanDistanceFromCapital (arg0_user) {
			//Try/catch statement for error trapping, since user ID's provided may not always be reliable
			try {
				//Convert from parameters
				var user_id = arg0_user,
					usr = (main.users[arg0_user]) ? main.users[arg0_user] : undefined;
				
				//Declare instance variables
				var total_distance = 0;
				var average_distance = 0;
				
				for (var i = 0; i < usr.pops.pop_array.length; i++) {
					var prov_id = usr.pops.pop_array[i];
					total_distance = total_distance + returnSafeNumber(moveTo(prov_id, usr.capital_id.toString()).length);
				}
				average_distance = total_distance/usr.pops.pop_array.length;
				
				//Return statement
				usr.mean_distance = average_distance;
				return average_distance;
			} catch {
				return undefined;
			}
		}
		
		function getOccupation (arg0_province) {
			//Convert from parameters
			var prov_id = arg0_province;
			
			//Declare instance variables
			var occupation_found = [false, ""];
			
			//Iterate over occupation array
			for (var i = 0; i < main.users.global.occupations.length; i++) {
				var occupation_obj = main.users.global.occupations[i];
				
				if (occupation_obj[0] == prov_id) {
					occupation_found = [true, occupation_obj];
				}
			}
			
			//Return statement
			return (occupation_found[0]) ? occupation_found[1] : undefined;
		}
		
		function getOverextension (arg0_user) {
			//Convert from parameters
			var user_id = arg0_user,
				usr = (main.users[arg0_user]) ? main.users[arg0_user] : undefined,
				overextension = 0;
			
			//Check to see if user is properly defined, error trap since you never know
			try {
				//Initialise instance variables
				var mean_dist_from_capital = getMeanDistanceFromCapital(user_id),
					non_accepted_population = getNumberOfNonAcceptedPops(user_id);
				
				//Overextension formula
				overextension = (mean_dist_from_capital/(1000/usr.provinces))*(non_accepted_population/usr.population)*usr.modifiers.non_core_manpower;
			} catch {}
			
			//Return statement
			return Math.round(overextension*100);
		}
		
		function getOverlord (arg0_user_id) {
			//Convert from parameters
			var user_id = arg0_user_id;
			
			//Declare instance variables
			var overlord_found = [false, ""];
			
			//Iterate through all users and search their respective vassal arrays
			for (var i = 0; i < main.user_array.length; i++) {
				var local_user = main.users[main.user_array[i]];
				if (local_user.vassals.includes(user_id)) {
					overlord_found = [true, local_user];
				}
			}
			
			//Return statement
			return (overlord_found[0]) ? overlord_found[1] : undefined;
		}
		
		function getPlayerScore (arg0_user) {
			//Convert from parameters
			var user_id = arg0_user;
			var usr = (main.users[arg0_user]) ? main.users[arg0_user] : undefined;
			
			//Check for user before returning score
			if (usr) {
				try {
					//Fetch total_economic_production
					var total_economic_production = 0;
					var production_obj = getProduction(user_id, "all", false);
					if (production_obj) {
						var production_obj_keys = Object.keys(production_obj);
						
						//Iterate over entire production_object
						for (var i = 0; i < production_obj_keys.length; i++) {
							var local_production = production_obj[production_obj_keys[i]];
							if (config.materials.includes(production_obj_keys[i])) total_economic_production += Math.ceil((local_production[0]+local_production[1])/2);
						}
					}
					
					//Fetch total_allies
					var total_allies = 0;
					for (var i = 0; i < usr.allies.length; i++) if (usr.allies[i][1] == "accepted") total_allies++;
					
					return Math.ceil(
						returnSafeNumber((returnSafeNumber(usr.used_soldiers)/10000)+(total_economic_production/100)+usr.provinces+(usr.researched_technologies.length*100)+((total_allies+usr.vassals.length)*1000))
					);
				} catch {}
			}
		}
		
		function getPopulationStats (arg0_user) {
			//Convert from parameters
			var usr = main.users[arg0_user];
			
			//Declare local instance variables
			var city_provinces = [];
			
			//Check if user is defined
			if (usr) {
				var pop_stats = {
					rural_pop: 0,
					rural_pop_percentile: 0,
					urban_pop: 0,
					urban_pop_percentile: 0,
					total_pop: 0
				};
				
				//Iterate over city array and add pop
				for (var i = 0; i < usr.cities.city_array.length; i++) {
					var local_city_obj = usr.cities[usr.cities.city_array[i]];
					
					city_provinces.push(local_city_obj.province); //Update tracker
					pop_stats.urban_pop += (usr.pops[local_city_obj.province]) ? returnSafeNumber(usr.pops[local_city_obj.province].population, 0) : 0;
				}
				for (var i = 0; i < usr.pops.pop_array.length; i++) {
					var local_pop_obj  = usr.pops[usr.pops.pop_array[i]];
					
					try {
						if (!city_provinces.includes(usr.pops.pop_array[i])) pop_stats.rural_pop += returnSafeNumber(local_pop_obj.population, 0);
					} catch {}
				}
				pop_stats.total_pop = usr.population;
				
				//Fix percentile
				pop_stats.rural_pop_percentile = pop_stats.rural_pop/usr.population;
				pop_stats.urban_pop_percentile = pop_stats.urban_pop/usr.population;
				
				//Return statement
				return pop_stats;
			}
		}
		
		function getProduction (arg0_user, arg1_good, arg2_greedy) { 
			//Convert from parameters
			var user_id = arg0_user;
			var usr = (main.users[arg0_user]) ? main.users[arg0_user] : undefined;
			var good_type = arg1_good.toLowerCase(); //Please note that 'all' is also a valid argument, and returns an object
			var is_greedy = (arg2_greedy) ? true : false; //If is_greedy equals true, then under_construction buildings are also counted into total production for the good
			
			//Declare instance variables, functions
			var goods_production = {};
			var virtual_inventory = JSON.parse(JSON.stringify(usr.inventory)); //Deep-copy, just for good measure
			var virtual_money = JSON.parse(JSON.stringify(usr.money));
			var virtual_user = JSON.parse(JSON.stringify(usr));
			
			function changeProductionValue (arg0_key, arg1_minmax_argument, arg2_value) {
				//Convert from parameters
				var local_key = arg0_key;
				var min_max_argument = arg1_minmax_argument;
				var local_value = Math.round(returnSafeNumber(arg2_value));
				
				//Add to goods_production
				if (goods_production[local_key]) {
					if (min_max_argument == "minimum") {
						goods_production[local_key][0] += local_value;
					} else if (min_max_argument == "maximum") {
						goods_production[local_key][1] += local_value;
					} else { //This will just apply to both minimum and maximum now
						goods_production[local_key][0] += local_value;
						goods_production[local_key][1] += local_value;
					}
				} else {
					if (min_max_argument == "minimum") {
						goods_production[local_key] = [local_value, 0];
					} else if (min_max_argument == "maximum") {
						goods_production[local_key] = [0, local_value];
					} else { //This will just apply to both minimum and maximum now
						goods_production[local_key] = [local_value, local_value];
					}
				}
			}
			
			//Get all goods production by default, filter only if good_type is not set to 'all'
			if (usr) {
				try { //Well, this never hurt anyone
					for (var i = 0; i < usr.cities.city_array.length; i++) {
						var city_obj = usr.cities[usr.cities.city_array[i]];
						var province_occupied = false;
						
						if (main.users.global.occupations) {
							for (var x = 0; x < main.users.global.occupations.length; x++) {
								province_occupied = (main.users.global.occupations[x][0] == usr.cities[usr.cities.city_array[i]].province) ? true : province_occupied;
							}
						}
						
						//Occupied provinces don't produce anything of worth
						if (!province_occupied) {
							//Iterate over all buildings and get production level
							for (var x = 0; x < config.buildings.length; x++) {
								var building_obj = config.building_stats[config.buildings[x]];
								
								if (city_obj.buildings[config.buildings[x]] > 0) {
									var total_buildings = JSON.parse(JSON.stringify(city_obj.buildings[config.buildings[x]]));
									if (is_greedy) {
										//Add under_construction buildings in city
										for (var y = 0; y < usr.under_construction.length; y++) {
											if (usr.under_construction[y][1] == config.buildings[x] && usr.under_construction[y][2] == usr.cities.city_array[i]) total_buildings += usr.under_construction[y][0];
										}
									}
									
									for (var y = 0; y < city_obj.buildings[config.buildings[x]]; y++) {
										var local_checks = 0; //This is just in case the current building is a production building
										var production_valid = true;
										var is_knowledge_building = false;
										
										if (building_obj.cost_per_turn) {
											for (var z = 0; z < building_obj.cost_per_turn.length; z++) {
												var current_amount = building_obj.cost_per_turn[z][0];
												var current_material = building_obj.cost_per_turn[z][1];
												
												//Check to make sure that material actually exists
												var local_actual_material = config.materials.includes(current_material);
												
												if (local_actual_material) {
													if (virtual_inventory[current_material] >= current_amount) {
														local_checks++;
														virtual_inventory[current_material] -= current_amount;
													}
												} else {
													if (virtual_user[current_material] >= current_amount) {
														local_checks++;
														virtual_user[current_material] -= current_amount;
													}
												}
												
												//Change production value for it
												changeProductionValue(current_material + "_upkeep", "minimum", current_amount);
												changeProductionValue(current_material + "_upkeep", "maximum", current_amount);
											}
										}
										
										//Check to see if the building is a research facility
										if (config.research_buildings) is_knowledge_building = config.research_buildings.includes(config.buildings[x]);
										
										if (building_obj.cost_per_turn) {
											if (local_checks >= building_obj.cost_per_turn.length) {
												production_valid = true;
												
												//Begin removing resources from virtual_inventory and virtual_user
												for (var z = 0; z < building_obj.cost_per_turn.length; z++) {
													var current_amount = building_obj.cost_per_turn[z][0];
													var current_material = building_obj.cost_per_turn[z][1];
													
													if (config.materials.includes(current_material)) {
														virtual_inventory[current_material] -= current_amount;
													} else {
														virtual_user[current_material] -= current_amount;
													}
												}
											} else {
												production_valid = false;
											}
										}
										
										//Only produce if the building has the necessary resources to do so
										if (production_valid) {
											//Add building special_effect to total goods production array
											goods_production[config.buildings[x] + "_special_effect"] = (goods_production[config.buildings[x] + "_special_effect"]) ?  goods_production[config.buildings[x] + "_special_effect"] + 1 : 1;
											
											var building_production = getBuildingProduction(user_id, config.buildings[x], city_obj);
											
											//Add building_production to goods_production
											var all_building_production = Object.keys(building_production);
											for (var z = 0; z < all_building_production.length; z++) {
												changeProductionValue(all_building_production[z], "minimum", building_production[all_building_production[z]][0]);
												changeProductionValue(all_building_production[z], "maximum", building_production[all_building_production[z]][1]);
											}
										}
									}
								}
							}
						}
					}
					
					//Sort goods_production so that each key is actually [min, max]
					var all_good_keys = Object.keys(goods_production);
					for (var i = 0; i < all_good_keys.length; i++) {
						if (Array.isArray(goods_production[all_good_keys[i]])) goods_production[all_good_keys[i]].sort();
					}
				} catch (e) {
					console.log(e);
				}
			}
			
			//Return statement
			if (good_type == "all") {
				return (Object.keys(goods_production).length > 0) ? goods_production : {};
			} else {
				return (goods_production[good_type]) ? goods_production[good_type] : {};
			}
		}
		
		function getProvince (arg0_province, arg1_mode) {
			//Convert from parameters
			var province_id = arg0_province;
			var mode = (arg1_mode) ? arg1_mode : "normal";
			
			var province_found = false;
			for (var i = 0; i < main.user_array.length; i++) {
				var usr = main.users[main.user_array[i]];
				for (var x = 0; x < usr.pops.pop_array.length; x++) {
					if (usr.pops.pop_array[x] == province_id) {
						province_found = true;
						if (mode == "normal") {
							return usr.pops[usr.pops.pop_array[x]];
						} else {
							return usr.id;
						}
					}
				}
			}
			if (province_found == false) {
				return undefined;
			}
		}
		
		function getResource (arg0_province) {
			//Convert from parameters
			var province_id = arg0_province;
			
			for (var i = 0; i < main.user_array.length; i++) {
				var local_user = main.users[main.user_array[i]];
				
				for (var x = 0; x < local_user.cities.city_array.length; x++) {
					var local_city = local_user.cities[local_user.cities.city_array[x]];
					
					//if (local_city.
				}
			}
		}
		
		function getTroopCountInProvince (arg0_province, arg1_user) {
			//Convert from parameters
			var province_id = arg0_province;
			var usr = (arg1_user) ? main.users[arg1_user] : undefined;
			
			//Declare instance variables
			var local_armies = (!usr) ? getArmiesInProvince(province_id) : getArmiesInProvince(province_id, usr.id);
			var troop_count = 0;
			
			if (local_armies) {
				for (var i = 0; i < local_armies.length; i++) {
					troop_count = troop_count + returnSafeNumber(local_armies[i].army_size);
				}
			}
			
			return troop_count;
		}
		
		function getUninhabitedProvince () {
			var current_iteration = 0;
			var return_province;
			
			while (true) {
				if (current_iteration < 10) {
					var current_province = randomNumber(config.min_provinces+1, config.max_provinces).toString();
					
					//Check if current_province is uninhabited, if so, return province, and break loop
					if (!getProvince(current_province)) {
						return_province = current_province;
						break;
					}
					
					current_iteration++;
				} else {
					break;
				}
			}
			
			//Return statement
			return return_province;
		}
		
		function getWar (arg0_name) {
			//Convert from parameters
			var war_name = arg0_name;
			
			var war_exists = [false, ""];
			var all_wars = Object.keys(main.users.global.wars);
			
			//Soft match first
			for (var i = 0; i < all_wars.length; i++) {
				var local_war = main.users.global.wars[all_wars[i]];
				if (local_war.name.toLowerCase().indexOf(war_name.toLowerCase()) != -1) {
					war_exists = [true, local_war];
				}
			}
			//Hard match last
			for (var i = 0; i < all_wars.length; i++) {
				var local_war = main.users.global.wars[all_wars[i]];
				if (local_war.name.toLowerCase() == war_name.toLowerCase()) {
					war_exists = [true, local_war];
				}
			}
			
			//Return statement
			return (war_exists[0]) ? war_exists[1] : undefined;
		}
		
		function hasFamineNextTurn (arg0_user) {
			//Convert from parameters
			var user_id = arg0_user;
			var usr = (main.users[arg0_user]) ? main.users[arg0_user] : undefined;
			
			//Declare instance variables
			try {
				var food_production = getProduction(user_id, "food");
					food_production = (!food_production) ? 0 : food_production;
				var virtual_inventory = JSON.parse(JSON.stringify(usr.inventory));
				
				//Reduce food from virtual_inventory
				virtual_inventory.food += food_production[0]; //Add minimum since this is inclusive for all possibilities of famine
				virtual_inventory.food -= returnSafeNumber(Math.ceil(usr.population/config.population_food_requirements)); //Reduce food count by population
				
				//Return statement
				return (virtual_inventory.food < 0) ? true : false;
			} catch {}
		}
		
		function hasRole (arg0_msg, arg1_role) {
			if (arg0_msg.member == undefined) {
				return false;
			} else {
				if (arg0_msg.member.roles.cache.some(role => role.name === arg1_role)) {
					return true;
				} else {
					return false;
				}
			}
		}
		
		function indexesOf (arg0_substring, arg1_string) {
			//Convert from parameters
			var substring = arg0_substring;
			var string = arg1_string;
			
			var a = [], i = -1;
			while ((i = string.indexOf(substring, i+1)) >= 0) a.push(i);
			
			//Return statement
			return a;
		}
		
		function isInVicinityOfAnotherCapital (arg0_province, arg1_distance_allowed) {
			//Convert from parameters
			var province_id = arg0_province.toString();
			var distance_allowed = arg1_distance_allowed;
			
			//Declare instance variables
			var is_in_vicinity_of_another_capital = false;
			for (var i = 0; i < main.user_array.length; i++) {
				var local_user = main.users[main.user_array[i]];
				if (local_user.capital_id != 0) {
					var current_distance = moveTo(province_id, local_user.capital_id.toString()).length;
					
					is_in_vicinity_of_another_capital = (current_distance < distance_allowed) ? true : is_in_vicinity_of_another_capital;
				}
			}
			
			//Return statement
			return is_in_vicinity_of_another_capital;
		}
		
		function isOccupied (arg0_city_name) {
			//Convert from parameters
			var city_name = arg0_city_name;
			var city_obj = getCity(arg0_city_name);
			
			//Declare instance variables
			var is_occupied = false;
			
			//Make sure city_obj is actually valid
			if (city_obj) {
				try {
					for (var i = 0; i < main.users.global.occupations.length; i++) {
						is_occupied = (main.users.global.occupations[i][0] == city_obj.province.toString()) ? true : is_occupied;
					}
					
					//Return statement
					return is_occupied;
				} catch {}
			}
		}
		
		function isProvinceBeingColonised (arg0_province) {
			//Convert from parameters
			var province_id = arg0_province;
			
			//Declare instance variables
			var being_colonised = false;
								
			for (var i = 0; i < main.user_array.length; i++) {
				var local_user = main.users[main.user_array[i]];
				
				//Look through all of their currently ongoing expeditions
				for (var x = 0; x < local_user.expeditions.length; x++) {
					var local_expedition = local_user.expeditions[x];
					
					//Look through all active provinces in expedition
					for (var y = 0; y < local_expedition[2].length; y++) {
						being_colonised = (local_expedition[2][y] == province_id) ? true : being_colonised;
					}
				}
			}
			
			//Return statement
			return being_colonised;
		}
		
		function isUrban (arg0_province) {
			//Convert from parameters
			var province_id = arg0_province;
			
			//Declare instance variables
			var is_urban = false;
			
			//Iterate over all users to check if province is urban
			for (var i = 0; i < main.user_array.length; i++) {
				var local_user = main.users[main.user_array[i]];
				
				is_urban = (local_user.cities.province_array.includes(province_id)) ? true : is_urban;
			}
			
			//Return statement
			return is_urban;
		}
		
		function longMessage (arg0_msg, arg1_array, arg2_amount, arg3_dm) {
			var msg = arg0_msg;
			var default_amount = 20;
			var dm_array = [];
			if (arg3_dm == undefined) {
				dm_array = [false, ""];
			} else {
				dm_array = arg3_dm;
			}
			if (arg2_amount != undefined) {
				default_amount = arg2_amount;
			}
			if (arg1_array.length > default_amount) {
				var temp_array_string = [];
				for (var i = 0; i < arg1_array.length; i++) {
					if (temp_array_string.length < default_amount) {
						temp_array_string.push(arg1_array[i]);
					} else {
						if (dm_array[0]) {
							client.users.fetch(dm_array[1]).then((user) => {
								try { if (user) user.send(temp_array_string.join("\n")); } catch {}
							});
						} else {
							msg.channel.send(temp_array_string.join("\n"));
						}
						temp_array_string = [];
						temp_array_string.push(arg1_array[i]);
					}
								
					if (arg1_array.length > default_amount) {
						if (i == arg1_array.length-1) {
							if (dm_array[0]) {
								client.users.fetch(dm_array[1]).then((user) => {
									try { if (user) user.send(temp_array_string.join("\n")); } catch {}
								});
							} else {
								msg.channel.send(temp_array_string.join("\n"));
							}
							temp_array_string = [];
						}
					}
				}
			} else {
				if (dm_array[0]) {
					client.users.fetch(dm_array[1]).then((user) => {
						try { if (user) user.send(arg1_array.join("\n")); } catch {}
					});
				} else {
					msg.channel.send(arg1_array.join("\n"));
				}
			}
		}
		
		function moveTo (prov1, prov2) {
			try {
				var pathFinder = pathfinding_bn.aStar(graph, {
					distance(fromNode, toNode, link) {
						return link.data.weight;
					}
				});
					
				var path = pathFinder.find(prov2, prov1);
				var connections = [];
				
				for (var i = 0; i < path.length; i++) {
					connections.push(path[i].id);
				}
				
				//Parse connections
				for (var i = 0; i < connections.length; i++) {
					if (isNaN(parseInt(connections[i]))) {
						connections.splice(i, 1);
					}
				}
				
				return connections;
			} catch (e) {
				console.log(e);
				return [prov1, prov2];
			}
		}
		
		function ordinalSuffix (i) {
			var negative_suffix = (i < 0) ? "-" : "";
			
			i = Math.abs(i);
			var j = i % 10,
				k = i % 100;
			if (j == 1 && k != 11) {
				return negative_suffix + i + "st";
			}
			if (j == 2 && k != 12) {
				return negative_suffix + i + "nd";
			}
			if (j == 3 && k != 13) {
				return negative_suffix + i + "rd";
			}
			return negative_suffix + i + "th";
		}
		
		function parseArray (arg0_array) {
			//Convert from parameters
			var local_array = arg0_array;
			var name_string;
			
			if (local_array.length > 2) {
				local_array[local_array.length-1] = "and " + local_array[local_array.length-1];
				name_string = local_array.join(", ");
			} else if (local_array.length == 2) {
				local_array[local_array.length-1] = "and " + local_array[local_array.length-1];
				name_string = local_array.join(" ");
			} else if (local_array.length == 1) {
				name_string = local_array[0];
			}
			
			return name_string;
		}
		
		function parseMilliseconds (duration) {
			var milliseconds = parseInt((duration % 1000) / 100),
			seconds = Math.floor((duration / 1000) % 60),
			minutes = Math.floor((duration / (1000 * 60)) % 60),
			hours = Math.floor((duration / (1000 * 60 * 60)) % 24);

			return hours + " hours, " + minutes + " minutes, " + seconds + " seconds";
		}
		
		function parseNumber (arg0_number) {
			return Intl.NumberFormat('de').format(parseInt(arg0_number));
		}
		
		function parseInteger (arg0_number) {
			return Intl.NumberFormat('de').format(parseInt(Math.ceil(arg0_number)));
		}
		
		function parseOrdinals (arg0_string) {
			//Convert from parameters
			var ordinal_string = arg0_string;
			
			//Declare instance array and reference variables
			var numbers = ["-", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "I", "V", "X", "L", "C", "D", "M", "i", "v", "x", "l", "c", "d", "m"],
				arabic_numerals = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"],
				ordinals = ["st", "nd", "rd", "th"],
				roman_numerals = ["I", "V", "X", "L", "C", "D", "M", "i", "v", "x", "l", "c", "d", "m"],
				midpoint_signifier = [".", " "];
			var ordinal_array = [];
			var global_suffix = "",
				irregular_structure = false;
			
			//Split up string into multiple ordinal arguments if commas are included
			ordinal_string = (ordinal_string.includes(",")) ? ordinal_string.split(",") : [ordinal_string];
			
			//Check for irregular structure (e.g. '23rd-24th, 86th, 88th Field Artillery')
			var single_field_count = 0;
			for (var i = 0; i < ordinal_string.length; i++) {
				if (ordinal_string[i].split(" ").length == 1) {
					single_field_count++;
				}
				//Check for ending index, if multiple args are detected, then set irregular_structure to true
				if (ordinal_string[i].split(" ").length > 1 && i == ordinal_string.length-1) {
					irregular_structure = true;
				}
			}
			
			if (irregular_structure) {
				var current_string = ordinal_string[ordinal_string.length-1].trim().split(" ").join(" ");
				var global_suffix_index = (current_string.indexOf("-") != -1) ? current_string.indexOf("-") : 0,
					numbers_stopped = false;
				
				//Expand global_suffix
				for (var i = global_suffix_index; i < current_string.length; i++) {
					if (!numbers.includes(current_string[i]) && current_string[i] != "-") {
						numbers_stopped = true;
					}
					if (numbers_stopped) {
						if (current_string[i]) {
							global_suffix += current_string[i];
						}
					}
				}
			}
			
			//Iterate through all arguments, taking the index of the dash in between and expanding left right (if dash is present)
			for (var i = 0; i < ordinal_string.length; i++) {
				//Error trapping for local argument just in case of invalid inputs
				try {
					ordinal_string[i] = ordinal_string[i].trim();
					ordinal_string[i] = ordinal_string[i].replace(/  /gm, "");
					ordinal_string[i] = ordinal_string[i].replace(" - ", "-");
					//Declare local variables for local argument
					var contains_ordinals = false, //Does this argument contain ordinals such as st, nd, and th? If so, these will be dynamically generated
						pure_numbers = true,
						left_number_indices = [],
						left_numbers = "",
						leftside_prefix = "",
						leftside_suffix = "",
						right_number_indices = [],
						right_numbers = "",
						rightside_prefix = "",
						rightside_suffix = "";
					
					var dash_index = ordinal_string[i].indexOf("-"),
						dash_indices = indexesOf("-", ordinal_string[i]),
						leftside_index,
						rightside_index;
						
					//Make it work with negative numbers!
					if (dash_indices.length > 1) {
						dash_index = dash_indices[1];
					}
					
					if (dash_index != -1) {
						//Left-side traversal and expansion
						var started_leftside_traversal = false,
							stop_leftside_traversal = false,
							stop_leftside_expansion = false;
							
						for (var x = dash_index; x >= 0; x--) {
							if (!stop_leftside_traversal) {
								if (numbers.includes(ordinal_string[i][x]) && x != dash_index) {
									started_leftside_traversal = (!started_leftside_traversal) ? true : started_leftside_traversal;
									leftside_index = x;
								} else {
									stop_leftside_traversal = (started_leftside_traversal) ? true : stop_leftside_traversal;
								}
							}
						}
						
						//Check for all left-side arabic/roman numeral arguments
						var sub_arguments = ordinal_string[i].split(" ");
						
						//Initialise local variables
						for (var x = 0; x < sub_arguments.length; x++) {
							for (var y = 0; y < ordinals.length; y++) {
								if (sub_arguments[x].includes(ordinals[y]) && sub_arguments[x].includes("-")) {
									contains_ordinals = true;
								}
							}
						}
						
						for (var x = 0; x < sub_arguments.length; x++) {
							try {
								var fulfills_conditions = false;
								
								if (sub_arguments[x].length > 2) {
									if ((roman_numerals.includes(sub_arguments[x][0]) && roman_numerals.includes(sub_arguments[x][1])) || (arabic_numerals.includes(sub_arguments[x][0]) && arabic_numerals.includes(sub_arguments[x][1]))) {
										fulfills_conditions = true;
									}
								} else {
									if ((roman_numerals.includes(sub_arguments[x][0]) || arabic_numerals.includes(sub_arguments[x][0])) || roman_numerals.includes(sub_arguments[x][1]) || arabic_numerals.includes(sub_arguments[x][1])) {
										fulfills_conditions = true;
									}
								}
							} catch {}
						}
						
						//Left-side expansion
						for (var x = leftside_index; x <= dash_index; x++) {
							if (!stop_leftside_expansion) {
								if (numbers.includes(ordinal_string[i][x]) && x != dash_index) {
									left_numbers += ordinal_string[i][x];
									left_number_indices.push(x);
								} else {
									stop_leftside_expansion = true;
								}
							}
						}
						
						//Begin right-side traversal
						var started_rightside_traversal = false,
							stop_rightside_traversal = false;
							
						//Check for all right-side arabic/roman numeral arguments, only do this if a number is not detected immediately after the dash, however
						rightside_index = dash_index;
						var numeric_post_dash_argument = false,
							post_dash_numbers = 0,
							post_dash_total = 0;
						
						for (var x = 0; x < sub_arguments.length; x++) {
							var local_dash_index = sub_arguments[x].indexOf("-");
							if (local_dash_index != -1) {
								//Check to see whether dash is actually valid, or just another negative number
								var valid_dash = false;
								var local_dash_indices = [];
								var total_count = 0;
								
								for (var y = 0; y < sub_arguments[x].length; y++) {
									if (sub_arguments[x][y] == "-") {
										total_count++;
										local_dash_indices.push(y);
									}
								}
								
								valid_dash = (total_count == 1) ? true : false;
								if (total_count > 1) local_dash_index = local_dash_indices[1];
								
								if (valid_dash) {
									for (var y = local_dash_index+1; y < sub_arguments[x].length; y++) {
										post_dash_numbers = (numbers.includes(sub_arguments[x][y])) ? post_dash_numbers + 1 : post_dash_numbers;
										post_dash_total++;
									}
									for (var y = 0; y < sub_arguments[x].length; y++) {
										if (!numbers.includes(sub_arguments[x][y]) && !contains_ordinals && sub_arguments[x][y] != "-") {
											pure_numbers = false;
										}
									}
								}
								if (!stop_rightside_traversal) {
									for (var y = local_dash_index+1; y < sub_arguments[x].length; y++) {
										if (numbers.includes(sub_arguments[x][y]) && y != local_dash_index) {
											var local_index_position = 0;
											started_rightside_traversal = (!started_rightside_traversal) ? true : started_rightside_traversal;
											right_numbers += sub_arguments[x][y];
											for (var z = 0; z < sub_arguments.length; z++) local_index_position += sub_arguments[z].length;
											
											right_number_indices.push(local_index_position + y);
										} else {
											stop_rightside_traversal = (started_rightside_traversal) ? true : stop_rightside_traversal;
										}
									}
								}
							}
						}
						numeric_post_dash_argument = ((post_dash_numbers/post_dash_total) < 0.5) ? false : true;
						
						if (!numeric_post_dash_argument) {
							for (var x = sub_arguments.length; x >= 0; x--) {
								try {
									var fulfills_conditions = false;
									
									//Check if local split string appears to consist mostly of numerals, of whatever type
									if (sub_arguments[x].length > 2) {
										if ((roman_numerals.includes(sub_arguments[x][0]) && roman_numerals.includes(sub_arguments[x][1])) || (arabic_numerals.includes(sub_arguments[x][0]) && arabic_numerals.includes(sub_arguments[x][1]))) {
											fulfills_conditions = true;
										}
									} else {
										if ((roman_numerals.includes(sub_arguments[x][0]) || arabic_numerals.includes(sub_arguments[x][0])) || roman_numerals.includes(sub_arguments[x][1]) || arabic_numerals.includes(sub_arguments[x][1])) {
											fulfills_conditions = true;
										}
									}
									
									if (fulfills_conditions) {
										var total_index = 0;
										for (var y = 0; y < x; y++) {
											total_index += sub_arguments[y].length;
										}
										rightside_index = Math.max(total_index, rightside_index);
									}
								} catch {}
							}
						}
						
						//Fetch leftside_prefix and leftside_suffix
						//leftside_prefix first
						if (left_number_indices[0] != 0) {
							for (var x = 0; x < left_number_indices[0]; x++) {
								leftside_prefix += ordinal_string[i][x];
							}
						}
						//leftside_suffix next
						if (left_number_indices[left_number_indices.length-1] != dash_index-1) {
							for (var x = left_number_indices[left_number_indices.length-1]+1; x < dash_index; x++) {
								if (ordinal_string[i][x]) {
									leftside_suffix += ordinal_string[i][x];
								}
							}
						}
						
						//Fetch rightside_prefix and rightside_suffix
						//rightside_prefix first
						var rightside_expansion_ran_into_number = false;
						var local_rightside_string = "";
						for (var x = dash_index+1; x < right_number_indices[0]; x++) if (ordinal_string[i][x]) local_rightside_string += ordinal_string[i][x];
						console.log(local_rightside_string.split(" "));
						local_rightside_string = local_rightside_string.split(" "); //Remove 1st term
						local_rightside_string[0] = "";
						local_rightside_string = local_rightside_string.join(" ").trim();
						
						//rightside_suffix next
						/* Deprecated:
						console.log(right_number_indices);
						if (right_number_indices[right_number_indices.length-1] != ordinal_string[i].length-1) {
							for (var x = right_number_indices[right_number_indices.length-1]+1; x < ordinal_string[i].length; x++) {
								if (ordinal_string[i][x]) {
									rightside_suffix += ordinal_string[i][x];
									console.log(ordinal_string[i][x]);
								}
							}
						}
						*/
						rightside_suffix = local_rightside_string;
						
						//Make sure that both left_numbers and right_numbers cannot contain both arabic and roman numerals
						var leftside_has_roman = false,
							rightside_has_roman = false;
						
						for (var x = 0; x < left_numbers.length; x++) {
							leftside_has_roman = (roman_numerals.includes(left_numbers[x])) ? true : leftside_has_roman;
						}
						for (var x = 0; x < right_numbers.length; x++) {
							rightside_has_roman = (roman_numerals.includes(right_numbers[x])) ? true : rightside_has_roman;
						}
						
						//Purge all arabic numerals from left_numbers and right_numbers independently if detected as a roman argument - no arabic numerals are included
						if (leftside_has_roman && !left_numbers.match(/[0-9]/gm)) {
							left_numbers = left_numbers.split("");
							if (!left_numbers.join("").match(/[0-9]/gm)) {
								for (var x = 0; x < left_numbers.length; x++) {
									if (!roman_numerals.includes(left_numbers[x])) {
										left_numbers.splice(x, 1);
									}
								}
							} else {
								for (var x = 0; x < left_numbers.length; x++) {
									if (!arabic_numerals.includes(left_numbers[x])) {
										left_numbers.splice(x, 1);
									}
								}
								leftside_has_roman = false;
							}
							left_numbers = left_numbers.join("");
						}
						if (rightside_has_roman) {
							right_numbers = right_numbers.split("");
							if (!right_numbers.join("").match(/[0-9]/gm)) {
								for (var x = 0; x < right_numbers.length; x++) {
									if (!roman_numerals.includes(right_numbers[x])) {
										right_numbers.splice(x, 1);
									}
								}
							} else {
								for (var x = 0; x < right_numbers.length; x++) {
									if (!arabic_numerals.includes(right_numbers[x])) {
										right_numbers.splice(x, 1);
									}
								}
								rightside_has_roman = false;
							}
							right_numbers = right_numbers.join("");
						}
						
						//Deordinalise all pefixes and suffixes
						var new_left_numbers = [], new_right_numbers = [],
							left_uppercase = (left_numbers[0] == left_numbers[0].toUpperCase()),
							right_uppercase = (right_numbers[0] == right_numbers[0].toUpperCase());
							
						console.log(`Left Uppercase: ${left_uppercase}, Right Uppercase: ${right_uppercase}`);
						
						for (var x = 0; x < left_numbers.length; x++) if ((left_numbers[x] == left_numbers[x].toUpperCase()) == left_uppercase) new_left_numbers.push(left_numbers[x]);
						for (var x = 0; x < right_numbers.length; x++) if ((right_numbers[x] == right_numbers[x].toUpperCase()) == left_uppercase) new_right_numbers.push(right_numbers[x]);
						
						left_numbers = new_left_numbers.join("");
						right_numbers = new_right_numbers.join("");
						
						console.log(`NUMBERS: ${left_numbers}-${right_numbers}`);
						
						leftside_prefix = deordinalise(leftside_prefix);
						leftside_suffix = deordinalise(leftside_suffix);
						rightside_prefix = deordinalise(rightside_prefix);
						rightside_suffix = deordinalise(rightside_suffix);
						global_suffix = deordinalise(global_suffix);
						
						//Make sure they're compatible with each other, rightside always takes precedent
						leftside_prefix = (rightside_prefix.indexOf(leftside_prefix) != -1 && leftside_prefix.length > 0) ? rightside_prefix : leftside_prefix;
						leftside_suffix = (rightside_suffix.indexOf(leftside_suffix) != -1 && leftside_suffix.length > 0) ? rightside_suffix : leftside_suffix;
						
						//If rightside_prefix is nonexistent or less than leftside_prefix, assign leftside_prefix to it
						if (leftside_prefix.length > rightside_prefix.length) {
							if (leftside_prefix.indexOf(rightside_prefix) != -1) {
								rightside_prefix = leftside_prefix;
							}
						}
						
						//If leftside_suffix is nonexistent, assign rightside_suffix to it
						if (rightside_suffix.length > leftside_suffix.length) {
							if (rightside_suffix.indexOf(leftside_suffix) != -1) {
								leftside_suffix = rightside_suffix;
							} else if (leftside_suffix.length <= 2 || leftside_suffix[0].toUpperCase() != leftside_suffix[0]) {
								leftside_suffix = rightside_suffix;
							}
						}
						
						console.log("Leftside Prefix: " + leftside_prefix);
						console.log("Rightside Prefix: " + rightside_prefix);
						console.log("Leftside Suffix: " + leftside_suffix);
						console.log("Rightside Suffix: " + rightside_suffix);
						
						//Check for global_suffix
						if (sub_arguments.length == 1) {
							leftside_suffix = (global_suffix.length > 0) ? global_suffix : leftside_suffix;
							rightside_suffix = (global_suffix.length > 0) ? global_suffix : rightside_suffix;
						}
						
						var parse_type; //arabic, roman
						if (leftside_has_roman == rightside_has_roman) { //They're the same argument type
							parse_type = (!isNaN(parseInt(left_numbers))) ? ["arabic", "arabic"] : ["roman", "roman"];
						} else { //Different argument types, bruv
							parse_type = (leftside_has_roman) ? ["roman", "arabic"] : ["arabic", "roman"];
						}
						
						var number_break = (leftside_prefix.length == 0 && rightside_prefix.length > 0) ? " " : "";
							number_break = (pure_numbers) ? " " : number_break;
						
						//Do the same for leftside_prefix after assigning number_break
						leftside_prefix = (leftside_prefix.length == 0 && rightside_prefix.length > 0) ? rightside_prefix : leftside_prefix;
						
						console.log(`Pure Numbers: ${pure_numbers}`);
						
						var local_break = (global_suffix != "" && sub_arguments.length == 1) ? " " : "";
						
						if (parse_type.toString() == ["roman", "roman"]) {
							var beginning_argument = Math.min(arabicise(left_numbers), arabicise(right_numbers)),
								ending_argument = Math.max(arabicise(left_numbers), arabicise(right_numbers));
								
							for (var x = beginning_argument; x <= ending_argument; x++) {
								//Carry leftside format all the way up until the ending index
								var current_ordinal = (contains_ordinals) ? returnOrdinal(x) + " " : "";
								if (x != ending_argument) {
									ordinal_array.push(processOrdinalString(`${leftside_prefix}${local_break} ${romanise(x)}${current_ordinal} ${leftside_suffix}`));
								} else {
									ordinal_array.push(processOrdinalString(`${rightside_prefix}${local_break} ${romanise(x)}${current_ordinal} ${rightside_suffix}`));
								}
							}
						} else if (parse_type.toString() == ["arabic", "arabic"]) {
							var beginning_argument = Math.min(parseInt(left_numbers), parseInt(right_numbers)),
								ending_argument = Math.max(parseInt(left_numbers), parseInt(right_numbers));
								
							for (var x = beginning_argument; x <= ending_argument; x++) {
								//Carry leftside format all the way up until the ending index
								var current_ordinal = (contains_ordinals) ? returnOrdinal(x) + " " : "";
								if (x != ending_argument) {
									ordinal_array.push(processOrdinalString(`${leftside_prefix}${number_break}${x}${current_ordinal} ${leftside_suffix}`));
								} else {
									ordinal_array.push(processOrdinalString(`${rightside_prefix}${number_break}${x}${current_ordinal} ${rightside_suffix}`));
								}
							}
						} else if (parse_type.toString() == ["roman", "arabic"]) {
							var beginning_argument = Math.min(arabicise(left_numbers), parseInt(right_numbers)),
								ending_argument = Math.max(arabicise(left_numbers), parseInt(right_numbers));
								
							for (var x = beginning_argument; x <= ending_argument; x++) {
								//Carry leftside format all the way up until the ending index
								var current_ordinal = (contains_ordinals) ? returnOrdinal(x) + " " : "";
								if (x != ending_argument) {
									ordinal_array.push(processOrdinalString(`${leftside_prefix}${local_break} ${romanise(x)}${current_ordinal} ${leftside_suffix}`));
								} else {
									ordinal_array.push(processOrdinalString(`${rightside_prefix}${number_break}${x}${current_ordinal} ${rightside_suffix}`));
								}
							}
						} else {
							var beginning_argument = Math.min(parseInt(left_numbers), arabicise(right_numbers)),
								ending_argument = Math.max(parseInt(left_numbers), arabicise(right_numbers));
								
							for (var x = beginning_argument; x <= ending_argument; x++) {
								//Carry leftside format all the way up until the ending index
								var current_ordinal = (contains_ordinals) ? returnOrdinal(x) + " " : "";
								if (x != ending_argument) {
									ordinal_array.push(processOrdinalString(`${leftside_prefix}${number_break}${x}${current_ordinal} ${leftside_suffix}`));
								} else {
									ordinal_array.push(processOrdinalString(`${rightside_prefix}${local_break} ${romanise(x)}${current_ordinal} ${rightside_suffix}`));
								}
							}
						}
					} else {
						//Only a single army is being added here, just push it to ordinal_array
						var global_suffix_display = (ordinal_string[i].trim().split(" ").length == 1) ? deordinalise(global_suffix) : "";
						
						//If all arguments are of the same length, no global_suffix_display is present, and neither is a local break
						var lengths_are_same = true;
						for (var x = 0; x < ordinal_string.length; x++) {
							lengths_are_same = (ordinal_string[x].trim().split(" ").length != ordinal_string[0].trim().split(" ").length) ? false : lengths_are_same;
						}
						global_suffix_display = (lengths_are_same) ? "" : global_suffix_display;
						
						var local_break = (global_suffix != "") ? " " : "";
						ordinal_array.push(processOrdinalString(ordinal_string[i].trim() + local_break + global_suffix_display));
					}
				} catch (e) {
					console.log(e);
				}
			}
			//Remove all empty elements
			for (var i = 0; i < ordinal_array.length; i++) {
				if (ordinal_array[i] == "") {
					ordinal_array.splice(i, 1);
				}
			}
			
			console.log(ordinal_array);
			
			//Return statement
			return ordinal_array;
		}
		
		function parseString (arg0_string) {
			//Convert from parameters
			var local_string = arg0_string;
			
			//Replace all underscores with spaces, then split into an array for automatic capitalisation
			local_string = local_string.split("_").join(" ");
			local_string = local_string.replace(/(^\w{1})|(\s{1}\w{1})/g, match => match.toUpperCase());
			
			return local_string;
		}
		
		function processOrdinalString (arg0_string) {
			//Convert from parameters
			var current_string = arg0_string.toString().trim();
			var trim_patterns = [
				[/  /gm, " "],
				[" . ", ". "],
				[/^M{0,3}(CM|CD|D?C{0,3})(XC|XL|L?X{0,3})(IX|IV|V?I{0,3}) [a-z]*/gm]
			];
			var alphabet = "abcdefghijklmnopqrstuvwxyz";
			for (var i = 0; i < alphabet.split("").length; i++) {
				trim_patterns.push([` ${alphabet.split("")[i]} `, `${alphabet.split("")[i]} `]);
			}
			
			//Trim out, well, trim patterns
			for (var i = 0; i < trim_patterns.length; i++) {
				if (trim_patterns[i].length > 1) {
					current_string = current_string.replace(trim_patterns[i][0], trim_patterns[i][1]);
				} else {
					var current_roman_array = current_string.match(trim_patterns[i][0]);
					if (current_roman_array != null) {
						current_string = current_string.replace(current_roman_array[0], current_roman_array[0].split(" ").join(" "));
					}
				}
			}
			
			//Return statement
			return current_string;
		}
			
		function provCheck () {
			for (var i = 0; i < all_provinces.length; i++) {
				if (provinces[all_provinces[i]]) {
					if (provinces[all_provinces[i]].adjacencies.length > 100) {
						console.log("Province " + all_provinces[i] + "  has some insane number of adjacencies!");
					}
				}
			}
		}
		
		function random (arg0_min, arg1_max) {
			//Convert from parameters
			var min = arg0_min;
			var max = arg1_max;
			
			return Math.random()*(max-min)+min;
		}
		
		function randomElement (arg0_array) {
			return arg0_array[Math.floor(Math.random() * arg0_array.length)];
		}
		
		function randomResearch (arg0_user, arg1_amount) {
			if (main.users[arg0_user] != undefined) {
				var usr = main.users[arg0_user];
				
				var all_technologies = Object.keys(config.technology);
				var local_limits = {};
				
				//60% fixed, 40% random
				var random_categories = [];
				var random_weighted_categories = distribute(config.tech_categories.length, Math.round(arg1_amount*0.4));
				
				for (var i = 0; i < config.tech_categories.length; i++) {
					random_categories.push(Math.round((arg1_amount*0.6)/config.tech_categories.length));
				}
				for (var i = 0; i < random_weighted_categories.length; i++) {
					random_categories[i] = random_categories[i] + random_weighted_categories[i];
				}
				
				console.log("Random Research Distribution: " + random_categories);
				
				for (var i = 0; i < config.tech_categories.length; i++) {
					for (var x = 0; x < random_categories[i]; x++) {
						var local_available_techs = [];
						
						//Fetch a list of currently available technologies in this tech category
						for (var y = 0; y < all_technologies.length; y++) {
							if (config.technology[all_technologies[y]].category == config.tech_categories[i]) {
								if (config.technology[all_technologies[y]].prerequisite_techs != undefined) {
									var all_checks = 0;
									for (var z = 0; z < config.technology[all_technologies[y]].prerequisite_techs.length; z++) {
										for (var a = 0; a < usr.researched_technologies.length; a++) {
											if (usr.researched_technologies[a] == config.technology[all_technologies[y]].prerequisite_techs[z]) {
												all_checks++;
											}
										}
									}
									
									if (all_checks >= config.technology[all_technologies[y]].prerequisite_techs.length) {
										local_available_techs.push(all_technologies[y]);
									}
								} else {
									local_available_techs.push(all_technologies[y]);
								}
							}
						}
						
						//Check to make sure that tech has not already been researched
						for (var y = 0; y < local_available_techs.length; y++) {
							for (var z = 0; z < usr.researched_technologies.length; z++) {
								if (local_available_techs[y] == usr.researched_technologies[z]) {
									local_available_techs.splice(y, 1);
								}
							}
						}
						
						//Research random technology from local_available_techs
						if (local_available_techs.length > 0) {
							console.log("Local available techs: " + local_available_techs);
							instantResearch(usr.id, randomElement(local_available_techs), "none");
						}
					}
				}
			}
		}
		
		function removeNationalSpirit (arg0_player, arg1_id) {
			if (main.users[arg0_player] != undefined) {
				var usr = main.users[arg0_player];
				
				//Inverse effects, then remove
				if (usr.national_spirits[arg1_id] != undefined) {
					var local_spirit = usr.national_spirits[arg1_id];
					for (var i = 0; i < local_spirit.effects.length; i++) {
						if (local_spirit.effects[i][0] == "stability" || local_spirit.effects[i][0] == "max_tax" || local_spirit.effects[i][0] == "manpower_percentage" || local_spirit.effects[i][0] == "pop_growth_modifier") {
							usr[local_spirit.effects[i][0]] += (local_spirit.effects[i][1]*-1);
						} else {
							usr.modifiers[local_spirit.effects[i][0]] += (local_spirit.effects[i][1]*-1);
						}
					}
				}
				
				//Ok, trolled. (Remove national spirit)
				delete usr.national_spirits[arg1_id];
			}
		}
		
		function researchUpTo (arg0_user, arg1_amount) {
			if (main.users[arg0_user] != undefined) {
				var usr = main.users[arg0_user];
				
				var all_technologies = Object.keys(config.technology);
				for (var i = 0; i < all_technologies.length; i++) {
					if (config.technology[all_technologies[i]].research_cost <= arg1_amount) {
						instantResearch(usr.id, all_technologies[i], "none");
					}
				}
			}
		}
		
		function returnAverageResources (arg0_user) {
			//Convert from parameters
			var user_id = arg0_user;
			var usr = (main.users[arg0_user]) ? main.users[arg0_user] : undefined;
			
			//Declare instance variables
			var total_goods = 0;
			
			//Check to see if user is defined
			if (usr) {
				for (var i = 0; i < config.materials.length; i++) {
					total_goods += usr.inventory[config.materials[i]];
				}
			}
			
			//Return statement
			return total_goods/config.materials.length;
		}
		
		function returnMention (arg0) {
			//console.log(user.id.toString());
			var user_exists = false;
			
			if (arg0.match(/^[<0-9>(@)!]+$/)) {
				var mention_id = arg0.replace(/(<)(@)(!)/g,"");
				mention_id = mention_id.replace(/(<)(@)/g,"");
				mention_id = mention_id.replace(">","");
				
				if (main.users.global.user_map[mention_id]) mention_id = main.users.global.user_map[mention_id];
				return mention_id;
			} else {
				var mention_id = "";
				var nation_found = [false, ""];
				var user_id = "";
				for (var i = 0; i < main.user_array.length; i++) {
					if (main.users[main.user_array[i]].name.toLowerCase().indexOf(arg0.toLowerCase()) != -1) {
						nation_found = [true, main.users[main.user_array[i]].name];
						mention_id = main.user_array[i];
					}
				}
				
				//Loop back again to prioritise any exact matches
				for (var i = 0; i < main.user_array.length; i++) {
					if (main.users[main.user_array[i]].name.toLowerCase() == arg0.toLowerCase()) {
						nation_found = [true, main.users[main.user_array[i]].name];
						mention_id = main.user_array[i];
					}
				}
				
				if (!nation_found[0]) {
					//Soft match first
					for (var i = 0; i < main.user_array.length; i++) {
						if (main.users[main.user_array[i]].username != undefined) {
							if (main.users[main.user_array[i]].username.toLowerCase().indexOf(arg0.toLowerCase()) != -1) {
								user_id = main.user_array[i];
							}
						}
					}
					//Hard match next
					for (var i = 0; i < main.user_array.length; i++) {
						if (main.users[main.user_array[i]].username != undefined) {
							if (main.users[main.user_array[i]].username.toLowerCase() == arg0.toLowerCase()) {
								user_id = main.user_array[i];
							}
						}
					}
					
					if (main.users[user_id] != undefined) {
						user_exists = true;
					}
				} else {
					if (main.users.global.user_map[mention_id]) mention_id = main.users.global.user_map[mention_id];
					console.log(mention_id);
					return mention_id;
				}
			}
			
			if (user_exists) {
				if (main.users.global.user_map[user_id]) user_id = main.users.global.user_map[user_id];
				console.log(user_id);
				return user_id;
			}
		}
		
		function returnOrdinal (arg0_number) {
			//Convert from parameters
			var i = Math.abs(arg0_number);
			
			//Logic
			var j = i % 10,
				k = i % 100;
			if (j == 1 && k != 11) {
				return "st";
			}
			if (j == 2 && k != 12) {
				return "nd";
			}
			if (j == 3 && k != 13) {
				return "rd";
			}
			
			//Return statement
			return "th";
		}
			
		function returnSafeNumber (arg0_operation, arg1_default) {
			//Convert from parameters
			var operation = arg0_operation;
			var default_number = (arg1_default) ? arg1_default : 0;
			
			if (!isNaN(operation) && isFinite(operation)) {
				return operation;
			} else {
				return default_number;
			}
		}
		
		function romanise (arg0_number) {
			//Convert from parameters
			var num = arg0_number;
			
			//Declare reference array
			var lookup = { M: 1000, CM: 900, D: 500, CD: 400, C: 100, XC: 90, L: 50, XL: 40, X: 10, IX: 9, V: 5, IV: 4, I: 1, m: 1000, cm: 900, d: 500, cd: 400, c: 100, xc: 90, l: 50, xl: 40, x: 10, ix: 9, v: 5, iv: 4, i: 1}, 
				roman = "", 
				i;
			
			for (i in lookup) {
				while (num >= lookup[i]) {
					roman += i;
					num -= lookup[i];
				}
			}
			
			//Return statement
			return roman;
		}
		
		function sendCommand (arg0_id, arg1_string, arg2_function, arg3_conditional) {
			//Convert from parameters
			var user_id = arg0_id;
			var current_command = arg1_string;
			var post_command_function = arg2_function;
			var conditional_function = arg3_conditional;
			
			//Declare instance variables
			var should_send_command = (conditional_function) ? conditional_function() : true;
			override_id = user_id;
			
			if (should_send_command) {
				returnChannel(cache_channel).send(bot_prefix + current_command).then((msg) => {
					if (post_command_function) post_command_function();
					override_id = undefined;
				});
			}
		}
		
		function setMobilisationUnit (arg0_player, arg1_unit) {
			if (main.users[arg0_player] != undefined) {
				var usr = main.users[arg0_player];
				
				usr.mobilise_unit = arg1_unit;
				if (usr.mobilised_manpower[1] != "") {
					var remaining_soldiers = usr.mobilised_manpower[3];
					for (var i = 0; i < usr.armies.army_array.length; i++) {
						if (usr.armies[usr.armies.army_array[i]][usr.mobilised_manpower[1]] > remaining_soldiers) {
							usr.armies[usr.armies.army_array[i]][usr.mobilised_manpower[1]] = usr.armies[usr.armies.army_array[i]][usr.mobilised_manpower[1]] - remaining_soldiers;
							usr.armies[usr.armies.army_array[i]][arg1_unit] = remaining_soldiers;
							remaining_soldiers = 0;
						} else {
							usr.armies[usr.armies.army_array[i]][arg1_unit] = remaining_soldiers;
							remaining_soldiers = remaining_soldiers - usr.armies[usr.armies.army_array[i]][usr.mobilised_manpower[1]];
							usr.armies[usr.armies.army_array[i]][usr.mobilised_manpower[1]] = 0;
						}
					}
				}
				
				//Set the mobilisation array to mobilise the new unit, lengthen cooldown, but only if user is actually mobilising
				if (usr.mobilised_manpower[1] != "") {
					usr.mobilised_manpower[1] = arg1_unit;
					usr.last_mobilised = main.roundCount;
				}
			}
		}
		
		function setNationalSpirit (arg0_player, arg1_id, arg2_modifier) {
			if (main.users[arg0_player] != undefined) {
				var usr = main.users[arg0_player];
				
				//Fetch and remove name, icon, and description from array
				var local_icon = "";
				var local_image = "";
				var local_name = "";
				var local_description = "";
				
				//Icon (emoji)
				for (var i = 0; i < arg2_modifier.length; i++) {
					if (arg2_modifier[i][0] == "icon") {
						local_icon = arg2_modifier[i][1];
					}
				}
				console.log(arg2_modifier);
				//Image (thumbnail)
				for (var i = 0; i < arg2_modifier.length; i++) {
					if (arg2_modifier[i][0] == "img") {
						local_image = arg2_modifier[i][1];
					}
				}
				console.log(arg2_modifier);
				//Name
				for (var i = 0; i < arg2_modifier.length; i++) {
					if (arg2_modifier[i][0] == "name") {
						local_name = arg2_modifier[i][1];
					}
				}
				console.log(arg2_modifier);
				//Description
				for (var i = 0; i < arg2_modifier.length; i++) {
					if (arg2_modifier[i][0] == "description") {
						local_description = arg2_modifier[i][1];
					}
				}
				console.log(arg2_modifier);
				
				//Add the national spirit to the country
				for (var i = 0; i < arg2_modifier.length; i++) {
					if (arg2_modifier[i][0] == "stability" || arg2_modifier[i][0] == "max_tax" || arg2_modifier[i][0] == "manpower_percentage" || arg2_modifier[i][0] == "pop_growth_modifier") {
						usr[arg2_modifier[i][0]] += arg2_modifier[i][1];
					} else {
						usr.modifiers[arg2_modifier[i][0]] += arg2_modifier[i][1];
					}
				}
				
				usr.national_spirits[arg1_id] = {
					name: local_name,
					effects: arg2_modifier
				};
				
				if (local_icon != "") {
					usr.national_spirits[arg1_id].icon = local_icon;
				}
				if (local_image != "") {
					usr.national_spirits[arg1_id].img = local_image;
				}
				if (local_description != "") {
					usr.national_spirits[arg1_id].description = local_description;
				}
				
				usr.national_spirits[arg1_id].effects = arg2_modifier;
			}
		}
		
		function shuffle (arg0_array) {
			//Convert from parameters
			var array = arg0_array;
			
			var current_index = array.length, random_index;

			//While there are still elements remaining to shuffle
			while (0 !== current_index) {
				//Pick a remaining element
				random_index = Math.floor(Math.random() * current_index);
				current_index--;

				//And swap it with the current element
				[array[current_index], array[random_index]] = [array[random_index], array[current_index]];
			}
			
			//Return statement
			return array;
		}
		
		function smartMove (arg0_user, arg1_army_name, arg2_province) {
			//Convert from parameters
			var user_id = arg0_user;
			var usr = (main.users[arg0_user]) ? main.users[arg0_user] : undefined;
			var army_obj = getArmy(user_id, arg1_army_name);
			var province_id = arg2_province;
			
			//Declare instance return variable
			var connections = [];
			
			//Check for errors
			if (usr != undefined) {
				if (army_obj != undefined) {
					//Create graph of all valid provinces
					try {
						var local_graph = createGraph();
						
						if (usr.avoid_attrition != "never") {
							for (var i = 0; i < all_provinces.length; i++) {
								var local_prov_obj = provinces[all_provinces[i]].province_obj;
								var local_prov_owner = provinces[all_provinces[i]].owner;
								var valid_province = false;
								
								//Is province uncolonised?
								valid_province = (provinces[all_provinces[i]] && !local_prov_obj) ? true : valid_province;
								if (local_prov_obj) {
									//What about military access or being a vassal, or being at war?
									valid_province = (usr.military_access.includes(local_prov_owner)) ? true : valid_province;
									valid_province = (usr.vassals.includes(local_prov_owner)) ? true : valid_province;
									valid_province = (usr.at_war.includes(main.users[local_prov_owner].name)) ? true : valid_province;
								}
								
								//Check to make sure that it does not exceed attrition limit
								var local_supply = (local_prov_obj) ? local_prov_obj.supply_limit : config.base_supply_limit;
								if (getTroopCountInProvince(all_provinces[i])+army_obj.army_size > local_supply) {
									valid_province = false;
								}
								
								for (var x = 0; x < provinces[all_provinces[i]].adjacencies.length; x++) {
									if (valid_province) {
										local_graph.addLink(all_provinces[i], provinces[all_provinces[i]].adjacencies[x], { weight: 1 });
									}
								}
							}
						}
						
						var path_finder = pathfinding_bn.aStar(graph, {
							distance(fromNode, toNode, link) {
								return link.data.weight;
							}
						});
						
						var path = path_finder.find(province_id.toString(), army_obj.province.toString());
						for (var i = 0; i < path.length; i++) {
							connections.push(path[i].id);
						}
						//Parse connections
						for (var i = 0; i < connections.length; i++) {
							if (isNaN(parseInt(connections[i]))) {
								connections.splice(i, 1);
							}
						}
					} catch {}
					
					if (connections.length == 0) {
						try {
							//Create dumb graph for attrition, but only 'if possible' is listed as an option
							if (usr.avoid_attrition == "if possible") {
								for (var i = 0; i < all_provinces.length; i++) {
									var local_prov_obj = provinces[all_provinces[i]].province_obj;
									var local_prov_owner = provinces[all_provinces[i]].owner;
									var valid_province = false;
									
									//Is province uncolonised?
									valid_province = (provinces[all_provinces[i]] && !local_prov_obj) ? true : valid_province;
									if (local_prov_obj) {
										//What about military access or being a vassal, or being at war?
										valid_province = (usr.military_access.includes(local_prov_owner)) ? true : valid_province;
										valid_province = (usr.vassals.includes(local_prov_owner)) ? true : valid_province;
										valid_province = (usr.at_war.includes(main.users[local_prov_owner].name)) ? true : valid_province;
									}
									
									for (var x = 0; x < provinces[all_provinces[i]].adjacencies.length; x++) {
										if (valid_province) {
											local_graph.addLink(all_provinces[i], provinces[all_provinces[i]].adjacencies[x], { weight: 1 });
										}
									}
								}
							}
							
							var path_finder = pathfinding_bn.aStar(graph, {
								distance(fromNode, toNode, link) {
									return link.data.weight;
								}
							});
							
							var path = path_finder.find(province_id.toString(), army_obj.province.toString());
							for (var i = 0; i < path.length; i++) {
								connections.push(path[i].id);
							}
							
							//Parse connections
							for (var i = 0; i < connections.length; i++) {
								if (isNaN(parseInt(connections[i]))) {
									connections.splice(i, 1);
								}
							}
						} catch {}
					}
					
					if (connections.length == 0) {
						try {
							//Create catch-all mindless graph if avoidance of territorial violation is enabled and attrition avoidance is enabled, else simply return an error message. Set both parameters to be dynamic
							for (var i = 0; i < all_provinces.length; i++) {
								var local_prov_obj = provinces[all_provinces[i]].province_obj;
								var local_prov_owner = provinces[all_provinces[i]].owner;
								var valid_province = true;
								
								if (local_prov_obj) {
									//What about military access or being a vassal, or being at war?
									valid_province = (!usr.military_access.includes(local_prov_owner) && !usr.vassals.includes(local_prov_owner) && !usr.at_war.includes(main.users[local_prov_owner].name) && usr.avoid_territorial_violation == "always") ? false : valid_province;
								}
								
								//What about attrition?
								var local_supply = (local_prov_obj) ? local_prov_obj.supply_limit : config.base_supply_limit;
								if (usr.avoid_attrition != "always") {
									if (getTroopCountInProvince(all_provinces[i])+army_obj.army_size > local_supply) {
										valid_province = false;
									}
								}
								
								for (var x = 0; x < provinces[all_provinces[i]].adjacencies.length; x++) {
									if (valid_province) {
										local_graph.addLink(all_provinces[i], provinces[all_provinces[i]].adjacencies[x], { weight: 1 });
									}
								}
							}
							
							var path = path_finder.find(province_id.toString(), army_obj.province.toString());
							for (var i = 0; i < path.length; i++) {
								connections.push(path[i].id);
							}
							
							//Parse connections
							for (var i = 0; i < connections.length; i++) {
								if (isNaN(parseInt(connections[i]))) {
									connections.splice(i, 1);
								}
							}
						} catch {
							if (["never", "if possible"].includes(usr.avoid_attrition) && ["never", "if possible"],includes(usr.avoid_territorial_violation)) {
								connections = moveTo(army_obj.province.toString(), province_id.toString());
							}
						}
					}
					
					return (connections.length > 0) ? connections : undefined;
				} else {
					return "invalid_army";
				}
			} else {
				return "undefined_user";
			}
		}
	}

	//Logic functions
	{
		function applyNationalModifiers (arg0_user) {
			//Convert from parameters
			var user_id = arg0_user;
			var usr = main.users[arg0_user];
			
			//Declare local instance variables
			var pop_stats = getPopulationStats(user_id);
			
			//Check if user is defined
			if (usr) {
				//Urbanisation Modifiers
				{
					if (usr.provinces >= 50) {
						//Remove all prior urbanisation modifiers first
						removeNationalSpirit(user_id, "agricultural_society");
						removeNationalSpirit(user_id, "low_urbanisation");
						removeNationalSpirit(user_id, "middling_urbanisation");
						removeNationalSpirit(user_id, "high_urbanisation");
						removeNationalSpirit(user_id, "very_high_urbanisation");
						removeNationalSpirit(user_id, "extreme_urbanisation");
						removeNationalSpirit(user_id, "early_hyperurbanisation_1");
						removeNationalSpirit(user_id, "early_hyperurbanisation_2");
						removeNationalSpirit(user_id, "a_state_of_cities");
						
						if (pop_stats.urban_pop_percentile < 0.50) {
							setNationalSpirit(user_id, "agricultural_society", [
								["name", "Agricultural Society"],
								["img", "https://media.discordapp.net/attachments/829862963485474827/893307111105237022/agricultural_society.png"],
								["icon", "<:farms:772296532275757087>"],
								["description", `With our country being predominantly rural, a large amount of emphasis is still being placed on the production of raw resources - such as food, iron, copper, and wood, at the cost of our nascent industrial base.\n\n• **+100%** RGO Throughput\n• **-60% ** Production Efficiency`],
								["rgo_throughput", 1.00],
								["production_efficiency", -0.60]
							]);
						} else if (pop_stats.urban_pop_percentile >= 0.50 && pop_stats.urban_pop_percentile < 0.60) {
							setNationalSpirit(user_id, "low_urbanisation", [
								["name", "Low Urbanisation"],
								["img", "https://media.discordapp.net/attachments/829862963485474827/893307116889178162/low_urbanisation.png"],
								["icon", "<:canals:773451853786251274>"],
								["description", `As more and more people have begun moving from their agricultural posts to take up residence in our humble cities, production efficiency has begun to rise at the cost of raw resource production as human capital flight has begun to become noticeable throughout our country.\n\n• **+75%** RGO Throughput\n• **-50%** Production Efficiency`],
								["rgo_throughput", 0.75],
								["production_efficiency", -0.50]
							]);
						} else if (pop_stats.urban_pop_percentile >= 0.60 && pop_stats.urban_pop_percentile < 0.75) {
							setNationalSpirit(user_id, "middling_urbanisation", [
								["name", "Middling Urbanisation"],
								["img", "https://media.discordapp.net/attachments/829862963485474827/893307119049252914/middling_urbanisation.png"],
								["icon", "<:neighbourhoods:772296532958642186>"],
								["description", `Our country has now reached a state of urbanisation where the firm majority of our population are now concentrated in cities, helping forge the tools of industry and commerce as our economy gradually shifts from an agricultural to an industrial one.\n\n• **+50% RGO Throughput**\n• **-25% Production Efficiency**`],
								["rgo_throughput", 0.50],
								["production_efficiency", -0.25]
							]);
						} else if (pop_stats.urban_pop_percentile >= 0.75 && pop_stats.urban_pop_percentile < 0.85) {
							setNationalSpirit(user_id, "high_urbanisation", [
								["name", "High Urbanisation"],
								["img", "https://media.discordapp.net/attachments/829862963485474827/893307122085937192/very_high_urbanisation.png"],
								["icon", "<:suburbs:772296532908310549>"],
								["description", `Although much of our citizenry remains in the countryside and raw resource production still makes up the majority of our economy, commercial and industrial interests in cities are beginning to notice that they can take advantage of cheaper labour than before due to the influx of migrants from the countryside, providing a boost to our industry.\n\n• **+35%** Research Efficiency\n• **+20%** RGO Throughput\n• **-10%** Production Efficiency\n• **-15%** Tax Efficiency`],
								["research_efficiency", 0.35],
								["rgo_throughput", 0.20],
								["production_efficiency", -0.10],
								["tax_efficiency", -0.15]
							]);
						} else if (pop_stats.urban_pop_percentile >= 0.85 && pop_stats.urban_pop_percentile < 0.90) {
							if (usr.researched_technologies.length < 150) {
								setNationalSpirit(user_id, "early_hyperurbanisation_1", [
									["name", "Early Hyperurbanisation"],
									["img", "https://media.discordapp.net/attachments/829862963485474827/897184967858217000/early_hyperurbanisation.png"],
									["icon", "<:flats:772296533004910622>"],
									["description", `Without sufficient resources or technology necessary to sustain such high urban populations, our industry is beginning to lag behind those of other nations as overcrowding and lack of land becomes a serious issue!\n\n• **-50%** RGO Throughput\n• **-50%** Production Efficiency`],
									["rgo_throughput", -0.50],
									["production_efficiency", -0.50]
								]);
							} else {
								setNationalSpirit(user_id, "very_high_urbanisation", [
									["name", "Very High Urbanisation"],
									["img", "https://media.discordapp.net/attachments/829862963485474827/893307115056295957/high_urbanisation.png"],
									["icon", "<:flats:772296533004910622>"],
									["description", `With the overwhelming majority of our population in cities, raw resource production and the economy of rural areas is beginning to suffer from a demographic imbalance, leading to a tremendous drop in raw resource output.\n\n• **-60% RGO Throughput**\n• **-50% Production Efficiency**\n• **-50%** Research Efficiency`],
									["rgo_throughput", -0.60],
									["production_efficiency", -0.50],
									["research_efficiency", -0.50]
								]);
							}
						} else if (pop_stats.urban_pop_percentile >= 0.90 && pop_stats.urban_pop_percentile < 0.95) {
							if (usr.researched_technologies.length < 175) {
								setNationalSpirit(user_id, "early_hyperurbanisation_2", [
									["name", "Early Hyperurbanisation"],
									["img", "https://media.discordapp.net/attachments/829862963485474827/897184967858217000/early_hyperurbanisation.png"],
									["icon", "<:flats:772296533004910622>"],
									["description", `Without sufficient resources or technology necessary to sustain such high urban populations, our industry is beginning to lag behind those of other nations as overcrowding and lack of land becomes a serious issue! Fires are beginning to overwhelm our meagre fire crews, and on occassion, entire blocks of city have to be blown up to create necessary firebreaks. Disease is also spreading rampant through some of the poorer areas due to poor hygeine and sanitation.\n\n• **-70%** RGO Throughput\n• **-60%** Production Efficiency\n• **-60%** Research Efficiency\n• **-15%** Population Growth Modifier`],
									["rgo_throughput", -0.70],
									["production_efficiency", -0.60],
									["research_efficiency", -0.60],
									["pop_growth_modifier", -0.15]
								]);
							} else {
								setNationalSpirit(user_id, "extreme_urbanisation", [
									["name", "Extreme Urbanisation"],
									["img", "https://media.discordapp.net/attachments/829862963485474827/893307113328214096/extreme_urbanisation.png"],
									["icon", "<:districts:772296533113700352>"],
									["description", `Our country is now extremely urbanised, with over 90% of our population living in cities. People are flocking to join the industry and service sectors of our economies, massively increasing production efficiency at the cost of raw resource production and mining.\n\n• **-100% RGO Throughput**\n• **+50% Production Efficiency**`],
									["rgo_throughput", -1.00],
									["production_efficiency", 0.50]
								]);
							}
						} else if (pop_stats.urban_pop_percentile >= 0.95) {
							if (usr.researched_technologies.length < 175) {
								console.log("RGO Throughput: " + usr.modifiers.rgo_throughput);
								setNationalSpirit(user_id, "early_hyperurbanisation_3", [
									["name", "The Urban Miasma"],
									["img", "https://media.discordapp.net/attachments/829862963485474827/897184967858217000/early_hyperurbanisation.png"],
									["icon", "<:flats:772296533004910622>"],
									["description", `With everyone being crowded into urban slums, the fields of the farms fall fallow and disease is rampant. Craftsmen are scurrying to other countries to hide from the grime, the crime, and rivers as pure as the Ganges. No one works in the mines or countryside any longer, and poor peasants that can't afford to leave die on the roadside of plague. Their gravestones will mark their last words (if they are so fortunate): 'Uggghhhhhhhh'.\n\n• **-350%** RGO Throughput\n• **-150%** Production Efficiency\n• **-100%** Research Efficiency\n• **-50%** Population Growth Modifier`],
									["rgo_throughput", -3.50],
									["production_efficiency", -1.50],
									["research_efficiency", -1.00],
									["pop_growth_modifier", -0.50]
								]);
								console.log("RGO Throughput: " + usr.modifiers.rgo_throughput);
							} else {
								setNationalSpirit(user_id, "a_state_of_cities", [
									["name", "A State of Cities"],
									["img", "https://media.discordapp.net/attachments/829862963485474827/893307109649813544/a_state_of_cities.png"],
									["icon", "<:financial_districts:772296532492812298>"],
									["description", `With virtually everyone in the country concentrated in the cities, even industry is beginning to suffer as lack of land, congestion, and cheap labour has made our economy less competitive than ever before. The countryside is empty and the fields lay fallow as mass human capital flight takes hold and our nation becomes a globally renowned example in demographic crisis.\n\n• **-250% RGO Throughput**\n• **-50% Production Efficiency**`],
									["rgo_throughput", -2.50],
									["production_efficiency", -0.50]
								]);
							}
						}
					}
				}
			}
		}
		
		function checkWars () {
			var all_wars = Object.keys(main.users.global.wars);
			
			//Iterate through all wars to remove duplicates and other bugs
			for (var i = 0; i < all_wars.length; i++) {
				var local_war = main.users.global.wars[all_wars[i]];
				var attacker_war_exhaustion = 0;
				var defender_war_exhaustion = 0;
				
				var fully_sieged_defenders = 0;
				
				//Make sure all defenders and attackers are unique nations and not duplicate IDs
				local_war.attackers = unique(local_war.attackers);
				local_war.defenders = unique(local_war.defenders);
				
				//Recalc war exhaustion on both sides
				for (var x = 0; x < local_war.attackers.length; x++) {
					attacker_war_exhaustion += returnSafeNumber(main.users[local_war.attackers[x]].modifiers.war_exhaustion, 100);
				}
				for (var x = 0; x < local_war.defenders.length; x++) {
					if (returnSafeNumber(main.users[local_war.defenders[x]].modifiers.war_exhaustion, 100) == 100) {
						fully_sieged_defenders++;
					}
					
					defender_war_exhaustion += returnSafeNumber(main.users[local_war.defenders[x]].modifiers.war_exhaustion, 100);
				}
				
				if (fully_sieged_defenders != local_war.defenders.length) {
					local_war.attacker_warscore = ((0.75*defender_war_exhaustion)+(0.25*returnSafeNumber(main.users[local_war.original_target].modifiers.war_exhastion, 100)))/local_war.defenders.length;
				} else {
					local_war.attacker_warscore = 100;
				}
				
				local_war.attacker_warscore = (local_war.attacker_warscore > 100) ? 100 : local_war.attacker_warscore;
				local_war.defender_warscore = (local_war.defender_warscore > 100) ? 100 : local_war.defender_warscore;
				
				local_war.defender_warscore = attacker_war_exhaustion/local_war.attackers.length;
			}
		}
		
		function initAI (arg0_type, arg1_is_manual) {
			//Convert from parameters
			var ai_template = arg0_type;
			var ai_type = (config.ai_types[arg0_type.toLowerCase()]) ? config.ai_types[arg0_type.toLowerCase()] : undefined;
			var is_manual = (arg1_is_manual) ? true : false;
			
			//Make sure that AI type is valid first before proceeding
			if (ai_type) {
				//Try/catch for obvious reasons, in case of missing parameters
				try {
					//Declare instance variables
					var ai_id = generateID();
					var ai_obj;
					var starting_province = (ai_type[`starting_${config.map_type}_province`]) ? ai_type[`starting_${config.map_type}_province`] : randomNumber(config.min_provinces+1, config.max_provinces).toString();
					
					//Initialise AI
					var ai_taken = false;
					try {
						//See if AI or player already exists for this country
						ai_taken = (main.user_array.includes(getProvince(starting_province, "owner"))) ? true : ai_taken;
						for (var i = 0; i < main.user_array.length; i++) ai_taken = (main.users[main.user_array[i]].name == ai_type.name) ? true : ai_taken;
						
						//Check spawn_years to make sure it lines up with the current game time, unless AI is being manually defined (is_manual)
						if (!is_manual) {
							var meets_spawn_years = false;
							if (ai_type.spawn_years) {
								for (var i = 0; i < ai_type.spawn_years.length; i++) {
									if (ai_type.spawn_years[i].length >= 2) {
										meets_spawn_years = (main.year >= ai_type.spawn_years[i][0] && main.year <= ai_type.spawn_years[i][ai_type.spawn_years[i].length-1]) ? true : meets_spawn_years;
									} else {
										meets_spawn_years = (main.year >= ai_type.spawn_years[i][0]) ? true : meets_spawn_years;
									}
								}
							}
							
							ai_taken = (!meets_spawn_years) ? true : ai_taken;
						}
					} catch (e) {
						console.log(e);
					}
					
					if (!ai_taken || is_manual) {
						if (ai_type.name) addCommand(ai_id, `found ${ai_type.name}`, function(){
							//This is only executed after the command
							ai_obj = main.users[ai_id];
							
							starting_province = (getProvince(starting_province)) ? getUninhabitedProvince() : starting_province;
							//Remove anarchy from ai_obj.available_governments if present
							for (var i = 0; i < ai_obj.available_governments.length; i++) {
								if (ai_obj.available_governments[i] == "anarchy") {
									ai_obj.available_governments.splice(i, 1);
								}
							}
							
							//Declare starting_government
							var starting_government = (ai_type.government) ? ai_type.government : randomElement(ai_obj.available_governments);
							
							ai_obj.type = "ai";
							ai_obj.ai = ai_type;
							ai_obj.ai.ai_template = ai_template;
							ai_obj.ai_disabled = false; //For disabling AI if a user decides to play as them
							ai_obj.ai.original_ai = ai_template; //This determines formable nations and other shenanigans
							ai_obj.ai.recently_colonised_provinces = []; //[province_id, user_id, turns_since_colonisation], only logs within zone of interest
							
							//Customisation commands
							if (ai_type.colour) addCommand(ai_id, `set-colour ${ai_type.colour.join(" ")}`);
							if (ai_type.culture_name) addCommand(ai_id, `rename-culture ${ai_type.culture_name}`);
							if (ai_type.flag) addCommand(ai_id, `set-flag ${ai_type.flag}`);
							if (ai_type.motto) addCommand(ai_id, `set-motto ${ai_type.motto}`);
							if (ai_type[`starting_${config.map_type}_province`]) addCommand(ai_id, `settle ${starting_province}`);
							
							//Resolve event and set starting government
							addCommand(ai_id, `resolve 0`);
							addCommand(ai_id, `government ${starting_government}`);
							
							//Found capital city
							var capital_city_founding = setInterval(function(){
								if (getProvince(starting_province, "owner") != ai_id) {
									var city_new_command_exists = false;
									for (var i = 0; i < command_queue.length; i++) {
										if (command_queue[i][1] == `city-new ${starting_province} ${ai_type.capital_city}`) city_new_command_exists = true;
									}
									
									if (ai_type.capital_city && !city_new_command_exists) addCommand(ai_id, `city-new ${starting_province} ${ai_type.capital_city}`);
								} else {
									clearInterval(capital_city_founding);
								}
							}, 3000);
							
							//Set up AI config variables
							{
								//Initialise placer variables
								ai_obj.ai.expansion_style = (ai_type.expansion_style) ? ai_type.expansion_style : "tall";
								
								//Initialise other variables
								try {
									ai_obj.ai.city_limit = randomNumber(config[ai_obj.ai.expansion_style + "_city_limit"][0], config[ai_obj.ai.expansion_style + "_city_limit"][1]);
								} catch {
									ai_obj.ai.city_limit = 1;
								}
							}
							
							//Return statement to verify that the AI has been founded
							return true;
						});
					}
				} catch (e) {
					console.log(e);
				}
			}
		}
		
		function initAllAI (arg0_msg) {
			//Convert from parameters
			var msg = arg0_msg;
			
			var all_ai_types = Object.keys(config.ai_types);
			var current_iteration = 0;
			
			var all_ai_inits = setInterval(function(){
				if (current_iteration < all_ai_types.length) {
					var local_ai = config.ai_types[all_ai_types[current_iteration]];
					initAI(all_ai_types[current_iteration]);
					msg.channel.send(`**${local_ai.name}** initialised as AI!`);
					
					current_iteration++;
				} else {
					clearInterval(all_ai_inits);
				}
			}, 3000);
		}
		
		function initGlobal () {
			if (!main.users.global) main.users.global = {};
			if (!main.users.global.user_map) main.users.global.user_map = {};
			if (!main.users.global.blockade_arrays) main.users.global.blockade_arrays = {};
			if (!main.users.global.blockades) main.users.global.blockades = {};
			if (!main.users.global.wars) main.users.global.wars = {};
			if (!main.users.global.occupations) main.users.global.occupations = [];
			//Battle functions
			if (!main.users.global.battle_tick) main.users.global.battle_tick = main.lastTurn;
			//Event functions
			if (!main.users.global.current_scope) main.users.global.current_scope = "";
			
			//Market functions
			for (var i = 0; i < config.materials.length; i++) {
				if (main.users.global[config.materials[i] + "_stock"] == undefined) {
					main.users.global[config.materials[i] + "_stock"] = config.resource_base_stock;
					main.users.global[config.materials[i] + "_amount_sold"] = 0;
					for (var x = 0; x < config.resource_list.length; x++) {
						if (config.resource_list[x][0] == config.materials[i]) {
							main.users.global[config.materials[i] + "_buy_price"] = Math.ceil(config.resource_list[x][1]);
							main.users.global[config.materials[i] + "_sell_price"] = Math.ceil(config.resource_list[x][1]*0.5);
						}
					}
				}
			}
		}
		
		function initUser (arg0_user) {
			initGlobal();
			var current_user = arg0_user.toString();
			var already_registered = false;
			for (var i = 0; i < main.user_array.length; i++) {
				if (main.user_array[i] == current_user) {
					already_registered = true;
				}
			}
			
			//Initialisation
			if (main.users[current_user] == undefined) { main.users[current_user] = {}; }
			
			//Moderation
			if (main.users[current_user].colour_locked == undefined) { main.users[current_user].colour_locked = false; }
			if (main.users[current_user].culture_locked == undefined) { main.users[current_user].culture_locked = false; }
			if (main.users[current_user].flag_locked == undefined) { main.users[current_user].flag_locked = false; }
			if (main.users[current_user].name_locked == undefined) { main.users[current_user].name_locked = false; }
			if (main.users[current_user].cede_disabled == undefined) { main.users[current_user].cede_disabled = false; }
			if (main.users[current_user].demolish_disabled == undefined) { main.users[current_user].demolish_disabled = false; }
			
			if (main.users[current_user].last_active_turn == undefined) { main.users[current_user].last_active_turn = 0; }
			if (main.users[current_user].highest_tier == undefined) { main.users[current_user].highest_tier = 0; }
			
			//Customisation
			if (main.users[current_user].name == undefined) { main.users[current_user].name = ""; }
			if (main.users[current_user].flag == undefined) { main.users[current_user].flag = "https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png"; }
			if (main.users[current_user].colour == undefined) { main.users[current_user].colour = [randomNumber(0,255),randomNumber(0,255),randomNumber(0,255)]; }
			if (main.users[current_user].id == undefined) { main.users[current_user].id = arg0_user; }
			if (main.users[current_user].motto == undefined) { main.users[current_user].motto = 'No motto set.'; }
			
			//Options
			if (main.users[current_user].avoid_territorial_violation == undefined) { main.users[current_user].avoid_territorial_violation = "if possible"; }
			if (main.users[current_user].avoid_attrition == undefined) { main.users[current_user].avoid_attrition = "if possible"; } //["always", "if possible", "never"]
			
			if (main.users[current_user].ignore_orders_when_carpet_sieging == undefined) { main.users[current_user].ignore_orders_when_carpet_sieging = false; }
			if (main.users[current_user].allow_cede == undefined) { main.users[current_user].allow_cede = []; }
			
			//Other/Stats
			if (main.users[current_user].government == undefined) { main.users[current_user].government = ""; }
			if (main.users[current_user].technology_level == undefined) { main.users[current_user].technology_level = 1; }
			if (main.users[current_user].population == undefined) { main.users[current_user].population = 0; }
			if (main.users[current_user].recent_military_casualties == undefined) { main.users[current_user].recent_military_casualties = []; }
			if (main.users[current_user].recent_civilian_casualties == undefined) { main.users[current_user].recent_civilian_casualties = []; }
			
			if (main.users[current_user].initial_manpower == undefined) { main.users[current_user].initial_manpower = 0; }
			if (main.users[current_user].manpower_percentage == undefined) { main.users[arg0_user].manpower_percentage = 1; }
			if (main.users[current_user].used_manpower == undefined) { main.users[current_user].used_manpower = 0; }
			if (main.users[current_user].active_personnel == undefined) { main.users[current_user].active_personnel = 0; }
			if (main.users[current_user].mobilised_manpower == undefined) { main.users[current_user].mobilised_manpower = [0, "", 0, 0, 0]; } //[ideal_manpower_mobilised, unit_mobilised, turns_until_fully_mobilised, current_manpower_mobilised, original_turns_until_fully_mobilised]
			
			if (main.users[current_user].money == undefined) { main.users[current_user].money = 10000; }
			if (main.users[current_user].stability == undefined) { main.users[current_user].stability = 75; }
			if (main.users[current_user].stability_decay == undefined) { main.users[current_user].stability_decay = 0; }
			if (main.users[current_user].coup_this_turn == undefined) { main.users[current_user].coup_this_turn = false; }
			if (main.users[current_user].overthrow_this_turn == undefined) { main.users[current_user].overthrow_this_turn = ""; }
			if (main.users[current_user].news_this_turn == undefined) { main.users[current_user].news_this_turn = ""; }
			
			//Array for enabled mechanics (especially temporary story-driven ones)
			if (main.users[current_user].enabled_mechanics == undefined) { main.users[current_user].enabled_mechanics = []; }
			
			//Colonisation
			if (main.users[current_user].capital_id == undefined) { main.users[current_user].capital_id = 0; }
			if (main.users[current_user].expeditions == undefined) { main.users[current_user].expeditions = []; }
			
			//Cooldowns
			if (main.users[current_user].country_age == undefined) { main.users[current_user].country_age = 0; }
			if (main.users[current_user].last_mobilised == undefined) { main.users[current_user].last_mobilised = -100; }
			if (main.users[current_user].maximum_transaction_amount == undefined) { main.users[current_user].maximum_transaction_amount = config.resource_init_max_percentile; }
			if (main.users[current_user].total_ceded_this_turn == undefined) { main.users[current_user].total_ceded_this_turn = 0; }
			if (main.users[current_user].total_cities == undefined) { main.users[current_user].total_cities = 0; }
			if (main.users[current_user].total_transactions_this_turn == undefined) { main.users[current_user].total_transactions_this_turn = 0; }
			
			//Buildings & Construction
			if (main.users[current_user].under_construction == undefined) { main.users[current_user].under_construction = []; }
			if (main.users[current_user].provinces == undefined) { main.users[current_user].provinces = 0; }
			if (main.users[current_user].building_count == undefined) { main.users[current_user].building_count = 0; }
			if (main.users[current_user].building_cap == undefined) { main.users[current_user].building_cap = 10; }
			
			//Sub-objects
			if (main.users[current_user].buildings == undefined) { main.users[current_user].buildings = {}; }
			if (main.users[current_user].cities == undefined) { main.users[current_user].cities = {}; }
			if (main.users[current_user].inventory == undefined) { main.users[current_user].inventory = {}; }
			if (main.users[current_user].military == undefined) { main.users[current_user].military = {}; }
			if (main.users[current_user].modifiers == undefined) { main.users[current_user].modifiers = {}; }
			if (main.users[current_user].politics == undefined) { main.users[current_user].politics = {}; }
			if (main.users[current_user].pops == undefined) { main.users[current_user].pops = {}; }
			
			//Modifiers
			if (main.users[current_user].prestige == undefined) { main.users[current_user].prestige = 0; }
			if (main.users[current_user].tax_rate == undefined) { main.users[current_user].tax_rate = 0; }
			if (main.users[current_user].max_tax == undefined) { main.users[current_user].max_tax = 0; }
			if (main.users[current_user].blockaded == undefined) { main.users[current_user].blockaded = false; }
			
			if (main.users[current_user].province_war_exhaustion == undefined) { main.users[current_user].province_war_exhaustion = 0; }
			
			if (main.users[current_user].production_buildings_modifier == undefined) { main.users[current_user].production_buildings_modifier = 1; }
			if (main.users[current_user].pop_growth_modifier == undefined) { main.users[current_user].pop_growth_modifier = 1.0539; }
			
			if (main.users[current_user].infamy == undefined) { main.users[current_user].infamy = 0; }
			if (main.users[current_user].infamy_rgo_throughput == undefined) { main.users[current_user].infamy_rgo_throughput = 0; }
			if (main.users[current_user].infamy_production_efficiency == undefined) { main.users[current_user].infamy_production_efficiency = 0; }
			if (main.users[current_user].at_war == undefined) { main.users[current_user].at_war = []; }
			
			if (main.users[current_user].modifiers.army_upkeep == undefined) { main.users[current_user].modifiers.army_upkeep = 1; }
			if (main.users[current_user].modifiers.national_manpower == undefined) { main.users[current_user].modifiers.national_manpower = 1; }
			if (main.users[current_user].modifiers.non_core_manpower == undefined) { main.users[current_user].modifiers.non_core_manpower = config.non_core_manpower; }
			if (main.users[current_user].modifiers.army_travel_speed == undefined) { main.users[current_user].modifiers.army_travel_speed = 1; }
			if (main.users[current_user].modifiers.colonist_travel_speed == undefined) { main.users[current_user].modifiers.colonist_travel_speed = 1; }
			if (main.users[current_user].modifiers.training_cost == undefined) { main.users[current_user].modifiers.training_cost = 1; }
			
			if (main.users[current_user].modifiers.starting_diplomatic_slots == undefined) { main.users[current_user].modifiers.starting_diplomatic_slots = 3; }
			if (main.users[current_user].modifiers.cb_generation_speed == undefined) { main.users[current_user].modifiers.cb_generation_speed = 1; }
			if (main.users[current_user].modifiers.infamy_loss == undefined) { main.users[current_user].modifiers.infamy_loss = config.infamy_loss; }
			if (main.users[current_user].modifiers.stability_modifier == undefined) { main.users[current_user].modifiers.stability_modifier = 0; }
			if (main.users[current_user].modifiers.political_capital_gain == undefined) { main.users[current_user].modifiers.political_capital_gain = config.political_capital_gain; }
			if (main.users[current_user].modifiers.war_exhaustion_rate == undefined) { main.users[current_user].modifiers.war_exhaustion_rate = 1; }
			if (main.users[current_user].modifiers.war_exhaustion == undefined) { main.users[current_user].modifiers.war_exhaustion = 0; }
			if (main.users[current_user].modifiers.reform_desire_gain == undefined) { main.users[current_user].modifiers.reform_desire_gain = 0.02; }
			if (main.users[current_user].modifiers.reform_desire == undefined) { main.users[current_user].modifiers.reform_desire = 0; }
			
			if (main.users[current_user].modifiers.prestige_gain == undefined) { main.users[current_user].modifiers.prestige_gain = 0; }
			
			if (main.users[current_user].modifiers.tax_efficiency == undefined) { main.users[current_user].modifiers.tax_efficiency = 0.15; }
			if (main.users[current_user].modifiers.research_efficiency == undefined) { main.users[current_user].modifiers.research_efficiency = 0.20; }
			if (main.users[current_user].modifiers.production_efficiency == undefined) { main.users[current_user].modifiers.production_efficiency = 1; }
			if (main.users[current_user].modifiers.building_cost == undefined) { main.users[current_user].modifiers.building_cost = 1; }
			if (main.users[current_user].modifiers.unit_cost == undefined) { main.users[current_user].modifiers.unit_cost = 1; }
			if (main.users[current_user].modifiers.training_cost == undefined) { main.users[current_user].modifiers.training_cost = 1; }
			if (main.users[current_user].modifiers.rgo_throughput == undefined) { main.users[current_user].modifiers.rgo_throughput = config.rgo_modifier; }
			if (main.users[current_user].modifiers.shipment_time == undefined) { main.users[current_user].modifiers.shipment_time = 1; }
			
			if (main.users[current_user].modifiers.extra_building_slots == undefined) { main.users[current_user].modifiers.extra_building_slots = 0; }
			if (main.users[current_user].modifiers.maximum_expeditions == undefined) { main.users[current_user].modifiers.maximum_expeditions = 1; }
			
			if (main.users[current_user].temporary_modifiers == undefined) { main.users[current_user].temporary_modifiers = []; }
			
			//New Modifiers from 5.1
			{
				//Political
				if (main.users[current_user].modifiers.administrative_efficiency == undefined) { main.users[current_user].modifiers.administrative_efficiency = 0.5; }
				if (main.users[current_user].modifiers.advisor_cost == undefined) { main.users[current_user].modifiers.advisor_cost = 1; }
				if (main.users[current_user].modifiers.centralisation == undefined) { main.users[current_user].modifiers.centralisation = 0; }
				if (main.users[current_user].modifiers.crime_rate == undefined) { main.users[current_user].modifiers.crime_rate = 0.05; }
				if (main.users[current_user].modifiers.centralisation_gain == undefined) { main.users[current_user].modifiers.centralisation_gain = 0; }
				if (main.users[current_user].modifiers.influence == undefined) { main.users[current_user].modifiers.influence = 0; }
				if (main.users[current_user].modifiers.influence_gain == undefined) { main.users[current_user].modifiers.influence_gain = 5; }
				if (main.users[current_user].modifiers.jingoism == undefined) { main.users[current_user].modifiers.jingoism = 0; }
				if (main.users[current_user].modifiers.knowledge_investment_limit == undefined) { main.users[current_user].modifiers.knowledge_investment_limit = 1; }
				if (main.users[current_user].modifiers.opinion_modifier == undefined) { main.users[current_user].modifiers.opinion_modifier = 0; }
				if (main.users[current_user].modifiers.overextension_modifier == undefined) { main.users[current_user].modifiers.overextension_modifier = 0; }
				if (main.users[current_user].modifiers.republicanism == undefined) { main.users[current_user].modifiers.republicanism = 0; }
				if (main.users[current_user].modifiers.ruling_party_support == undefined) { main.users[current_user].modifiers.ruling_party_support = 0; }
				
				//Economic
				for (var i = 0; i < config.pop_array.length; i++) {
					if (main.users[current_user].modifiers[config.pop_array[i] + "_growth_modifier"] == undefined) { main.users[current_user].modifiers[config.pop_array[i] + "_growth_modifier"] = 1; }
				}
				for (var i = 0; i < config.materials.length; i++) {
					if (main.users[current_user].modifiers[config.materials[i] + "_gain"] == undefined) { main.users[current_user].modifiers[config.materials[i] + "_gain"] = 1; }
				}
				for (var i = 0; i < config.building_categories.length; i++) {
					if (main.users[current_user].modifiers[config.building_categories[i] + "_building_slots"] == undefined) { main.users[current_user].modifiers[config.building_categories[i] + "_building_slots"] = 1; }
				}
				
				if (main.users[current_user].modifiers.construction_speed == undefined) { main.users[current_user].modifiers.construction_speed = 1; }
				if (main.users[current_user].modifiers.isolation == undefined) { main.users[current_user].modifiers.isolation = 0.50; }
				if (main.users[current_user].modifiers.research_slots == undefined) { main.users[current_user].modifiers.research_slots = 3; }
				if (main.users[current_user].modifiers.shipment_capacity == undefined) { main.users[current_user].modifiers.shipment_capacity = 50; }
				
				//Military
				if (main.users[current_user].modifiers.ack_ack_effectiveness == undefined) { main.users[current_user].modifiers.ack_ack_effectiveness = 1; }
				if (main.users[current_user].modifiers.air_interception_range == undefined) { main.users[current_user].modifiers.air_interception_range = 1; }
				if (main.users[current_user].modifiers.attrition_rate == undefined) { main.users[current_user].modifiers.attrition_rate = 1; }
				if (main.users[current_user].modifiers.army_professionalism == undefined) { main.users[current_user].modifiers.army_professionalism = 1; }
				if (main.users[current_user].modifiers.blockade_efficiency == undefined) { main.users[current_user].modifiers.blockade_efficiency = 0.2; }
				if (main.users[current_user].modifiers.casualty_reduction == undefined) { main.users[current_user].modifiers.casualty_reduction = 1; }
				if (main.users[current_user].modifiers.command_power_gain == undefined) { main.users[current_user].modifiers.command_power_gain = 1; }
				if (main.users[current_user].modifiers.combat_order == undefined) { main.users[current_user].modifiers.combat_order = config.combat_order; }
				if (main.users[current_user].modifiers.mobilisation_impact == undefined) { main.users[current_user].modifiers.mobilisation_impact = 1; }
				if (main.users[current_user].modifiers.mobilisation_size == undefined) { main.users[current_user].modifiers.mobilisation_size = 1; }
				if (main.users[current_user].modifiers.mobilisation_speed == undefined) { main.users[current_user].modifiers.mobilisation_speed = 1; }
				if (main.users[current_user].modifiers.navy_professionalism == undefined) { main.users[current_user].modifiers.navy_professionalism = 1; }
				if (main.users[current_user].modifiers.supply_consumption == undefined) { main.users[current_user].modifiers.supply_consumption = 1; }
				
				//Colonisation
				if (main.users[current_user].modifiers.colonial_immigration_rate == undefined) { main.users[current_user].modifiers.colonial_immigration_rate = 1; }
				if (main.users[current_user].modifiers.colonial_maintenance == undefined) { main.users[current_user].modifiers.colonial_maintenance = 1; }
				if (main.users[current_user].modifiers.colonial_power_gain == undefined) { main.users[current_user].modifiers.colonial_power_gain = 1; }
				if (main.users[current_user].modifiers.colonial_power_cap == undefined) { main.users[current_user].modifiers.colonial_power_cap = 50; }
				
				if (main.users[current_user].modifiers.colonial_power == undefined) { main.users[current_user].modifiers.colonial_power = 0; }
			}
			
			//National spirits
			if (main.users[current_user].national_spirits == undefined) { main.users[current_user].national_spirits = {}; }
			
			//Unit modifiers
			for (var i = 0; i < config.unit_categories.length; i++) {
				if (main.users[current_user].modifiers[config.unit_categories[i] + "_ap"] == undefined) { main.users[current_user].modifiers[config.unit_categories[i] + "_ap"] = 1; }
				if (main.users[current_user].modifiers[config.unit_categories[i] + "_dp"] == undefined) { main.users[current_user].modifiers[config.unit_categories[i] + "_dp"] = 1; }
			}
			
			//Obsoletion mechanics
			if (main.users[current_user].available_units == undefined) { main.users[current_user].available_units = []; }
			if (main.users[current_user].available_buildings == undefined) { main.users[current_user].available_buildings = []; }
			if (main.users[current_user].available_governments == undefined) { main.users[current_user].available_governments = []; }
			if (main.users[current_user].enable_blockades == undefined) { main.users[current_user].enable_blockades = false; }
			if (main.users[current_user].enable_mobilisation == undefined) { main.users[current_user].enable_mobilisation = false; }
			if (main.users[current_user].mobilise_unit == undefined) { main.users[current_user].mobilise_unit = ""; }
			
			if (main.users[current_user].researched_technologies == undefined) { main.users[current_user].researched_technologies = []; }
			if (main.users[current_user].researching == undefined) { main.users[current_user].researching = []; }
			if (main.users[current_user].research_queue == undefined) { main.users[current_user].research_queue = []; }
			
			//Events
			if (main.users[current_user].events == undefined) { main.users[current_user].events = []; }
			if (main.users[current_user].triggered_events == undefined) { main.users[current_user].triggered_events = {}; }
			if (main.users[current_user].previous_option_id == undefined) { main.users[current_user].previous_option_id = 0; }
			
			//Crafting values
			if (main.users[current_user].actions == undefined) { main.users[current_user].actions = 10; }
			
			if (main.users[current_user].civilian_actions == undefined) { main.users[current_user].civilian_actions = 0; }
			if (main.users[current_user].civilian_actions_percentage == undefined) { main.users[current_user].civilian_actions_percentage = 0; }
			if (main.users[current_user].refining_actions == undefined) { main.users[current_user].refining_actions = 0; }
			
			for (var i = 0; i < config.unit_categories.length; i++) {
				if (main.users[current_user][config.unit_categories[i] + "_cp"] == undefined) { main.users[current_user][config.unit_categories[i] + "_cp"] = 0; }
			}
			
			//Add all materials to inventory
			for (var i = 0; i < config.materials.length; i++) {
				if (main.users[current_user].inventory[config.materials[i]] == undefined) { main.users[current_user].inventory[config.materials[i]] = 0; }
				if (main.users[current_user].modifiers[config.materials[i]] == undefined) { main.users[current_user].modifiers[config.materials[i]] = 1; }
			}
			if (main.users[current_user].knowledge_per_turn == undefined) { main.users[current_user].knowledge_per_turn = 0; }
			if (main.users[current_user].modifiers.actions == undefined) { main.users[current_user].modifiers.actions = 1; }
			
			//Research
			if (main.users[current_user].techs_researched == undefined) { main.users[current_user].techs_researched = 0; }
			for (var i = 0; i < config.tech_categories.length; i++) {
				if (main.users[current_user][config.tech_categories[i] + "_researched"] == undefined) { main.users[current_user][config.tech_categories[i] + "_researched"] = 0; }
			}
			
			//Add all buildings
			for (var i = 0; i < config.buildings.length; i++) {
				if (main.users[current_user].buildings[config.buildings[i]] == undefined) { main.users[current_user].buildings[config.buildings[i]] = 0; }
				if (main.users[current_user].modifiers[config.buildings[i]] == undefined) { main.users[current_user].modifiers[config.buildings[i]] = 1; }
			}
			
			//Politics
			if (main.users[current_user].political_capital == undefined) { main.users[current_user].political_capital = 150; }
			if (main.users[current_user].available_reforms == undefined) { main.users[current_user].available_reforms = []; }
			if (main.users[current_user].political_instability_modifier == undefined) { main.users[current_user].political_instability_modifier = 0; }
			if (main.users[current_user].political_reform_desire_modifier == undefined) { main.users[current_user].political_reform_desire_modifier = 0; }
			if (main.users[current_user].political_capital_gain_modifier == undefined) { main.users[current_user].political_capital_gain_modifier = 0; }
			
			//Add all political parties
			for (var i = 0; i < config.government_list.length; i++) {
				if (main.users[current_user].politics[config.government_list[i]] == undefined) { main.users[current_user].politics[config.government_list[i]] = 0; }
			}
			for (var i = 0; i < config.government_list.length; i++) {
				if (main.users[current_user].modifiers[config.government_list[i]] == undefined) { main.users[current_user].modifiers[config.government_list[i]] = 1; }
				if (main.users[current_user].modifiers[config.government_list[i] + "_discontent"] == undefined) { main.users[current_user].modifiers[config.government_list[i] + "_discontent"] = 0; }
			}
			
			//Cities
			if (main.users[current_user].cities.province_array == undefined) { main.users[current_user].cities.province_array = []; }
			if (main.users[current_user].cities.city_array == undefined) { main.users[current_user].cities.city_array = []; }
			if (main.users[current_user].city_cap == undefined) { main.users[current_user].city_cap = 3; }
			if (main.users[current_user].city_count == undefined) { main.users[current_user].city_count = 0; }
			
			if (main.users[current_user].random_drop == undefined) { main.users[current_user].random_drop = randomNumber(5, 7); }
			
			//Population
			if (main.users[current_user].culture == undefined) { main.users[current_user].culture = ""; }
			if (main.users[current_user].accepted_cultures == undefined) { main.users[current_user].accepted_cultures = []; }
			if (main.users[current_user].pops.pop_array == undefined) { main.users[current_user].pops.pop_array = []; }
			for (var i = 0; i < config.pop_array.length; i++) {
				if (main.users[current_user][config.pop_array[i]] == undefined) { main.users[current_user][config.pop_array[i]] = 0; }
				if (main.users[current_user]["used_" + config.pop_array[i]] == undefined) { main.users[current_user]["used_" + config.pop_array[i]] = 0; }
			}
			if (main.users[current_user].pop_tax_efficiency == undefined) { main.users[current_user].pop_tax_efficiency = 0; }
			if (main.users[current_user].pop_stability == undefined) { main.users[current_user].pop_stability = 0; }
			if (main.users[current_user].pop_research_efficiency == undefined) { main.users[current_user].pop_research_efficiency = 0; }
			if (main.users[current_user].pop_knowledge == undefined) { main.users[current_user].pop_knowledge = 0; }
			
			//Assimilation and accepted cultures
			if (main.users[current_user].assimilations == undefined) { main.users[current_user].assimilations = []; }
			if (main.users[current_user].cultural_integrations == undefined) { main.users[current_user].cultural_integrations = []; }
			
			//Add all military units
			for (var i = 0; i < config.units.length; i++) {
				if (main.users[current_user].military[config.units[i]] == undefined) { main.users[current_user].military[config.units[i]] = 0; }
			}
			
			if (main.users[current_user]["armies"] == undefined) { main.users[current_user]["armies"] = {}; }
			if (main.users[current_user]["armies"].army_array == undefined) { main.users[current_user]["armies"].army_array = []; }
			
			if (main.users[current_user].last_election == undefined) { main.users[current_user].last_election = 0; }
			
			//Trade [[3, "iron"], "213287117017710593", 3]
			if (main.users[current_user].auto_trades == undefined) { main.users[current_user].auto_trades = []; }
			if (main.users[current_user].trade_array == undefined) { main.users[current_user].trade_array = []; }
			
			//Stats
			if (main.users[current_user].last_turn_income == undefined) { main.users[current_user].last_turn_income = 0; }
			if (main.users[current_user].stability_reform_desire == undefined) { main.users[current_user].stability_reform_desire = 0; }
			
			if (main.users[current_user].blockaded_war_exhaustion == undefined) { main.users[current_user].blockaded_war_exhaustion = 0; }
			
			if (already_registered == false) {
				//Starting function from config
				config.starting_kit(main.users[current_user]);
				
				//Push at end
				main.user_array.push(current_user);
			}
			
			//Temp logic
			{
				
				//Variables
				var user = main.users[current_user];
				var all_modifiers = Object.keys(main.users[current_user].modifiers);
				var cities = main.users[current_user].cities;
				
				main.users[current_user].actions = Math.round(main.users[current_user].actions);
				
				//Relations
				if (main.users[current_user].infamy == null) { main.users[current_user].infamy = 5; }
				
				var temp_user_array = main.user_array;
				if (main.users[current_user].used_diplomatic_slots == undefined) { main.users[current_user].used_diplomatic_slots = 0; }
				if (main.users[current_user].rival_slots == undefined) { main.users[current_user].rival_slots = config.rival_slots; }
				if (main.users[current_user].relations == undefined) { main.users[current_user].relations = []; }
				if (main.users[current_user].allies == undefined) { main.users[current_user].allies = []; }
				if (main.users[current_user].rivals == undefined) { main.users[current_user].rivals = []; }
				if (main.users[current_user].guarantees == undefined) { main.users[current_user].guarantees = []; }
				if (main.users[current_user].military_access == undefined) { main.users[current_user].military_access = []; }
				if (main.users[current_user].non_aggression_pacts == undefined) { main.users[current_user].non_aggression_pacts = []; }
				if (main.users[current_user].vassals == undefined) { main.users[current_user].vassals = []; }
				
				if (main.users[current_user].casus_belli == undefined) { main.users[current_user].casus_belli = []; }
				if (main.users[current_user].justifications == undefined) { main.users[current_user].justifications = []; }
				if (main.users[current_user].wargoals == undefined) { main.users[current_user].wargoals = []; }
				if (main.users[current_user].blockaded_by == undefined) { main.users[current_user].blockaded_by = ""; }
				
				if (main.users[current_user].vassal_years == undefined) { main.users[current_user].vassal_years = 0; }
				
				//[[value, player_id, [improving/decreasing/none, turns]]
				for (var i = 0; i < temp_user_array.length; i++) {
					var player_currently_exists_in_array = false;
					for (var x = 0; x < user.relations.length; x++) {
						if (user.relations[x][1] == temp_user_array[i]) {
							player_currently_exists_in_array = true;
						}
					}
					
					if (player_currently_exists_in_array == false) {
						//Add relation as neutral
						if (temp_user_array[i] != current_user) { //Can't have relations with yourself
							user.relations.push([0, temp_user_array[i], ["none", 0]]);
						}
					}
				}
				
				//War Exhaustion
				if (main.users[current_user].at_war.length > 0) {
					//Full occupation
					if (main.users[current_user].provinces == 0) {
						main.users[current_user].modifiers.war_exhaustion = 100;
					}
				}
			}
		}
		
		function logicCheck (arg0_user) {
			//Convert from parameters
			var current_user = main.users[arg0_user].id;
			var usr = main.users[arg0_user];
			var cities = main.users[arg0_user].cities;
			
			console.log("Checking logic for " + current_user);
			
			//Apply National Modifiers
			applyNationalModifiers(usr.id);
			
			//Options logic
			{
				usr.avoid_attrition = (!["always", "if possible", "never"].includes(usr.avoid_attrition)) ? "if possible" : usr.avoid_attrition;
				usr.avoid_territorial_violation = (!["always", "if possible", "never"].includes(usr.avoid_territorial_violation)) ? "if possible" : usr.avoid_territorial_violation;
			}
			
			//Temp Logic
			{
				if (main.users[current_user].used_workers < 0) {
					main.users[current_user].used_workers = 0;
				} else if (main.users[current_user].used_workers > main.users[current_user].workers) {
					main.users[current_user].used_workers = main.users[current_user].workers;
				}
				
				if (main.users[current_user].used_soldiers < 0) {
					main.users[current_user].used_soldiers = 0;
				}
				var total_cities = 0;
				for (var i = 0; i < usr.cities.city_array.length; i++) {
					//Set capital if bugged
					var local_city_obj = usr.cities[usr.cities.city_array[i]];
					if (local_city_obj.type == "capital") {
						main.users[current_user].capital_id = parseInt(local_city_obj.province);
					}
					
					var is_occupied = false;
					for (var x = 0; x < main.users.global.occupations.length; x++) {
						if (main.users.global.occupations[x][0] == usr.cities[usr.cities.city_array[i]].province) {
							is_occupied = true;
						}
					}
					
					if (is_occupied == false) {
						total_cities++;
					}
				}
				usr.city_count = total_cities;
				
				//Make sure that population is being calculated correctly
				for (var i = 0; i < config.pop_array.length; i++) {
					if (isNaN(usr[config.pop_array[i]])) {
						usr[config.pop_array[i]] = 0;
					}
				}
				for (var i = 0; i < usr.pops.pop_array.length; i++) {
					usr.pops.pop_array[i] = usr.pops.pop_array[i].toString();
				}
				
				//Round all materials and other things to whole numbers
				main.users[current_user].stability = Math.round(main.users[current_user].stability);
				main.users[current_user].infamy = Math.round(main.users[current_user].infamy*100)/100;
				for (var i = 0; i < config.materials.length; i++) {
					if (isNaN(usr.inventory[config.materials[i]])) {
						usr.inventory[config.materials[i]] = 0;
					}
					main.users[current_user].inventory[config.materials[i]] = Math.round(main.users[current_user].inventory[config.materials[i]]);
				}
				
				if (isNaN(usr.money)) {
					returnChannels.send(announcements_channel, usr.name + " ran into trouble whilst calculating their financial balance sheets, and their balance has been reset for stability purposes.");
					usr.money = 0;
				}
				if (isNaN(usr.modifiers.war_exhaustion)) {
					usr.modifiers.war_exhaustion = 100;
				}
				
				//Check for negative CP
				for (var i = 0; i < config.unit_categories.length; i++) {
					if (usr[config.unit_categories[i] + "_cp"] < 0) {
						usr[config.unit_categories[i] + "_cp"] = 0;
					}
				}
				
				//Mobilisation
				if (usr.mobilised_manpower[1] != "") {
					if (usr.mobilised_manpower[0] == 0) { //Demobilise if user has 0 forces remaining
						usr.mobilised_manpower = [0, "", 0, 0, 0];
						usr.last_mobilised = main.roundCount;
					}
				}
				
				//Infamy
				if (usr.infamy > 15) {
					usr.infamy = 15;
				}
				
				//War Exhaustion
				if (usr.province_war_exhaustion != 0) {
					usr.modifiers.war_exhaustion = usr.modifiers.war_exhaustion + returnSafeNumber(usr.province_war_exhaustion);
					usr.province_war_exhaustion = 0;
				}
				if (usr.modifiers.war_exhaustion < 0) {
					usr.modifiers.war_exhaustion = 0;
				}
				if (usr.modifiers.war_exhaustion > 100) {
					usr.modifiers.war_exhaustion = 100;
				}
				
				//Infamy
				if (usr.modifiers.infamy_loss > config.infamy_loss) {
					usr.modifiers.infamy_loss = config.infamy_loss;
				}
				
				//Make sure that countries cannot have a deficit or negative surplus of pops
				for (var i = 0; i < config.pop_array.length; i++) {
					if (usr["used_" + config.pop_array[i]] > usr[config.pop_array[i]]) {
						usr["used_" + config.pop_array[i]] = usr[config.pop_array[i]];
					}
					if (usr["used_" + config.pop_array[i]] < 0) {
						usr["used_" + config.pop_array[i]] = 0;
					}
					if (usr[config.pop_array[i]] < 0) {
						usr[config.pop_array[i]] = 0;
					}
				}
				
				//Check for NaN in pops
				for (var i = 0; i < usr.pops.pop_array.length; i++) {
					if (isNaN(parseInt(usr.pops.pop_array[i]))) {
						usr.pops.pop_array.splice(i, 1);
					}
				}
				for (var i = 0; i < usr.pops.pop_array.length; i++) {
					var found_invalid_pop = false;
					if (usr.pops[usr.pops.pop_array[i]] != undefined) {
						for (var x = 0; x < config.pop_array.length; x++) {
							if (usr.pops[usr.pops.pop_array[i]][config.pop_array[x]] != undefined) {
								if (isNaN(usr.pops[usr.pops.pop_array[i]][config.pop_array[x]])) {
									usr.pops[usr.pops.pop_array[i]][config.pop_array[x]] = 1;
									found_invalid_pop = true;
								}
								if (usr.pops[usr.pops.pop_array[i]][config.pop_array[x]] <= 0) {
									usr.pops[usr.pops.pop_array[i]][config.pop_array[x]] = 1;
									found_invalid_pop = true;
								}
							}
						}
						
						if (found_invalid_pop) {
							var total_population = 0;
							for (var x = 0; x < config.pop_array.length; x++) {
								total_population = total_population + usr.pops[usr.pops.pop_array[i]][config.pop_array[x]];
							}
							
							usr.pops[usr.pops.pop_array[i]].population = total_population;
						}
					}
				}
				
				for (var i = 0; i < usr.armies.army_array.length; i++) {
					if (isNaN(parseInt(usr.armies[usr.armies.army_array[i]].province))) {
						usr.armies[usr.armies.army_array[i]].province = usr.capital_id;
					}
				}
				
				var all_wars = Object.keys(main.users.global.wars);
				var all_at_war = [];
				for (var i = 0; i < all_wars.length; i++) {
					var local_war = main.users.global.wars[all_wars[i]];
					var friendly_side;
					var opposite_side;
					
					for (var x = 0; x < local_war.attackers.length; x++) {
						if (local_war.attackers[x] == usr.id) {
							friendly_side = "attackers";
							opposite_side = "defenders";
						}
					}
					for (var x = 0; x < local_war.defenders.length; x++) {
						if (local_war.defenders[x] == usr.id) {
							friendly_side = "defenders";
							opposite_side = "attackers";
						}
					}
					
					if (friendly_side && opposite_side) {
						for (var x = 0; x < local_war[opposite_side].length; x++) {
							if (!all_at_war.includes(local_war[opposite_side][x])) {
								all_at_war.push(main.users[local_war[opposite_side][x]].name);
							}
						}
					}
				}
				usr.at_war = all_at_war;
				
				//Remove duplicate pops
				var unique_pops = [];
				for (var i = 0; i < usr.pops.pop_array.length; i++) {
					var matched_pop = false;
					for (var x = 0; x < unique_pops.length; x++) {
						if (unique_pops[x] == usr.pops.pop_array[i]) {
							matched_pop = true;
						}
					}
					
					if (matched_pop == false) {
						unique_pops.push(usr.pops.pop_array[i]);
					} else {
						usr.pops.pop_array.splice(i, 1);
					}
				}
				
				//Check for undefined pops
				for (var i = 0; i < usr.pops.pop_array.length; i++) {
					if (usr.pops[usr.pops.pop_array[i]] == undefined) {
						var is_urban = false;
						var urban_population = 0;
						for (var x = 0; x < usr.cities.city_array.length; x++) {
							if (usr.cities[usr.cities.city_array[x]].province == usr.pops.pop_array[i]) {
								is_urban = true;
								urban_population = usr.cities[usr.cities.city_array[x]].population;
							}
						}
						
						if (is_urban) {
							generatePops(current_user, usr.pops.pop_array[i], urban_population, [20000, 50000]);
						} else {
							generatePops(current_user, usr.pops.pop_array[i], [15000, 150000], [20000, 50000]);
						}
					}
				}
				for (var i = 0; i < usr.cities.province_array.length; i++) {
					if (usr.pops[usr.cities.province_array[i]] == undefined) {
						
						var is_urban = false;
						var urban_population = 0;
						for (var x = 0; x < usr.cities.city_array.length; x++) {
							if (usr.cities[usr.cities.city_array[x]].province == usr.cities.province_array[i]) {
								is_urban = true;
								urban_population = usr.cities[usr.cities.city_array[x]].population;
							}
						}
						
						if (is_urban) {
							generatePops(current_user, usr.cities.province_array[i], urban_population, [20000, 50000]);
						} else {
							generatePops(current_user, usr.cities.province_array[i], [15000, 150000], [20000, 50000]);
						}
					}
				}
				
				//Reset pops.pop_array
				usr.pops.pop_array = Object.keys(usr.pops);
				if (usr.pops.pop_array.includes("pop_array")) {
					usr.pops.pop_array.splice(usr.pops.pop_array.indexOf("pop_array"), 1);
				}
				
				//City cap
				for (var i = 0; i < cities.city_array.length; i++) {
					if (cities[cities.city_array[i]] != undefined) {
						var city_obj = cities[cities.city_array[i]];
						
						if (city_obj.name == "") {
							city_obj.name = "Name Invalid";
						}
						
						var total_building_cap = 0;
						var total_building_count = 0;
						
						if (city_obj.development == undefined || city_obj.development == null) {
							city_obj.development = 0;
						}
						
						for (var x = 0; x < config.building_categories.length; x++) {
							if (city_obj[config.building_categories[x] + "_development"] == undefined) {
								city_obj[config.building_categories[x] + "_development"] = 0;
							}
							city_obj[config.building_categories[x] + "_building_slots"] = (usr.modifiers[config.building_categories[x] + "_building_slots"] + city_obj[config.building_categories[x] + "_development"]);
							total_building_cap = total_building_cap + city_obj[config.building_categories[x] + "_building_slots"];
						}
						
						for (var x = 0; x < config.buildings.length; x++) {
							if (config[config.building_stats[config.buildings[x]].category + "_disable_slots"] != true) {
								total_building_count = total_building_count + cities[cities.city_array[i]].buildings[config.buildings[x]];
							}
						}
						city_obj.building_cap = total_building_cap;
						city_obj.building_count = total_building_count;
					}
				}
				
				for (var i = 0; i < config.unit_categories.length; i++) {
					main.users[current_user][config.unit_categories[i] + "_cp"] = Math.round(main.users[current_user][config.unit_categories[i] + "_cp"]);
				}
				
				if (config.city_unlock_caps.length > 0) {
					for (var i = 0; i < config.city_unlock_caps.length; i++) {
						var next_bound = config.city_unlock_caps[i+1];
						
						if (next_bound != undefined) {
							if (main.users[current_user].provinces >= config.city_unlock_caps[i] && main.users[current_user].provinces < next_bound) {
								main.users[current_user].city_cap = (i+1);
							}
						} else {
							if (main.users[current_user].provinces >= config.city_unlock_caps[i]) {
								main.users[current_user].city_cap = (i+1);
							}
						}
					}
				} else {
					main.users[current_user].city_cap = main.users[current_user].provinces;
				}
				
				//Fix army_array
				var new_army_array = [];
				var all_armies = Object.keys(usr.armies);
				for (var i = 0; i < all_armies.length; i++) {
					if (all_armies[i] != "army_array") {
						new_army_array.push(all_armies[i]);
					}
				}
				
				usr.armies.army_array = new_army_array;
				
				//Check for strings in moving_to
				for (var i = 0; i < usr.armies.army_array.length; i++) {
					if (usr.armies[usr.armies.army_array[i]] != undefined) {
						if (usr.armies[usr.armies.army_array[i]].moving_to != undefined) {
							if (Array.isArray(usr.armies[usr.armies.army_array[i]].moving_to) == false) {
								usr.armies[usr.armies.army_array[i]].moving_to = [];
							}
						}
					}
				}
				
				//Reforms
				var all_reform_categories = Object.keys(config.reforms);
				for (var i = 0; i < all_reform_categories.length; i++) {
					var all_reforms_in_category = Object.keys(config.reforms[all_reform_categories[i]]);
					for (var x = 0; x < all_reforms_in_category.length; x++) {
						if (all_reforms_in_category[x] == "name") {
							all_reforms_in_category.splice(x, 1);
						}
					}
					
					if (main.users[current_user][all_reform_categories[i]] == undefined) { main.users[current_user][all_reform_categories[i]] = all_reforms_in_category[0]; }
				}
			}
		
			//Vassal Logic
			{
				//Remove nonexistent vassals
				for (var i = 0; i < usr.vassals.length; i++) {
					var local_vassal = main.users[usr.vassals[i]];
					if (local_vassal.eliminated) {
						usr.vassals.splice(i, 1);
					}
				}
				//Enable customisation by default if overlord does not exist
				if (!getOverlord(usr)) {
					usr.customisation_locked = false;
				}
			}
			
			//Modifier Caps
			{
				if (usr.modifiers.tax_efficiency > 2) {
					usr.modifiers.tax_efficiency = 2;
				}
				if (usr.modifiers.tax_efficiency < 0.10) {
					usr.modifiers.tax_efficiency = 0.10;
				}
				if (usr.modifiers.rgo_throughput < 0.05) {
					usr.modifiers.rgo_throughput = 0.05;
				}
				if (usr.modifiers.research_efficiency > 2) {
					usr.modifiers.research_efficiency = 2;
				}
				if (usr.modifiers.research_efficiency < 0.10) {
					usr.modifiers.research_efficiency = 0.10;
				}
				if (usr.modifiers.production_efficiency > 2) {
					usr.modifiers.production_efficiency = 2;
				}
				if (usr.modifiers.production_efficiency < 0.05) {
					usr.modifiers.production_efficiency = 0.05;
				}
				if (usr.modifiers.mobilisation_speed < 0.5) {
					usr.modifiers.mobilisation_speed = 0.5;
				}
				if (usr.modifiers.army_travel_speed > 6) {
					usr.modifiers.army_travel_speed = 6;
				}
				if (usr.modifiers.army_travel_speed < 0.10) {
					usr.modifiers.army_travel_speed = 0.10;
				}
				if (usr.modifiers.colonist_travel_speed > 4) {
					usr.modifiers.colonist_travel_speed = 4;
				}
				if (usr.modifiers.shipment_time > 2) {
					usr.modifiers.shipment_time = 2;
				}
				if (usr.modifiers.shipment_time < 0.05) {
					usr.modifiers.shipment_time = 0.05;
				}
				if (usr.modifiers.stability_modifier > 100) {
					usr.modifiers.stability_modifier = 100;
				}
				if (usr.modifiers.stability_modifier < -100) {
					usr.modifiers.stability_modifier = -100;
				}
				if (usr.modifiers.infamy_loss > 0.1) {
					usr.modifiers.infamy_loss = 0.1;
				}
				if (usr.modifiers.war_exhaustion_rate > 5) {
					usr.modifiers.war_exhaustion_rate = 5;
				}
				if (usr.modifiers.building_cost < 0.1) {
					usr.modifiers.building_cost = 0.1;
				}
				if (usr.modifiers.building_cost > 2) {
					usr.modifiers.building_cost = 2;
				}
				if (usr.modifiers.unit_cost < 0.1) {
					usr.modifiers.unit_cost = 0.1;
				}
				if (usr.modifiers.unit_cost > 2) {
					usr.modifiers.unit_cost = 2;
				}
				if (usr.pop_growth_modifier < 0.95) {
					usr.pop_growth_modifier = 0.95;
				}
				
				//Deal with NaN's
				usr.modifiers.production_efficiency = (isNaN(usr.modifiers.production_efficiency)) ? 1 : usr.modifiers.production_efficiency;
				usr.modifiers.research_efficiency = (isNaN(usr.modifiers.research_efficiency)) ? 1 : usr.modifiers.research_efficiency;
				usr.modifiers.rgo_throughput = (isNaN(usr.modifiers.rgo_throughput)) ? 1 : usr.modifiers.rgo_throughput;
			}
		
			//Provinces
			{
				var total_provinces = usr.pops.pop_array.length;
				var occupied_provinces = [];
				
				for (var i = 0; i < main.users.global.occupations.length; i++) if (main.users.global.occupations[i][3] == usr.id && !occupied_provinces.includes(main.users.global.occupations[i][0])) 
					occupied_provinces.push(main.users.global.occupations[i][0]);
				
				usr.provinces = total_provinces-occupied_provinces.length;
			}
		}
		
		function nextTurnAI (arg0_user) {
			//Convert from parameters
			var ai_id = arg0_user;
			var user_id = arg0_user;
			var usr = (main.users[arg0_user]) ? main.users[arg0_user] : undefined;
			
			//Check to see if user is defined
			if (usr) {
				try { //Never hurts!
					//Declare secondary instance variables
					var ai_obj = config.ai_types[usr.ai.ai_template];
					var temp_local_user = JSON.parse(JSON.stringify(usr));
					var local_user = nextTurn(temp_local_user, true);
					
					//AI variable processing
					{
						//Actually useful variables not for turn processing
						usr.ai.per_turn_demand = {};
						usr.ai.province_limit = config.expansionism_fraction*config.max_provinces*returnSafeNumber(usr.expansionism, 1)*config.max_expansion_willingness;
						usr.ai.recently_colonised_provinces = (usr.ai.recently_colonised_provinces) ? [] : usr.ai.recently_colonised_provinces;
						
						//Many of these are temporary metric variables for loading purposes
						usr.ai.ran_out_of_slots = false;
						usr.ai.buy_transactions = 0;
						usr.ai.colonist_crafting_length = 0;
						usr.ai.colonists_crafted = 0;
						usr.ai.constructions_fulfilled = 0;
						usr.ai.failed_build_commands = []; //Same format as building_queue
						usr.ai.processed_failed_builds = 0;
						usr.ai.sell_commands = 0;
						usr.ai.sell_transactions = 0;
						
						//AI array processing
						for (var i = 0; i < usr.ai.recently_colonised_provinces.length; i++) {
							var local_element = usr.ai.recently_colonised_provinces[i];
							local_element[i][2]++;
							if (local_element[i][2] > Math.max(config.adjacency_importance_turns, config.power_importance_turns, config.rival_importance_turns)) usr.ai.recently_colonised_provinces.splice(i, 1);
						}
					}
					
					//Building/Economy AI
					{
						var goods_importance = generateGoodsMatrix(user_id);
						var goods_production = getProduction(user_id, "all", true);
						var all_produced_goods = Object.keys(goods_production);
						var all_scored_goods = Object.keys(goods_importance);
						
						//Action Management
						var action_consumption_modifier = (usr.country_age <= config.lessen_action_consumption) ? 1 : 0.5;
						
						var mineable_importance = 0;
						var stone_importance = goods_importance.stone;
						var wood_importance = goods_importance.wood;
						
						var total_importance = 0;
						
						for (var i = 0; i < all_scored_goods.length; i++) if (config.mineable_materials.includes(all_scored_goods[i])) mineable_importance += goods_importance[all_scored_goods[i]];
						total_importance = mineable_importance+stone_importance+wood_importance;
						
						//Begin chopping, mining, and quarrying
						var mine_amount = Math.ceil(usr.actions*action_consumption_modifier*(mineable_importance/total_importance));
						var quarry_amount = Math.ceil(usr.actions*action_consumption_modifier*(stone_importance/total_importance));
						var chop_amount = Math.ceil(usr.actions*action_consumption_modifier*(wood_importance/total_importance));
						
						if (mine_amount > 0) addCommand(ai_id, `mine ${mine_amount}`);
						if (quarry_amount> 0) addCommand(ai_id, `quarry ${quarry_amount}`);
						if (chop_amount > 0) addCommand(ai_id, `chop ${chop_amount}`);
						
						//Building Construction
						var building_matrix = generateBuildingMatrix(user_id);
						var building_queue = [];
						
						//Convert them all to building orders
						
						for (var i = 0; i < building_matrix.length; i++) {
							var could_find_slot = false;
							var remaining_buildings = building_matrix[i][1];
							var total_iterations = 0;
							
							while (true) {
								if (total_iterations < 20) {
									var available_slot = getAvailableBuildingSlot(user_id, building_matrix[i][0]); //[city_name, building_slots_remaining]
									
									if (remaining_buildings > 0) {
										if (available_slot[1] >= remaining_buildings) {
											building_queue.push([Math.min(available_slot[1], config.split_building_orders), building_matrix[i][0], usr.cities[available_slot[0]].name]);
											remaining_buildings -= Math.min(available_slot[1], config.split_building_orders);
											could_find_slot = true;
										} else {
											if (available_slot[1] > 0) {
												building_queue.push([Math.min(remaining_buildings, config.split_building_orders), building_matrix[i][0], usr.cities[available_slot[0]].name]);
											}
											remaining_buildings = 0;
											could_find_slot = true;
											break;
										}
									} else {
										break;
									}
								} else {
									break;
								}
								
								total_iterations++;
							}
							
							if (!could_find_slot && randomNumber(0, 100) <= config.run_out_of_slots_chance*100) {
								usr.ai.ran_out_of_slots = true;
							}
						}
						
						//Build the building orders!
						for (var i = 0; i < building_queue.length; i++) {
							addCommand(ai_id, `build ${building_queue[i][0]} ${building_queue[i][1]} "${building_queue[i][2]}"`, function () {
								usr.ai.constructions_fulfilled++;
							});
						}
						
						var post_building = setInterval(function(){
							if (usr.ai.constructions_fulfilled >= building_queue.length-1) {
								//Market AI - Selling
								var goods_in_surplus = 0;
								var low_cash = config.low_cash;
								var selling_matrix = generateSellingMatrix(user_id);
								
								for (var i = 0; i < all_produced_goods.length; i++) {
									var local_value = goods_production[all_produced_goods[i]];
									if (Array.isArray(local_value)) {
										if (Math.ceil((local_value[0]+local_value[1])/2)) goods_in_surplus++;
									}
								}
								
								if (Math.min(usr.money, getBalanceNextTurn(user_id)) <= low_cash || goods_in_surplus > 0) {
									var total_sold_amount = 0;
									for (var i = 0; i < selling_matrix.length; i++) {
										var total_market_capacity = usr.modifiers.shipment_capacity*usr.maximum_transaction_amount;
										var remaining_market_capacity = (usr.modifiers.shipment_capacity*usr.maximum_transaction_amount)-total_sold_amount;
										var amount_to_sell = Math.min(Math.ceil(usr.inventory[selling_matrix[i][0]]*0.5), Math.ceil(((usr.modifiers.shipment_capacity*usr.maximum_transaction_amount)-usr.total_transactions_this_turn)*0.5));
										
										//Adjust amount to sell so that it can never exceed 50% of the AI's total market capacity
										amount_to_sell = (Math.floor((total_market_capacity*config.maximum_selling)-(total_sold_amount+amount_to_sell)) < 0) ? Math.floor((total_market_capacity*config.maximum_selling)-total_sold_amount) : amount_to_sell;
										total_sold_amount += amount_to_sell;
										
										//Add sell command
										if (i < config.maximum_goods_for_selling && amount_to_sell > 0) {
											usr.ai.sell_commands++;
											addCommand(ai_id, `sell ${amount_to_sell} ${selling_matrix[i][0]}`, function () {
												usr.ai.sell_transactions++;
											});
										} 
									}
								}
								
								//Market AI - Buying
								var total_bought_amount = 0;
								
								//Only buy if AI user has cash
								var post_selling = setInterval(function(){
									if (usr.ai.sell_transactions == usr.ai.sell_commands) {
										var buy_matrix = generateBuyingMatrix(user_id);
										
										for (var i = 0; i < buy_matrix.length; i++) {
											var total_market_capacity = usr.modifiers.shipment_capacity*usr.maximum_transaction_amount;
											var remaining_market_capacity = (usr.modifiers.shipment_capacity*usr.maximum_transaction_amount)-total_sold_amount-total_bought_amount;
											console.log("Remaining Market Capacity: " + remaining_market_capacity);
											console.log("Buy Matrix: " + buy_matrix[i][1]);
											var amount_to_buy = Math.min(remaining_market_capacity, buy_matrix[i][1]);
											
											//Begin buying stuff, with added conditional at end
											total_bought_amount += amount_to_buy;
											if (amount_to_buy > 0) addCommand(ai_id, `buy ${amount_to_buy} ${buy_matrix[i][0]}`, function () {
												usr.ai.buy_transactions++;
											}, function () {
												return (usr.money >= low_cash*2);
											});
										}
								
										//Reattempt unfulfilled construction requests
										var post_buying = setInterval(function(){
											if (usr.ai.buy_transactions >= buy_matrix.length) {
												//Tax AI
												var money_needed = (config.low_cash-getBalanceNextTurn(user_id))*-1;
												var spare_stability = local_user.stability-40;
												
												if (money_needed >= 0 && spare_stability > 0) {
													var maximum_tax_rate = Math.min(spare_stability, usr.maximum_tax_rate);
													addCommand(ai_id, `set-tax ${maximum_tax_rate}`);
												} else {
													addCommand(ai_id, `set-tax 0`);
												}
												
												//Begin issuing unfulfilled building orders
												for (var i = 0; i < usr.ai.failed_build_commands.length; i++) {
													addCommand(ai_id, `build ${usr.ai.failed_build_commands[i][0]} ${usr.ai.failed_build_commands[i][1]} ${usr.ai.failed_build_commands[i][2]}`, function () {
														usr.ai.processed_failed_builds++;
													});
												}
												
												//For crafting AI and other purposes
												var post_failed_building = setInterval(function(){
													if (usr.ai.processed_failed_builds >= usr.ai.failed_build_commands.length) {
														var colonist_crafting_matrix = generateColonistMatrix(user_id);
															usr.ai.colonist_crafting_length = colonist_crafting_matrix.length;
														for (var i = 0; i < colonist_crafting_matrix.length; i++) {
															addCommand(ai_id, `craft ${colonist_crafting_matrix[1]} ${colonist_crafting_matrix[0]}`, function () {
																usr.ai.colonists_crafted++;
															});
														}
														
														//Clear post_failed_building at end
														clearInterval(post_failed_building);
													}
												}, 100);
											
												//Clear post_buying at end
												clearInterval(post_buying);
											}
										}, 100);
										
										//Clear local loop at end
										clearInterval(post_selling);
									}
								}, 100);
								
								//Clear post_building at end
								clearInterval(post_building);
							}
						}, 100);
					}
					
					//City AI
					{
						var city_processing = setInterval(function(){
							if (usr.ai.processed_failed_builds >= usr.ai.failed_build_commands.length) {
								var current_city_matrix = generateCityMatrix(user_id); //[province, score]
								var current_city_names = [];
								var found_cities_array = []; //Where should cities be founded and what should they be named? [province_id, city_name]
								
								//Fetch current_city_names for certitude
								for (var i = 0; i < usr.cities.city_array.length; i++) current_city_names.push(usr.cities[usr.cities.city_array[i]].name);
								
								//Preferred cities are always built first if they can be
								if (ai_obj.cities[config.map_type]) {
									var all_city_keys = Object.keys(ai_obj.cities[config.map_type]);
									for (var i = 0; i < all_city_keys.length; i++) {
										var local_city_value = ai_obj.cities[config.map_type][all_city_keys[i]];
										var preferred_province_owner = getProvince(local_city_value, "owner");
										
										//Push to found_cities_array
										if (preferred_province_owner == usr.id && !current_city_names.includes(all_city_keys[i])) found_cities_array.push([local_city_value, all_city_keys[i]]);
									}
								}
								
								//No calculations are required if city matrix has nothing in it
								if (current_city_matrix.length > 0) {
									if (found_cities_array.length == 0) {
										//Shuffle city matrix, Fisher-Yates
										current_city_matrix = shuffle(current_city_matrix);
										
										for (var i = 0; i < current_city_matrix.length; i++) { //[province, score]
											var current_roll = random(0, (((1/(current_city_matrix[i][1]+1))*-1)+1)/10);
											if (Math.random() <= current_roll) {
												//Get available city name
												var iteration_count = 0;
												var available_name = "";
												while (true) {
													if (iteration_count < 10) {
														var proposed_name = randomElement(ai_obj.cities.generic_names);
														if (!current_city_names.includes(proposed_name)) {
															//Make sure province is colonised, and does not belong to owner if the proposed city is a manually preferred one
															var preferred_city_free = true;
															if (ai_obj.cities[config.map_type][proposed_name]) {
																if (getProvince(ai_obj.cities[config.map_type][proposed_name], "owner")) {
																	if (getProvince(ai_obj.cities[config.map_type][proposed_name], "owner") != usr.id) {
																		preferred_city_free = false;
																	}
																}
															}
															
															//Set name as available and break loop
															if (!preferred_city_free) {
																available_name = proposed_name;
																break;
															}
														}
													} else {
														break;
													}
													iteration_count++;
												}
												
												if (available_name != "") {
													//Add to found_cities_array
													found_cities_array.push([current_city_matrix[i][0], available_name]);
												}
											}
										}
									}
								}
								
								//Found new cities until AI no longer wants to found cities (WIP)
								for (var i = 0; i < found_cities_array.length; i++) {
									//Should cities be founded?
									var ai_wants_new_city = false;
									
									//Is the AI short on workers?
									var available_workers = usr.workers-usr.used_workers;
									var higher_worker_requirement = Math.max(Math.ceil(usr.workers*config.low_worker_count[0]), config.low_worker_count[1]);
									var worker_deficit = (available_workers < higher_worker_requirement) ? higher_worker_requirement-available_workers : 0;
									
									ai_wants_new_city = (available_workers < higher_worker_requirement) ? true : ai_wants_new_city;
									
									//Can the AI build more housing if it is short on workers?
									if (available_workers < higher_worker_requirement) {
										//Check for housing and city building capacity here
										var can_build_housing = false; //The amount of housing it should build should at least be enough to override the current worker deficit
										var has_city_resources = false;
									}
									
									//Does the AI have no slots left when it comes to certain buildings?
									ai_wants_new_city = (usr.ai.ran_out_of_slots) ? true : ai_wants_new_city;
									
									//Make sure AI can't exceed their city_limit
									ai_wants_new_city = (usr.cities.city_array.length > usr.ai.city_limit) ? false : ai_wants_new_city;
									
									//Found a new city
									if (ai_wants_new_city) addCommand(ai_id, `city-new ${found_cities_array[i][0]} ${found_cities_array[i][1]}`);
								}
								
								//Clear city_processing at end
								clearInterval(city_processing);
							}
						}, 100);
					}
					
					//Colonisation AI
					{
						var colonisation_processing = setInterval(function(){
							if (usr.ai.colonists_crafted >= usr.ai.colonist_crafting_length) {
								var current_colonisation_capacity = [];
								var current_colonisation_priority = generateColonisationMatrix(user_id);
								
								//Make sure that AI hasn't expanded past their maximum expansion willingness
								if (current_colonisation_priority.length > 0 && usr.provinces < Math.ceil(usr.ai.province_limit)) {
									//Sort current_colonisation_capacity
									current_colonisation_priority.sort((a, b) => b[0]-a[0]);
									
									//Initialise colonisation_capacity array
									for (var i = 0; i < config.colonists.length; i++) {
										if (usr.military[config.colonists[i]] > 0) {
											if (config.unit_stats[config.colonists[i]].colonise_provinces) {
												for (var x = 0; x < config.colonists.length; x++) {
													current_colonisation_capacity.push(config.unit_stats[config.colonists[i]].colonise_provinces);
												}
											}
										}
									}
									
									//Imperial AI Trigger
									{
										if (usr.imperialist) {
											var has_no_high_priority_provs = true;
											for (var i = 0; i < current_colonisation_priority.length; i++) {
												if (current_colonisation_priority[i][1] > config.start_imperialism_at) has_no_high_priority_provs = false;
											}
											
											var average_tech_count = getAverageTechnologyLevel();
											
											//Activate imperial_ai if all conditions are met
											if (has_no_high_priority_provs && usr.researched_technologies.length > average_tech_count) usr.ai.imperial_ai = true;
										}
									}
									
									//Colonial AI
									{
										//Sort colonisation_capacity array
										current_colonisation_capacity.sort((a, b) => b-a);
										
										//Send out colonists if expedition capacity is spare
										var spare_expedition_slots = usr.modifiers.maximum_expeditions-usr.expeditions.length;
										
										for (var i = 0; i < current_colonisation_capacity.length; i++) {
											//Begin processing and sending expedition out
											var current_colonisation_provs = [];
											var elements_for_removal = []; //Removes indices from current_colonisation_priority
											
											if (current_colonisation_priority.length > 0 && spare_expedition_slots > 0) {
												for (var x = 0; x < current_colonisation_capacity[i]; x++) {
													//Begin taking provinces from current_colonisation_priority
													//[province_id, colonisation_score]
													
													if (current_colonisation_priority[x]) {
														elements_for_removal.push(current_colonisation_priority[x]);
														
														//Only append if province does not return a valid owner, and colonisation by another country is not active (this can be changed in config.js)
														if (!getProvince(current_colonisation_priority[x][0]) && (!isProvinceBeingColonised(current_colonisation_priority[x][0]) && !config.attempt_colonisation_even_if_active)) {
															current_colonisation_provs.push(current_colonisation_priority[x][0]);
														}
													}
												}
												
												//Remove elements_for_removal from current_colonisation_priority
												for (var x = 0; x < elements_for_removal.length; x++) {
													for (var y = 0; y < current_colonisation_priority.length; y++) {
														if (elements_for_removal[x] == current_colonisation_priority[y]) current_colonisation_priority.splice(y, 1);
													}
												}
												
												//Send out a new expedition!
												spare_expedition_slots--;
												if (current_colonisation_provs.length > 0) addCommand(ai_id, `settle ${current_colonisation_provs.join(" ")}`);
											}
										}
									}
								}
								
								//Clear colonisation_processing once done
								clearInterval(colonisation_processing);
							}
						}, 100);
					}
				
					//Technology AI
					{
						var available_slots = usr.modifiers.research_slots-usr.researching.length;
						
						for (var i = 0; i < available_slots; i++) {
							var technology_matrix = generateTechnologyMatrix(user_id);
							//Try/catch statement just in case
							try {
								if (available_slots > 0 && technology_matrix.length > 0) addCommand(ai_id, `research ${technology_matrix[0][0]}`);
							} catch {}
						}
					}
				} catch (e) {
					console.log(e);
				}
			}
		}
		
		function nextTurn (arg0_user, arg1_simulation) { //nextTurn(object, true) for simulation
			let user = client.users.cache.find(user => user.id.toString() == arg0_user);
			var is_simulation;
			var user_id;
			var age;
			var inventory;
			var cities;
			
			if (arg1_simulation != undefined) {
				is_simulation = true;
			} else {
				is_simulation = false;
			}
			
			if (is_simulation == false) {
				user_id = main.users[arg0_user];
				age = main.users[arg0_user].technology_level-1;
				inventory = main.users[arg0_user].inventory;
				cities = main.users[arg0_user].cities;
			} else {
				user_id = arg0_user;
				age = arg0_user.technology_level-1;
				inventory = arg0_user.inventory;
				cities = arg0_user.cities;
			}
			
			var usr = user_id;
			var current_pop = user_id.population;
			var temp_obj = {};
			
			//News variables:
			
			var national_news = "";
			var famine_loss = Math.ceil(user_id.population*0.1);
			
			logicCheck(user_id.id);
			
			//AI
			if (!is_simulation && user_id.type == "ai") {
				if (!user_id.ai.ai_disabled) nextTurnAI(user_id.id);
			}
			
			//Apply starting modifiers
			{
				//Cooldowns and other modifiers
				user_id.country_age++;
				user_id.total_cities = user_id.total_cities + user_id.city_count;
				user_id.total_ceded_this_turn = 0;
				
				//Subtract all first (although this is inversed)
				user_id.modifiers.rgo_throughput = user_id.modifiers.rgo_throughput + returnSafeNumber(user_id.infamy_rgo_throughput, 0);
				user_id.modifiers.production_efficiency = user_id.modifiers.production_efficiency + returnSafeNumber(user_id.infamy_production_efficiency, 0);
				
				//Calculate ...
				if (user_id.infamy > config.infamy_limit) { //Infamy limit
					user_id.infamy_rgo_throughput = user_id.infamy*0.02 //-2% per infamy
					user_id.infamy_production_efficiency = user_id.infamy*0.03 //-3% per infamy
					
					if (user_id.modifiers.rgo_throughput < 0) {
						user_id.modifiers.rgo_throughput = 0;
					}
					if (user_id.modifiers.production_efficiency < 0) {
						user_id.modifiers.production_efficiency = 0;
					}
				} else {
					user_id.infamy_rgo_throughput = 0;
					user_id.infamy_production_efficiency = 0;
				}
				
				for (var i = 0; i < user_id.cities.city_array.length; i++) user_id.cities[user_id.cities.city_array[i]].attacked_this_turn = false;
				
				//Then add (also inversed, so subtract)
				user_id.modifiers.rgo_throughput = user_id.modifiers.rgo_throughput - returnSafeNumber(user_id.infamy_rgo_throughput, 0);
				user_id.modifiers.production_efficiency = user_id.modifiers.production_efficiency - returnSafeNumber(user_id.infamy_production_efficiency, 0);
				
				if (user_id.country_age > 10) {
					user_id.maximum_transaction_amount = config.resource_max_percentile;
				}
				
				//Cities
				var avg_cities = Math.ceil(usr.total_cities/usr.country_age);
				
				if (avg_cities == 0) {
					avg_cities = 1;
				}
				
				//National Modifiers
				var all_national_spirits = Object.keys(usr.national_spirits);
				
				//Remove previous national spirit
				for (var i = 0; i < all_national_spirits.length; i++) {
					for (var x = 0; x < usr.national_spirits[all_national_spirits[i]].effects.length; x++) {
						if (usr.national_spirits[all_national_spirits[i]].effects[x][0] == "stability" || usr.national_spirits[all_national_spirits[i]].effects[x][0] == "max_tax" || usr.national_spirits[all_national_spirits[i]].effects[x][0] == "manpower_percentage" || usr.national_spirits[all_national_spirits[i]].effects[x][0] == "pop_growth_modifier") {
							usr[usr.national_spirits[all_national_spirits[i]].effects[x][0]] = usr[usr.national_spirits[all_national_spirits[i]].effects[x][0]] - usr.national_spirits[all_national_spirits[i]].effects[x][1];
						} else {
							usr.modifiers[usr.national_spirits[all_national_spirits[i]].effects[x][0]] = usr.modifiers[usr.national_spirits[all_national_spirits[i]].effects[x][0]] - usr.national_spirits[all_national_spirits[i]].effects[x][1];
						}
					}
				}
				
				//Add the national spirit to the country
				for (var i = 0; i < all_national_spirits.length; i++) {
					for (var x = 0; x < usr.national_spirits[all_national_spirits[i]].effects.length; x++) {
						if (usr.national_spirits[all_national_spirits[i]].effects[x][0] == "stability" || usr.national_spirits[all_national_spirits[i]].effects[x][0] == "max_tax" || usr.national_spirits[all_national_spirits[i]].effects[x][0] == "manpower_percentage" || usr.national_spirits[all_national_spirits[i]].effects[x][0] == "pop_growth_modifier") {
							usr[usr.national_spirits[all_national_spirits[i]].effects[x][0]] = usr[usr.national_spirits[all_national_spirits[i]].effects[x][0]] + usr.national_spirits[all_national_spirits[i]].effects[x][1];
						} else {
							usr.modifiers[usr.national_spirits[all_national_spirits[i]].effects[x][0]] = usr.modifiers[usr.national_spirits[all_national_spirits[i]].effects[x][0]] + usr.national_spirits[all_national_spirits[i]].effects[x][1];
						}
					}
				}
				
				//Apply research imbalance debuffs
				var total_research = 0;
				var largest_imbalance = 0;
				var all_techs = Object.keys(config.technology);
				for (var i = 0; i < config.tech_categories.length; i++) {
					var total_in_category = 0;
					for (var x = 0; x < all_techs.length; x++) {
						if (config.technology[all_techs[x]].category == config.tech_categories[i]) {
							total_in_category++;
						}
					}
					total_research = total_research + (user_id[config.tech_categories[i] + "_researched"]/total_in_category);
					if ((user_id[config.tech_categories[i] + "_researched"]/total_in_category) > largest_imbalance) {
						largest_imbalance = (user_id[config.tech_categories[i] + "_researched"]/total_in_category);
					}
				}
				
				var avg_research = total_research/config.tech_categories.length;
				
				/*Linear scale - 
					Slight Research Imbalance (15-20 techs)
					Moderate Research Imbalance (20-30 techs)
					Major Research Imbalance (30-40 techs)
					Extreme Research Imbalance (40-50 techs)
					Overwhelming Research Imbalance (50+ techs)
				*/
				var research_imbalance = (largest_imbalance-avg_research)*100;
				
				console.log("Research Imbalance: " + research_imbalance);
				console.log("Largest Imbalance: " + largest_imbalance);
				console.log("Avg. Research: " + avg_research);
				
				if (research_imbalance >= 15 && research_imbalance < 20) {
					removeNationalSpirit(user_id.id, "research_imbalance");
					setNationalSpirit(user_id.id, "research_imbalance", [
						["name", "Slight Research Imbalance"],
						["img", "https://media.discordapp.net/attachments/744414944019087451/800592602129760256/research_imbalance_not_good.png"],
						["icon", "<:technology_imbalance:800889184880951296>"],
						["description", "As higher priorities for certain sectors of technology have been set by the national government, scientists in other fields have begun to notice slight decreases in their funding, slowing down the rate of overall research.\n\n• **-10%** Research Efficiency"],
						["research_efficiency", -0.10]
					]);
				} else if (research_imbalance >= 20 && research_imbalance < 30) {
					removeNationalSpirit(user_id.id, "research_imbalance");
					setNationalSpirit(user_id.id, "research_imbalance", [
						["name", "Moderate Research Imbalance"],
						["img", "https://media.discordapp.net/attachments/744414944019087451/800592627963658280/research_imbalance_bad.png"],
						["icon", "<:technology_imbalance:800889184880951296>"],
						["description", "Government priorities and meddling in research are seriously beginning to affect mmany major research departments as complaints about lack of funding become increasingly common, and the financial and military sectors are starting to take notice.\n\n• **-15%** Research Efficiency\n• **-10%** Production Efficiency\n• **-5%** National Manpower\n• **-5%** Tax Efficiency"],
						["research_efficiency", -0.15],
						["production_efficiency", -0.10],
						["national_manpower", -0.05],
						["tax_efficiency", -0.05]
					]);
				} else if (research_imbalance >= 30 && research_imbalance < 40) {
					removeNationalSpirit(user_id.id, "research_imbalance");
					setNationalSpirit(user_id.id, "research_imbalance", [
						["name", "Major Research Imbalance"],
						["img", "https://media.discordapp.net/attachments/744414944019087451/800592647823556608/research_imbalance_terrible.png"],
						["icon", "<:technology_imbalance:800889184880951296>"],
						["description", "The hyperfocusing of specific scientific fields is beginning to damage our national industrial and scientific capacities, and our enforcement of the law and economic productivity is severely limited by our narrow research scope.\n\n• **-20%** Production Efficiency\n• **-15%** Tax Efficiency\n• **-10%** National Manpower\n• **-5%** RGO Throughput\n• **-1** Extra Building Slot"],
						["research_efficiency", -0.20],
						["production_efficiency", -0.20],
						["tax_efficiency", -0.15],
						["national_manpower", -0.10],
						["rgo_throughput", -0.05],
						["extra_building_slots", -1]
					]);
				} else if (research_imbalance >= 40 && research_imbalance < 50) {
					removeNationalSpirit(user_id.id, "research_imbalance");
					setNationalSpirit(user_id.id, "research_imbalance", [
						["name", "Extreme Research Imbalance"],
						["img", "https://media.discordapp.net/attachments/744414944019087451/800592673068154891/research_imbalance_horrible.png"],
						["icon", "<:technology_imbalance:800889184880951296>"],
						["description", "Our nation is experiencing a severe brain drain, and our society is on the cusp of total economic collapse due to our research priorities. If this continues, we might find ourselves completely isolated from the global scientific community.\n\n• **-25%** Research Efficiency\n• **-30%** Production Efficiency\n• **-25%** Tax Efficiency\n• **-20%** National Manpower\n• **-15%** RGO Throughput\n• **-2** Extra Building Slots"],
						["research_efficiency", -0.25],
						["production_efficiency", -0.30],
						["tax_efficiency", -0.25],
						["national_manpower", -0.20],
						["rgo_throughput", -0.15],
						["extra_building_slots", -2]
					]);
				} else if (research_imbalance >= 50) {
					removeNationalSpirit(user_id.id, "research_imbalance");
					setNationalSpirit(user_id.id, "research_imbalance", [
						["name", "Overwhelming Research Imbalance"],
						["img", "https://media.discordapp.net/attachments/744414944019087451/800592697462882334/research_imbalance_abysmal.png"],
						["icon", "<:technology_imbalance:800889184880951296>"],
						["description", "The current research imbalance has overwhelmed nearly every aspect of our society, and we must turn it around as soon as possible if we are to avoid permanent damage. Scientists are fleeing our nation in droves, and many aspects of modern science are going neglected.\n\n• **-50%** Research Efficiency\n• **-50%** National Manpower\n• **-35%** Production Efficiency\n• **-25%** Tax Efficiency\n• **-25%** RGO Throughput\n• **-10%** Pop. Growth Modifier\n• **-3** Extra Building Slots"],
						["research_efficiency", -0.50],
						["national_manpower", -0.50],
						["production_efficiency", -0.35],
						["tax_efficiency", -0.25],
						["rgo_throughput", -0.25],
						["pop_growth_modifier", -0.1],
						["extra_building_slots", -3]
					]);
				} else {
					removeNationalSpirit(user_id.id, "research_imbalance");
				}
				
				//Trim stats
				usr.recent_military_casualties.push(0);
				usr.recent_civilian_casualties.push(0);
				if (usr.recent_military_casualties.length > 10) usr.recent_military_casualties.shift();
				if (usr.recent_civilian_casualties.length > 10) usr.recent_civilian_casualties.shift();
				
				//Delete countries that are older than eight turns, have zero provinces, and are at peace
				if (usr.country_age > 8 && usr.provinces == 0 && usr.at_war.length == 0) {
					national_news += `${usr.name} ceased to exist as a country.`;
					setTimeout(function(){ 
						deleteCountry(usr, "none");
					}, 1000);
				}
			}
			
			//Building production & construction
			{
				user_id.actions = user_id.actions + config.starting_actions; //Base actions
				
				//All buildings
				
				/*Crafting Points (CP):
				 ground_units_cp
				 ground_artillery_cp
				 ground_vehicles_cp
				 aeroplanes_cp
				 naval_units_cp
				 colonists_cp
				*/
				
				user_id.ground_units_cp = 0;
				user_id.ground_artillery_cp = 0;
				user_id.ground_vehicles_cp = 0;
				user_id.aeroplanes_cp = 0;
				user_id.naval_units_cp = 0;
				user_id.colonists_cp = 0;
				
				user_id.inventory.knowledge = 0;
				
				//Get production
				var total_production_stats = getProduction(user_id.id, "all", false); //REFER TO PRODUCTION METHOD WHEN EDITING
				
				if (total_production_stats) {
					var all_production_keys = Object.keys(total_production_stats);
					
					//Consider refactoring this code block in the future?
					for (var i = 0; i < all_production_keys.length; i++) {
						try {
							//Alias local_good_production and add to user inventory
							var local_good_production = total_production_stats[all_production_keys[i]];
							
							if (config.materials.includes(all_production_keys[i])) {
								user_id.inventory[all_production_keys[i]] += ceilRandomNumber(local_good_production[0], local_good_production[1]);
							} else {
								if (all_production_keys[i].indexOf("_special_effect") == -1 && all_production_keys[i].indexOf("_upkeep") == -1) {
									user_id[all_production_keys[i]] += ceilRandomNumber(local_good_production[0], local_good_production[1]);
								} else if (all_production_keys[i].indexOf("_upkeep") != -1) {
									if (config.materials.includes(all_production_keys[i].replace("_upkeep", ""))) {
										user_id.inventory[all_production_keys[i].replace("_upkeep", "")] -= randomNumber(local_good_production[0], local_good_production[1]);
									} else {
										user_id[all_production_keys[i]] -= randomNumber(local_good_production[0], local_good_production[1]);
									}
								} else if (all_production_keys[i].indexOf("_special_effect") != -1) {
									//Execute _special_effect functions if detected
									var local_building_name = all_production_keys[i].replace("_special_effect", "");
									for (var x = 0; x < local_good_production; x++) {
										if (config.building_stats[local_building_name].special_effect) config.building_stats[local_building_name].special_effect(user_id);
									}
								}
							}
						} catch (e) {
							console.log(e);
						}
					}
					
					//Reset goods to zero if detected as negative
					for (var i = 0; i < config.materials.length; i++) user_id.inventory[config.materials[i]] = (user_id.inventory[config.materials[i]] < 0) ? 0 : user_id.inventory[config.materials[i]];
				}
				
				//Building Construction
				for (var i = 0; i < user_id.under_construction.length; i++) {
					//Make sure that all under construction requests belong to cities held by the user. If not, remove them.
					var user_holds_city = false;
					for (var x = 0; x < cities.city_array.length; x++) {
						if (cities.city_array[x] == user_id.under_construction[i][2]) {
							user_holds_city = true;
						}
					}
					
					if (user_holds_city == false) { //This works, I think?
						user_id.under_construction.splice(i, 1);
					}
				}
				
				//Build the buildings!
				for (var i = 0; i < user_id.under_construction.length; i++) {
					user_id.under_construction[i][0] = parseInt(user_id.under_construction[i][0]);
				}
				for (var i = 0; i < user_id.under_construction.length; i++) {
					user_id.under_construction[i][3]--;
				}
				for (var i = 0; i < user_id.under_construction.length; i++) {
					var local_city = user_id.cities[user_id.under_construction[i][2]];
					console.log("Going through " + user_id.under_construction[i].join(", "));
					try {
						if (user_id.under_construction[i][3] <= 0) {
							local_city.buildings[user_id.under_construction[i][1]] = local_city.buildings[user_id.under_construction[i][1]] + user_id.under_construction[i][0];
							
							for (var x = 0; x < user_id.under_construction[i][0]; x++) {
								if (config.building_stats[user_id.under_construction[i][1]].immediate_effect != undefined) {
									config.building_stats[user_id.under_construction[i][1]].immediate_effect(user_id);
								}
								if (config.building_stats[user_id.under_construction[i][1]].houses != undefined) {
									local_city.housing = local_city.housing + config.building_stats[user_id.under_construction[i][1]].houses;
								}
								if (config.building_stats[user_id.under_construction[i][1]].supply_limit != undefined) {
									console.log(getAllProvincesInRange(local_city.province, config.infrastructure_range));
									var all_valid_provinces = getAllProvincesInRange(local_city.province, config.infrastructure_range);
									
									for (var y = 0; y < all_valid_provinces.length; y++) {
										var province_id = all_valid_provinces[y];
										if (getProvince(province_id, "owner") == arg0_user) {
											if (getProvince(province_id).supply_limit != undefined) {
												getProvince(province_id).supply_limit += config.building_stats[user_id.under_construction[i][1]].supply_limit;
											} else {
												getProvince(province_id).supply_limit = config.building_stats[user_id.under_construction[i][1]].supply_limit;
											}
										}
									}
								}
							}
						}
					} catch {}
				}
				console.log("CURRENT LOOP: ");
				console.log(user_id.under_construction);
				while (true) {
					var found_exception = false;
					for (var i = 0; i < user_id.under_construction.length; i++) {
						if (user_id.under_construction[i][3] <= 0) {
							found_exception = true;
							user_id.under_construction.splice(i, 1);
						}
					}
					
					if (!found_exception) {
						break;
					}
				}
				
				//Knowledge
				user_id.inventory.knowledge = user_id.inventory.knowledge*user_id.modifiers.research_efficiency;
				var pop_knowledge_gain = 0;
				for (var i = 0; i < config.pop_array.length; i++) {
					if (config.pops[config.pop_array[i]].knowledge_per_100k != undefined) {
						pop_knowledge_gain = pop_knowledge_gain + Math.ceil((user_id[config.pop_array[i]]/100000)*config.pops[config.pop_array[i]].knowledge_per_100k);
					}
				}
				
				if (pop_knowledge_gain > 500) {
					pop_knowledge_gain = 500;
				}
				user_id.inventory.knowledge = user_id.inventory.knowledge + pop_knowledge_gain;
				user_id.knowledge_per_turn = user_id.inventory.knowledge;
				console.log("Knowledge per turn: " + user_id.knowledge_per_turn);
			}
			
			//Army movement and Combat
			{
				if (!is_simulation) {
					if (user_id.mobilised_manpower[2] > 0) {
						user_id.mobilised_manpower[2]--;
						user_id.military[user_id.mobilised_manpower[1]] = user_id.military[user_id.mobilised_manpower[1]] + Math.ceil(user_id.mobilised_manpower[0]/user_id.mobilised_manpower[4]);
						user_id.mobilised_manpower[3] = user_id.mobilised_manpower[3] + Math.ceil(user_id.mobilised_manpower[0]/user_id.mobilised_manpower[4]);
					}
					if (user_id.mobilised_manpower[1] != "" && user_id.mobilised_manpower[2] == 0) {
						returnChannels.send(war_channel, "**" + user_id.name + "** has fully mobilised, and is now able to field a strong army.");
					}
					user_id.mobilised_manpower[0] = Math.ceil(user_id.mobilised_manpower[0]);
					user_id.mobilised_manpower[3] = Math.ceil(user_id.mobilised_manpower[3]);
					
					var combat_provinces = [];
					for (var i = 0; i < user_id.armies.army_array.length; i++) {
						var army_size = 0;
						
						for (var x = 0; x < config.units.length; x++) {
							army_size = army_size + (config.unit_stats[config.units[x]].manpower_cost*user_id.armies[user_id.armies.army_array[i]][config.units[x]]);
						}
						
						user_id.armies[user_id.armies.army_array[i]].army_size = army_size;
						user_id.armies[user_id.armies.army_array[i]].submarine_cooldown = false;
						user_id.armies[user_id.armies.army_array[i]].challenged_this_turn = 0;
						
						console.log(user_id.armies[user_id.armies.army_array[i]].name + ".province: " + user_id.armies[user_id.armies.army_array[i]].province);
						console.log(user_id.armies[user_id.armies.army_array[i]].name + ".moving_to: " + user_id.armies[user_id.armies.army_array[i]].moving_to);
						
						try {
							if (user_id.armies[user_id.armies.army_array[i]].moving_to.length > 0) {
								console.log("Army " + user_id.armies[user_id.armies.army_array[i]].name + " is moving!");
								var new_province = 0;
								var current_speed = Math.ceil(config.army_speed*user_id.modifiers.army_travel_speed);
								var current_element = 0;
								for (var x = 0; x < user_id.armies[user_id.armies.army_array[i]].moving_to.length; x++) {
									if (user_id.armies[user_id.armies.army_array[i]].moving_to[x] == user_id.armies[user_id.armies.army_array[i]].province) {
										current_element = x;
									}
								}
								
								for (var x = 0; x < current_speed; x++) {
									if (user_id.armies[user_id.armies.army_array[i]].moving_to[x+current_element] != undefined) {
										user_id.armies[user_id.armies.army_array[i]].province = user_id.armies[user_id.armies.army_array[i]].moving_to[x+current_element];
										console.log("Moving to Province #" + user_id.armies[user_id.armies.army_array[i]].province);
									}
									
									//Add combat check here to test if the army has collided into the armies of any hostile users
									var collision_results_in_battle = randomNumber(0, 100);
									if (user_id.at_war.length > 0) {
										for (var y = 0; y < user_id.at_war.length; y++) {
											for (var z = 0; z < main.user_array.length; z++) {
												if (main.users[main.user_array[z]].name == user_id.at_war[y]) {
													for (var a = 0; a < main.users[main.user_array[z]].armies.army_array.length; a++) {
														var army_obj = main.users[main.user_array[z]].armies[main.users[main.user_array[z]].armies.army_array[a]];
														if (army_obj.province == user_id.armies[user_id.armies.army_array[i]].province) {
															if (army_obj.name != "deleted-army" && user_id.armies[user_id.armies.army_array[i]].name != "deleted-army") {
																var in_combat = false;
																for (var b = 0; b < combat_provinces.length; b++) {
																	if (combat_provinces[b] == army_obj.province) {
																		in_combat = true;
																	}
																}
																if (army_obj.type != "navy" && user_id.armies[user_id.armies.army_array[i]].type != "navy") {
																	if (in_combat == false) {
																		if (collision_results_in_battle > 50) {
																			combat(main.user_array[z], army_obj.name, user_id.id, user_id.armies[user_id.armies.army_array[i]].name, army_obj.province, "none");
																			combat_provinces.push(army_obj.province);
																		}
																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
								
								if (user_id.armies[user_id.armies.army_array[i]].moving_to[user_id.armies[user_id.armies.army_array[i]].moving_to.length-1] == user_id.armies[user_id.armies.army_array[i]].province) {
									user_id.armies[user_id.armies.army_array[i]].moving_to = [];
								}
								
								if (user_id.armies[user_id.armies.army_array[i]].moving_to.length == 0) {
									user_id.armies[user_id.armies.army_array[i]].state = "stationed";
								}
							} else {
								if (user_id.armies[user_id.armies.army_array[i]].type != "navy") {
									user_id.armies[user_id.armies.army_array[i]].state = "stationed";
									user_id.armies[user_id.armies.army_array[i]].stationary_turns++;
								} else {
									user_id.armies[user_id.armies.army_array[i]].state = "in harbour";
									user_id.armies[user_id.armies.army_array[i]].stationary_turns++;
								}
							}
						} catch {}
					}
						
					for (var i = 0; i < user_id.armies.army_array.length; i++) {
						var local_army = user_id.armies[user_id.armies.army_array[i]];
						
						//Takes attrition depending on province supply limit
						var total_in_province = 0;
						var province_supply_limit = 0;
						
						var is_hostile = false;
						var has_access = false;
						var is_friendly = false;
						
						for (var x = 0; x < user_id.accepted_cultures.length; x++) {
							if (getProvince(user_id.armies[user_id.armies.army_array[i]].province) != undefined) {
								if (getProvince(user_id.armies[user_id.armies.army_array[i]].province).culture == user_id.accepted_cultures[x]) {
									is_friendly = true;
								}
							}
						}
						for (var x = 0; x < user_id.military_access.length; x++) {
							if (getProvince(user_id.armies[user_id.armies.army_array[i]].province) != undefined) {
								if (getProvince(user_id.armies[user_id.armies.army_array[i]].province, "owner") == user_id.military_access[x]) {
									has_access = true;
								}
							}
						}
						if (has_access == false && is_friendly == false) {
							is_hostile = true;
						}
							
						//Fetch supply limit
						if (getProvince(user_id.armies[user_id.armies.army_array[i]].province) != undefined) {
							if (getProvince(user_id.armies[user_id.armies.army_array[i]].province).supply_limit != undefined) {
								province_supply_limit = getProvince(user_id.armies[user_id.armies.army_array[i]].province).supply_limit;
							} else {
								province_supply_limit = config.base_supply_limit;
							}
						} else {
							province_supply_limit = config.base_supply_limit;
						}
						
						if (is_friendly) {
							province_supply_limit = province_supply_limit*config.friendly_territory_modifier;
						}
						if (has_access) {
							province_supply_limit = province_supply_limit*config.access_territory_modifier;
						}
						if (is_hostile) {
							province_supply_limit = province_supply_limit*config.hostile_territory_modifier;
						}
						
						for (var x = 0; x < main.user_array.length; x++) {
							var local_user = main.users[main.user_array[x]];
							for (var y = 0; y < local_user.armies.army_array.length; y++) {
								if (local_user.armies[local_user.armies.army_array[y]].province == user_id.armies[user_id.armies.army_array[i]].province) {
									total_in_province = total_in_province + local_user.armies[local_user.armies.army_array[y]].army_size;
								}
							}
						}
						
						//Reset attrition status
						delete user_id.armies[user_id.armies.army_array[i]].taking_attrition;
						
						//Troops are kil if total in province exceeds province_supply_limit*1000
						if (total_in_province > (province_supply_limit*1000)) {
							if (!is_friendly || user_id.at_war.length > 0) {
								if (user_id.armies[user_id.armies.army_array[i]].type != "navy") {
									if (user_id.capital_id.toString() != user_id.armies[user_id.armies.army_array[i]].province.toString()) {
										for (var x = 0; x < config.units.length; x++) {
											if (user_id.armies[user_id.armies.army_array[i]][config.units[x]] > 0) {
												var lost_units = user_id.armies[user_id.armies.army_array[i]][config.units[x]]-Math.ceil(user_id.armies[user_id.armies.army_array[i]][config.units[x]]*config.base_attrition_rate*user_id.modifiers.attrition_rate);
												user_id.armies[user_id.armies.army_array[i]][config.units[x]] = Math.ceil(user_id.armies[user_id.armies.army_array[i]][config.units[x]]*config.base_attrition_rate*user_id.modifiers.attrition_rate);
												user_id.used_soldiers = user_id.used_soldiers - (lost_units*config.unit_stats[config.units[x]].manpower_cost);
												removePops(user_id.id, (lost_units*config.unit_stats[config.units[x]].manpower_cost), "soldiers");
											}
										}
										user_id.armies[user_id.armies.army_array[i]].taking_attrition = true;
									}
								}
							}
						}
					
						//Check if the nation the army belongs to has military access through the province, if not, add the territorial violation CB to that user.
						var has_mil_access = false;
						var other_user = "";
						for (var x = 0; x < main.user_array.length; x++) {
							if (main.users[main.user_array[x]].pops[user_id.armies[user_id.armies.army_array[i]].province] != undefined) {
								console.log("[Triumph & Tragedy]: Has army in province: " + user_id.armies[user_id.armies.army_array[i]].province.toString());
								
								for (var y = 0; y < user_id.military_access.length; y++) {
									if (user_id.military_access[y] == main.user_array[x]) {
										has_mil_access = true;
									}
								}
								if (main.user_array[x] == user_id.id) {
									has_mil_access = true;
								} else {
									console.log("[Triumph & Tragedy]: Province belongs to another user. Military access: " + has_mil_access);
								}
								//Alliances
								for (var y = 0; y < user_id.allies.length; y++) {
									if (user_id.allies[y][1] == "accepted") {
										if (user_id.allies[y][0] == main.user_array[x]) {
											has_mil_access = true;
										}
									}
								}
								//Vassals
								for (var y = 0; y < user_id.vassals.length; y++) {
									if (user_id.vassals[y] == main.user_array[x]) {
										has_mil_access = true;
									}
								}
								//At War
								for (var y = 0; y < user_id.at_war.length; y++) {
									if (main.users[main.user_array[x]].name == user_id.at_war[y]) {
										has_mil_access = true;
									}
								}
								if (has_mil_access == false) {
									other_user = main.users[main.user_array[x]];
								}
							}
						}
						//Check if province is uncolonised
						if (other_user == "") {
							has_mil_access = true;
						}
						
						console.log("[Triumph & Tragedy]: Has military access: " + has_mil_access);
						
						if (has_mil_access == false) {
							var has_violation_cb = false;
							for (var x = 0; x < other_user.wargoals.length; x++) {
								if (other_user.wargoals[x] == ["territorial_violation", user_id.id]) {
									has_violation_cb = true;
								}
							}
							if (!has_violation_cb) {
								if (!temp_obj[other_user.id + "_has_territorial_violation_cb"]) {
									other_user.wargoals.push(["territorial_violation", user_id.id]);
									user_id.infamy = user_id.infamy + 1;
									returnChannels.send(war_channel, "**" + other_user.name + "** has gained the **Territorial Violation** Wargoal on **" + user_id.name + "**!\nThis action has costed **" + user_id.name + "** <:infamy:716817688453709905> 1 infamy.\n- The **" + local_army.name + "** was charged with this perfidy in Province **" + local_army.province + "**.");
									temp_obj[other_user.id + "_has_territorial_violation_cb"] = true;
								}
							} else {
								returnChannels.send(war_channel, "The **" + local_army.name + "** of **" + user_id.name + "** was noted for violating the integral territory of **" + other_user.name + "**.");
							}
						}
						
						//Reduce cooldown timer if above 0
						if (user_id.armies[user_id.armies.army_array[i]].can_move[1] > 0) {
							user_id.armies[user_id.armies.army_array[i]].can_move[1]--;
						}
						if (user_id.armies[user_id.armies.army_array[i]].can_move[1] == 0) {
							user_id.armies[user_id.armies.army_array[i]].can_move[0] = true;
						}
						
						//Blockade cooldown timers
						if (user_id.armies[user_id.armies.army_array[i]].blockade_recovery_turns > 0) {
							user_id.armies[user_id.armies.army_array[i]].blockade_recovery_turns--;
						}
					}
					
					//Naval blockade cooldown
					for (var i = 0; i < main.user_array.length; i++) {
						if (user_id["blockade_cooldown_" + main.user_array[i]] != undefined) {
							if (user_id["blockade_cooldown_" + main.user_array[i]] > 0) {
								user_id["blockade_cooldown_" + main.user_array[i]]--;
							}
							if (user_id["blockade_cooldown_" + main.user_array[i]] == 0) {
								delete user_id["blockade_cooldown_" + main.user_array[i]];
							}
						}
					}
				}
			}
			
			//Colonisation
			{
				//["conquistadors", turn_amount, [province_ids]]
				if (is_simulation == false) {
					var expeditions_to_remove = [];
					for (var i = 0; i < user_id.expeditions.length; i++) {
						if (user_id.expeditions[i][1] == 1) {
							if (user_id.expeditions[i]) {
								for (var x = 0; x < user_id.expeditions[i][2].length; x++) {
									//Check to see if AI user has a province within zone_of_interest distance
									var interested_provs = getAllProvincesInRange(user_id.expeditions[i][2][x], config.zone_of_interest);
									
									for (var y = 0; y < interested_provs; y++) {
										//Check to see if province is defined
										if (getProvince(interested_provs[y])) {
											var local_province_owner = main.users[getProvince(interested_provs[y], "owner")];
											if (local_province_owner.type == "ai" && user_id.id != local_province_owner.id) local_province_owner.ai.recently_colonised_provinces.push([user_id.expeditions[i][2][x], user_id.id, 0]);
										}
									}
									
									//Generate pops and all that good stuff
									generatePops(user_id.id, user_id.expeditions[i][2][x], [15000, 150000], [20000, 50000]);
									user_id.provinces++;
									original_svg = processSVG([user_id.colour, user_id.expeditions[i][2][x]], original_svg);
								}
								national_news = national_news + "\nSettlers from " + user_id.name + " have finished colonising Province(s) " + user_id.expeditions[i][2].join(", ") + "!";
								user_id.expeditions.splice(i, 1);
							}
						} else {
							user_id.expeditions[i][1]--;
						}
					}
				}
			}
			
			//Diplomacy
			{
				if (is_simulation == false) {
					var is_being_justified_on = false;
					for (var i = 0; i < main.user_array.length; i++) {
						if (main.users[main.user_array[i]].justifications.length > 0) {
							for (var x = 0; x < main.users[main.user_array[i]].justifications.length; x++) {
								if (main.users[main.user_array[i]].justifications[x][1] == user_id.id) {
									is_being_justified_on = true;
								}
							}
						}
					}
					
					if (user_id.at_war.length == 0 && user_id.blockaded == false && user_id.mobilised_manpower[1] == "") {
						user_id.modifiers.war_exhaustion = user_id.modifiers.war_exhaustion - returnSafeNumber(config.war_exhaustion_tickdown_rate);
					}
					if (user_id.mobilised_manpower[0] > 0) {
						user_id.modifiers.war_exhaustion = user_id.modifiers.war_exhaustion + returnSafeNumber(config.war_exhaustion_mobilisation_rate);
						if (user_id.at_war.length == 0 && !is_being_justified_on) {
							user_id.infamy = user_id.infamy + config.peacetime_mobilisation_penalty;
						}
					}
					
					if (isNaN(user_id.modifiers.infamy_loss) || user_id.modifiers.infamy_loss > config.infamy_loss) {
						user_id.infamy_loss = -0.05;
					}
					if (user_id.infamy > 0) {
						user_id.infamy = user_id.infamy + user_id.modifiers.infamy_loss;
					}
					if (user_id.infamy < 0) {
						user_id.infamy = 0;
					}
					
					//CB cooldowns
					{
						var remove_cbs = [];
						if (user_id.casus_belli.length > 0) {
							for (var i = 0; i < user_id.casus_belli.length; i++) {
								if (user_id.casus_belli[i][2] == 1) {
									remove_cbs.push(user_id.casus_belli[i]);
								} else {
									user_id.casus_belli[i][2]--;
								}
							}
						}
						if (remove_cbs.length > 0) {
							for (var i = 0; i < remove_cbs.length; i++) {
								for (var x = 0; x < user_id.casus_belli.length; x++) {
									if (user_id.casus_belli[x] == remove_cbs[i]) {
										user_id.casus_belli.splice(x, 1);
									}
								}
							}
						}
					}
					
					//CB handouts
					{
						//containment
						if (user_id.infamy > config.infamy_limit) {
							if (is_simulation == false) {
								returnChannels.send(war_channel, "**" + user_id.name + "** has exceeded the infamy limit! Everyone may now justify a containment wargoal on this user.");
							}
							for (var i = 0; i < main.user_array.length; i++) {
								if (main.user_array[i] != user_id.id) {
									main.users[main.user_array[i]].casus_belli.push(["containment", user_id.id, 1]);
								}
							}
						}
						
						var attacker_ap = 0;
						for (var i = 0; i < user_id.armies.army_array.length; i++) {
							for (var x = 0; x < config.units.length; x++) {
								attacker_ap = attacker_ap + user_id.armies[user_id.armies.army_array[i]][config.units[x]]*config.unit_stats[config.units[x]].ap;
							}
						}
						
						//colonial_integration
						for (var i = 0; i < main.user_array.length; i++) {
							var ot_user = main.users[main.user_array[i]];
							var defender_ap = 0;
							
							for (var x = 0; x < ot_user.armies.army_array.length; x++) {
								for (var y = 0; y < config.units.length; y++) {
									defender_ap = defender_ap + ot_user.armies[ot_user.armies.army_array[x]][config.units[y]]*config.unit_stats[config.units[y]].ap;
								}
							}
						
							if (attacker_ap > defender_ap*4 && user_id.researched_technologies.length*0.75 > ot_user.researched_technologies.length) {
								if (main.user_array[i] != user_id.id) {
									user_id.casus_belli.push(["colonial_integration", main.user_array[i], 1]);
								}
							}
						}
						
						//free_oppressed_people
						if (user_id.government == "democracy" || user_id.government == "constitutional_monarchy") {
							for (var i = 0; i < main.user_array.length; i++) {
								if (main.users[main.user_array[i]].infamy > 3) {
									if (main.users[main.user_array[i]].government != "democracy" && main.users[main.user_array[i]].government != "constitutional_monarchy") {
										if (main.user_array[i] != user_id.id) {
											user_id.casus_belli.push(["free_oppressed_people", main.user_array[i], 1]);
										}
									}
								}
							}
						}
						
						//independence
						if (user_id.vassal_years > 5) {
							for (var i = 0; i < main.user_array.length; i++) {
								for (var x = 0; x < main.users[main.user_array[i]].vassals.length; x++) {
									if (main.users[main.user_array[i]].vassals[x] == user_id.id) {
										if (main.user_array[i] != user_id.id) {
											user_id.casus_belli.push(["independence", main.user_array[i], 1]);
										}
									}
								}
							}
						}
						
						//revanchism
						for (var i = 0; i < main.user_array.length; i++) {
							var all_provs = Object.keys(main.users[main.user_array[i]].pops);
							
							for (var x = 0; x < all_provs.length; x++) {
								if (main.user_array[i] != user_id.id) {
									try {
										if (main.users[main.user_array[i]].pops[all_provs[x]].culture == user_id.culture) {
											var already_has_cb = false;
											for (var y = 0; y < user_id.casus_belli.length; y++) {
												if (user_id.casus_belli[y][1] == main.user_array[i]) {
													already_has_cb = true;
												}
											}
											
											if (already_has_cb == false) {
												user_id.casus_belli.push(["revanchism", main.user_array[i], 1]);
											}
										}
									} catch {}
								}
							}
						}
						
						//lebensraum
						if (user_id.government == "absolute_monarchy" || user_id.government == "fascism" || user_id.government == "communism") {
							for (var i = 0; i < main.user_array.length; i++) {
								if (main.user_array[i] != user_id.id) {
									user_id.casus_belli.push(["lebensraum", main.user_array[i], 1]);
								}
							}
						}
						
						//acquire_state
						for (var i = 0; i < main.user_array.length; i++) {
							if (main.users[main.user_array[i]].capital_id.toString() != 0 && user_id.capital_id.toString() != 0) {
								var total_distance = moveTo(user_id.capital_id.toString(), main.users[main.user_array[i]].capital_id.toString());
								if (total_distance.length < 15) {
									var attacker_ap = 0;
									var defender_ap = 0;
									
									for (var x = 0; x < user_id.armies.army_array.length; x++) {
										for (var y = 0; y < config.units.length; y++) {
											attacker_ap = attacker_ap + user_id.armies[user_id.armies.army_array[x]][config.units[y]]*config.unit_stats[config.units[y]].ap;
										}
									}
									for (var x = 0; x < main.users[main.user_array[i]].armies.army_array.length; x++) {
										for (var y = 0; y < config.units.length; y++) {
											defender_ap = defender_ap + main.users[main.user_array[i]].armies[main.users[main.user_array[i]].armies.army_array[x]]*config.unit_stats[config.units[y]].ap;
										}
									}
									
									if (attacker_ap > defender_ap*2) {
										if (main.user_array[i] != user_id.id) {
											user_id.casus_belli.push(["acquire_state", main.user_array[i], 1]);
										}
									}
								}
							}
						}
					}
					
					//Improve/decrease relations
					//[[value, player_id, [improving/decreasing/none, turns]]
					
					if (user_id.relations.length > 0) {
						for (var i = 0; i < user_id.relations.length; i++) {
							if (user_id.relations[i][2][1] > 0) {
								user_id.relations[i][2][1]--;
							} else {
								user_id.relations[i][2][1] = 0;
							}
							
							if (user_id.relations[i][2][1] == 0) {
								user_id.relations[i][2][0] = "none";
							}
							
							//[[0,"453420991536824340",["improving",4]]]
							//Increase/decrease relations
							if (user_id.relations[i][2][0] == "improving") {
								if (user_id.relations[i][0]+10 <= 100) {
									user_id.relations[i][0] = user_id.relations[i][0] + 10;
								} else {
									user_id.relations[i][0] = 100;
									user_id.relations[i][2][0] = "none";
									user_id.relations[i][2][1] = 0;
								}
							} else if (user_id.relations[i][2][0] == "decreasing") {
								if (user_id.relations[i][0]-10 >= -100) {
									user_id.relations[i][0] = user_id.relations[i][0] - 10;
									user_id.casus_belli.push(["diplomatic_insult", main.user_array[i], 1]);
								} else {
									user_id.relations[i][0] = -100;
									user_id.relations[i][2][0] = "none";
									user_id.relations[i][2][1] = 0;
								}
							}
						}
					}
					
					//Non-Aggression Pact
					//[[user_id, turns_before_expiry]]
					if (user_id.non_aggression_pacts.length > 0) {
						for (var i = 0; i < user_id.non_aggression_pacts.length; i++) {
							if (user_id.non_aggression_pacts[i][1] > 0) {
								user_id.non_aggression_pacts[i][1]--;
							}
							if (user_id.non_aggression_pacts[i][1] == 0) {
								localisation.push(user_id.name);
								printEvent(user_id.non_aggression_pacts[i][0], "non_aggression_pact_expired");
								for (var x = 0; x < main.users[user_id.non_aggression_pacts[i][0]].non_aggression_pacts.length; x++) {
									if (main.users[user_id.non_aggression_pacts[i][0]].non_aggression_pacts[x][0] == arg0_user) {
										main.users[user_id.non_aggression_pacts[i][0]].non_aggression_pacts.splice(x, 1);
									}
								}
								
								user_id.non_aggression_pacts.splice(x, 1);
							}
						}
					}
					
					if (user_id.vassals.length > 0) {
						for (var i = 0; i < user_id.vassals.length; i++) {
							main.users[user_id.vassals[i]].vassal_years++;
						}
					}
					
					//Prestige
					user_id.prestige = user_id.prestige + user_id.modifiers.prestige_gain;
					
					if (user_id.prestige < 0) {
						user_id.prestige = 0;
					}
					
					//Wargoal justification
					if (user_id.justifications.length > 0) {
						var elements_for_removal = [];
						var removed_elements = 0;
						for (var i = 0; i < user_id.justifications.length; i++) {
							if (user_id.justifications[i][2] > 0) {
								user_id.justifications[i][2]--;
							}
							
							if (user_id.justifications[i][2] > 0) {
								if (is_simulation == false) {
									returnChannels.send(war_channel, "War justification from **" + user_id.name + "** on **" + main.users[user_id.justifications[i][1]].name + "** will complete in **" + parseNumber(user_id.justifications[i][2]) + "** turns.");
								}
							}
							
							if (user_id.justifications[i][2] <= 0) {
								if (is_simulation == false) {
									returnChannels.send(war_channel, "<@" + user_id.id + "> has finished justification on <@" + user_id.justifications[i][1] + ">! (CB: **" + config.casus_belli[user_id.justifications[i][0]].name + "**).");
								}
								//[CB, nation]
								user_id.wargoals.push([user_id.justifications[i][0], user_id.justifications[i][1]]);
								elements_for_removal.push(user_id.justifications[i]);
							}
						}
						for (var i = 0; i < elements_for_removal.length; i++) {
							for (var x = 0; x < user_id.justifications.length; x++) {
								if (user_id.justifications[x] == elements_for_removal[i]) {
									user_id.justifications.splice(x, 1);
								}
							}
						}
					}
					
					//War Exhaustion Ticker
					if (user_id.at_war.length > 0) {
						if (user_id.modifiers.war_exhaustion+user_id.modifiers.war_exhaustion_rate < 100 && user_id.modifiers.war_exhaustion+user_id.modifiers.war_exhaustion_rate > 0) {
							user_id.modifiers.war_exhaustion = user_id.modifiers.war_exhaustion + returnSafeNumber(user_id.modifiers.war_exhaustion_rate);
						} else if (user_id.modifiers.war_exhaustion+user_id.modifiers.war_exhaustion_rate >= 100) {
							user_id.modifiers.war_exhaustion = 100;
						} else {
							user_id.modifiers.war_exhaustion = 0;
						}
					}
				}
			}
			
			//Modifiers
			{
				var get_temporary_modifiers = user_id.temporary_modifiers;
				console.log("[Triumph & Tragedy]: Temporary Modifiers for " + user_id.name + ": " + get_temporary_modifiers);
				
				if (get_temporary_modifiers.length > 0) {
					for (var i = 0; i < get_temporary_modifiers.length; i++) {
						//[modifier_id, amount, turns_before_expiry, already_applied]
						var current_id = get_temporary_modifiers[i][0];
						var current_amount = get_temporary_modifiers[i][1];
						
						//Check if modifier expired
						if (get_temporary_modifiers[i][2] > 0) {
							user_id.temporary_modifiers[i][2]--;
						} else if (get_temporary_modifiers[i][2] == 0) {
							if (current_id != "stability" && current_id != "pop_growth_modifier") {
								user_id.modifiers[current_id] = user_id.modifiers[current_id] - get_temporary_modifiers[i][1];
							} else {
								user_id[current_id] = user_id[current_id] - parseInt(get_temporary_modifiers[i][1]);
							}
							user_id.temporary_modifiers.splice(i, 1);
						}
						
						if (get_temporary_modifiers[i] != undefined) {
							if (get_temporary_modifiers[i][3] != true) {
								if (current_id != "stability" && current_id != "pop_growth_modifier") {
									user_id.modifiers[current_id] = user_id.modifiers[current_id] + get_temporary_modifiers[i][1];
								} else {
									user_id[current_id] = user_id[current_id] + parseInt(get_temporary_modifiers[i][1]);
								}
								user_id.temporary_modifiers[i][3] = true;
							}
						}
					}
				}
				
				//War Exhaustion
				if (isNaN(user_id.modifiers.war_exhaustion)) {
					user_id.modifiers.war_exhaustion = 0;
				}
				
				if (user_id.blockaded) {
					console.log("Detected user as being blockaded! War exhaustion should be raised by " + config.war_exhaustion_blockade_rate + "%.");
					console.log("Current war exhastion: " + user_id.modifiers.war_exhaustion);
					if (user_id.blockaded_war_exhaustion+config.war_exhaustion_blockade_rate < config.war_exhaustion_blockade_limit) {
						user_id.modifiers.war_exhaustion, user_id.modifiers.war_exhaustion + returnSafeNumber(config.war_exhaustion_rate); //+5% per turn of being blockaded
						user_id.blockaded_war_exhaustion, user_id.blockaded_war_exhaustion + returnSafeNumber(config.war_exhaustion_rate);//Same deal
					}
					console.log("New war exhaustion: " + user_id.modifiers.war_exhaustion);
				} else { //Relieving the blockade resets the blockade warscore
					user_id.modifiers.war_exhaustion = user_id.modifiers.war_exhaustion - returnSafeNumber(user_id.blockaded_war_exhaustion);
					user_id.blockaded_war_exhaustion = 0;
				}
				
				var occupied_provinces = 0;
				var total_provinces = 0;
				
				for (var i = 0; i < main.users.global.occupations.length; i++) {
					if (main.users.global.occupations[i][2] == user_id.id && user_id.accepted_cultures.includes(getProvince(main.users.global.occupations[i][0]).culture)) {
						occupied_provinces++;
						total_provinces++;
					}
				}
				
				total_provinces = total_provinces + user_id.provinces;
				
				user_id.province_war_exhaustion = Math.round((occupied_provinces/total_provinces)*100);
				
				if (user_id.modifiers.war_exhaustion > 100) {
					user_id.modifiers.war_exhaustion = 100;
				}
			}
			
			//Population and Upkeep
			{
				//Tax
				var previous_money = user_id.money;
				var total_soldiers = usr.used_soldiers + usr.mobilised_manpower[0];
				user_id.money = user_id.money + Math.ceil((user_id.actions*config.money_per_action)*user_id.tax_rate*user_id.modifiers.tax_efficiency);
				
				user_id.money = user_id.money - Math.ceil(returnSafeNumber(total_soldiers)/100*(user_id.modifiers.army_upkeep));
				console.log(user_id.name + " paid £" + Math.ceil(returnSafeNumber(total_soldiers)/100*(user_id.modifiers.army_upkeep)));
				user_id.last_turn_income = user_id.money - previous_money;
				
				//Subtract previous bonuses
				var total_tax_efficiency = 0;
				var total_stability = 0;
				var total_research_efficiency = 0;
				
				for (var i = 0; i < config.pop_array.length; i++) {
					if (config.pops[config.pop_array[i]].tax_efficiency_per_100k != undefined) {
						total_tax_efficiency = total_tax_efficiency + (user_id[config.pop_array[i]]/100000)*config.pops[config.pop_array[i]].tax_efficiency_per_100k;
					}
					if (config.pops[config.pop_array[i]].stability_per_100k != undefined) {
						total_stability = total_stability + (user_id[config.pop_array[i]]/100000)*config.pops[config.pop_array[i]].stability_per_100k;
					}
					if (config.pops[config.pop_array[i]].research_efficiency_per_100k != undefined) {
						total_research_efficiency = total_research_efficiency + (user_id[config.pop_array[i]]/100000)*config.pops[config.pop_array[i]].research_efficiency_per_100k;
					}
				}
				
				if (total_tax_efficiency > 60) {
					total_tax_efficiency = 60;
				}
				if (total_stability > 50) {
					total_stability = 50;
				}
				if (total_research_efficiency > 50) {
					total_research_efficiency = 50;
				}
				
				user_id.modifiers.tax_efficiency = user_id.modifiers.tax_efficiency - total_tax_efficiency;
				user_id.stability = user_id.stability - total_stability;
				user_id.modifiers.research_efficiency = user_id.modifiers.research_efficiency - total_research_efficiency;
				
				//Food
				if (user_id.population > user_id.inventory.food*config.population_food_requirement) {
					if (config.governments[user_id.government].famine_penalty != undefined) {
						if (user_id.pops.pop_array.length > 0) {
							try {
								for (var i = 0; i < user_id.pops.pop_array.length; i++) {
									for (var x = 0; x < config.pop_array.length; x++) {
										user_id.pops[user_id.pops.pop_array[i]][config.pop_array[x]] = user_id.pops[user_id.pops.pop_array[i]][config.pop_array[x]] - Math.ceil(user_id.pops[user_id.pops.pop_array[i]][config.pop_array[x]]*config.governments[user_id.government].famine_penalty);
									}
								}
							} catch {}
						}
						national_news = national_news + "\nA famine struck citizens of " + user_id.name + " resulting in " + parseNumber(Math.ceil(user_id.population*config.governments[user_id.government].famine_penalty)) + " fatalities.";
					}
					inventory.food = 0;
				} else {
					for (var i = 0; i < user_id.pops.pop_array.length; i++) {
						var is_city = false;
						var local_city_name = "";
						
						if (user_id.pops[user_id.pops.pop_array[i]] != undefined) {
							for (var x = 0; x < user_id.cities.city_array.length; x++) {
								if (user_id.cities[user_id.cities.city_array[x]].province == user_id.pops.pop_array[i]) {
									is_city = true;
									local_city_name = user_id.cities.city_array[x];
									
								}
							}
							for (var x = 0; x < config.pop_array.length; x++) {
								if (is_city) {
									var scalar = 1;
									var total_local_pop = 0;
									var local_el = user_id.pops[user_id.pops.pop_array[i]];
									for (var y = 0; y < config.pop_array.length; y++) {
										total_local_pop = total_local_pop + local_el[config.pop_array[y]];
									}
									
									if (total_local_pop > 5000000) { //-3% per million
										scalar = scalar - Math.ceil((total_local_pop-5000000)/1000000)*0.03;
									}
									if (scalar < 0.775) { //Institute cap
										scalar = 0.775;
									}
									if (Math.ceil(total_local_pop+((user_id.pops[user_id.pops.pop_array[i]][config.pop_array[x]]*user_id.pop_growth_modifier*user_id.modifiers[config.pop_array[x] + "_growth_modifier"])-user_id.pops[user_id.pops.pop_array[i]][config.pop_array[x]])) <= user_id.cities[local_city_name].housing) {
										user_id.pops[user_id.pops.pop_array[i]][config.pop_array[x]] = Math.ceil(user_id.pops[user_id.pops.pop_array[i]][config.pop_array[x]]*user_id.pop_growth_modifier*user_id.modifiers[config.pop_array[x] + "_growth_modifier"]*scalar);
									} else {
										console.log("[Triumph & Tragedy] " + user_id.cities[local_city_name].name + " did not meet housing requirements. Housing: " + user_id.cities[local_city_name].housing + ", potential pop growth for " + config.pop_array[x] + ": " + Math.ceil(user_id.pops[user_id.pops.pop_array[i]][config.pop_array[x]]*user_id.pop_growth_modifier*user_id.modifiers[config.pop_array[x] + "_growth_modifier"]*scalar) + ".");
									}
								} else {
									var local_population = 0;
									for (var y = 0; y < config.pop_array.length; y++) {
										local_population = local_population + user_id.pops[user_id.pops.pop_array[i]][config.pop_array[y]];
									}
									
									if (user_id.pops[user_id.pops.pop_array[i]].pop_cap != undefined) {
										if (local_population < user_id.pops[user_id.pops.pop_array[i]].pop_cap) {
											user_id.pops[user_id.pops.pop_array[i]][config.pop_array[x]] = Math.ceil(user_id.pops[user_id.pops.pop_array[i]][config.pop_array[x]]*user_id.pop_growth_modifier*user_id.modifiers[config.pop_array[x] + "_growth_modifier"]);
										}
									} else {
										user_id.pops[user_id.pops.pop_array[i]][config.pop_array[x]] = Math.ceil(user_id.pops[user_id.pops.pop_array[i]][config.pop_array[x]]*user_id.pop_growth_modifier*user_id.modifiers[config.pop_array[x] + "_growth_modifier"]);
									}
								}
							}
						} else {
							console.log("Pop Array Element " + user_id.pops.pop_array[i] + " returned undefined!");
						}
					}
					inventory.food = inventory.food - Math.ceil(user_id.population/config.population_food_requirement);
				}
				
				inventory.food = Math.ceil(inventory.food);
				
				//Recalculate all pop types
				user_id.population = 0;
				
				var complete_population = 0;
				for (var i = 0; i < config.pop_array.length; i++) {
					user_id[config.pop_array[i]] = 0;
				}
				
				for (var i = 0; i < user_id.pops.pop_array.length; i++) {
					var prov_population = 0;
					if (user_id.pops[user_id.pops.pop_array[i]] != undefined) {
						for (var x = 0; x < config.pop_array.length; x++) {
							prov_population = prov_population + user_id.pops[user_id.pops.pop_array[i]][config.pop_array[x]];
							
							var is_core_manpower = false;
							for (var y = 0; y < user_id.accepted_cultures.length; y++) {
								if (user_id.accepted_cultures[y] == user_id.pops[user_id.pops.pop_array[i]].culture) {
									is_core_manpower = true;
								}
							}
							
							if (isNaN(user_id.pops[user_id.pops.pop_array[i]][config.pop_array[x]]) == false) {
								if (is_core_manpower) {
									user_id[config.pop_array[x]] = user_id[config.pop_array[x]] + user_id.pops[user_id.pops.pop_array[i]][config.pop_array[x]];
								} else {
									user_id[config.pop_array[x]] = user_id[config.pop_array[x]] + Math.ceil(user_id.pops[user_id.pops.pop_array[i]][config.pop_array[x]]*user_id.modifiers.non_core_manpower);
								}
							}
						}
						user_id.pops[user_id.pops.pop_array[i]].population = prov_population;
						if (isNaN(prov_population) == false) {
							complete_population = complete_population + prov_population;
						}
					}
				}
				
				//Soldiers
				user_id.soldiers = user_id.soldiers*user_id.modifiers.national_manpower;
				user_id.population = complete_population;
				
				//Recalculate all city pops
				for (var i = 0; i < cities.city_array.length; i++) {
					if (user_id.pops[cities[cities.city_array[i]].province] != undefined) {
						var total_population = 0;
						for (var x = 0; x < config.pop_array.length; x++) {
							total_population = total_population + user_id.pops[cities[cities.city_array[i]].province][config.pop_array[x]];
						}
						cities[cities.city_array[i]].population = total_population;
					}
				}
				
				user_id.initial_manpower = Math.ceil(user_id.soldiers*user_id.manpower_percentage*user_id.modifiers.national_manpower);
				
				//Upkeep
				if (Math.ceil(user_id.used_soldiers/100*(user_id.modifiers.army_upkeep)) > user_id.money) {
					national_news = national_news + "\nTroops in the " + user_id.name + " deserted en masse. Analysts estimate up to 15% of their armed forces and even colonists may have quite simply dissipated.";
					
					//Mobilised troops also desert
					if (usr.mobilised_manpower[1] != "") {
						usr.used_workers = usr.used_workers - usr.mobilised_manpower[0]*0.15;
						usr.mobilised_manpower[0] = usr.mobilised_manpower[0]*0.85;
						usr.mobilised_manpower[3] = usr.mobilised_manpower[3]*0.85;
					}
					
					user_id.used_soldiers = user_id.used_soldiers - Math.ceil(user_id.used_soldiers*0.15);
					
					for (var i = 0; i < config.units.length; i++) {
						user_id.military[config.units[i]] = Math.ceil(user_id.military[config.units[i]]*0.85);
					}
					
					if (user_id.armies.army_array.length > 0) {
						for (var x = 0; x < user_id.armies.army_array.length; x++) {
							for (var i = 0; i < config.units.length; i++) {
								user_id.armies[user_id.armies.army_array[x]][config.units[i]] = Math.ceil(user_id.armies[user_id.armies.army_array[x]][config.units[i]]*0.85);
							}
						}
					}
				}
				
				if (user_id.population == current_pop) {
					national_news = national_news + "\nDue to a lack of housing in major cities, the population of " + user_id.name + " was unable to grow, and has since stagnated.";
				}
				
				//Recalculate bonuses
				var pop_tax_efficiency = 0;
				var pop_stability_modifier = 0;
				var pop_research_efficiency = 0;
				for (var i = 0; i < config.pop_array.length; i++) {
					if (config.pops[config.pop_array[i]].tax_efficiency_per_100k != undefined) {
						pop_tax_efficiency = pop_tax_efficiency + (user_id[config.pop_array[i]]/100000)*config.pops[config.pop_array[i]].tax_efficiency_per_100k;
					}
					if (config.pops[config.pop_array[i]].stability_per_100k != undefined) {
						pop_stability_modifier = pop_stability_modifier + (user_id[config.pop_array[i]]/100000)*config.pops[config.pop_array[i]].stability_per_100k;
					}
					if (config.pops[config.pop_array[i]].research_efficiency_per_100k != undefined) {
						pop_research_efficiency = pop_research_efficiency + (user_id[config.pop_array[i]]/100000)*config.pops[config.pop_array[i]].research_efficiency_per_100k;
					}
				}
				
				if (pop_tax_efficiency > 60) {
					pop_tax_efficiency = 60;
				}
				if (pop_stability_modifier > 50) {
					pop_stability_modifier = 50;
				}
				if (pop_research_efficiency > 50) {
					pop_research_efficiency = 50;
				}
				
				user_id.modifiers.tax_efficiency = user_id.modifiers.tax_efficiency + pop_tax_efficiency;
				user_id.stability = user_id.stability + pop_stability_modifier;
				user_id.modifiers.research_efficiency = user_id.modifiers.research_efficiency + pop_research_efficiency;
				
				//Civilian Actions
				{
					if (user_id.country_age > 1) {
						if (config.governments[user_id.government].civilian_actions != undefined) {
							user_id.civilian_actions = Math.ceil(user_id.actions*config.governments[user_id.government].civilian_actions);
						} else {
							user_id.civilian_actions = Math.ceil(user_id.actions*user_id.civilian_actions_percentage);
						}
						
						national_news = national_news + "\nThe country of **" + user_id.name + "** now has " + Math.floor(user_id.actions) + " actions, of which " + Math.ceil(user_id.civilian_actions) + " were automatically used by the populace.";
						
						user_id.actions = user_id.actions - user_id.civilian_actions;
					}
				}
			
				//Cultural Assimilation
				{
					//assimilations: [turns, culture, province]
					if (user_id.assimilations.length > 0) {
						var remove_elements = [];
						for (var i = 0; i < user_id.assimilations.length; i++) {
							if (user_id.assimilations[i][0] > 0) {
								user_id.assimilations[i][0]--;
							}
						
							if (user_id.assimilations[i][0] <= 0) {
								var province_belongs_to_user = false;
								for (var x = 0; x < user_id.pops.pop_array.length; x++) {
									if (user_id.assimilations[i] != undefined) {
										if (user_id.pops.pop_array[x] == user_id.assimilations[i][2]) {
											province_belongs_to_user = true;
										}
									}
								}
								
								if (province_belongs_to_user) {
									if (user_id.assimilations[i] != undefined) {
										user_id.pops[user_id.assimilations[i][2]].culture = user_id.assimilations[i][1];
										remove_elements.push(user_id.assimilations[i]);
									}
								}
							}
						}
						//Remove elements from assimilations array
						for (var i = 0; i < remove_elements.length; i++) {
							for (var x = 0; x < user_id.assimilations.length; x++) {
								if (user_id.assimilations[x] == remove_elements[i]) {
									user_id.assimilations.splice(x, 1);
								}
							}
						}
						remove_elements = [];
					}
					
					//cultural_integrations: [turns, culture]
					if (user_id.cultural_integrations.length > 0) {
						var remove_elements = [];
						for (var i = 0; i < user_id.cultural_integrations.length; i++) {
							if (user_id.cultural_integrations[i][0] > 0) {
								user_id.cultural_integrations[i][0]--;
							}
							
							if (user_id.cultural_integrations[i][0] <= 0) {
								user_id.accepted_cultures.push(user_id.cultural_integrations[i][1]);
								remove_elements.push(user_id.cultural_integrations[i]);
							}
						}
						//Remove elements from cultural_integrations array
						for (var i = 0; i < remove_elements.length; i++) {
							for (var x = 0; x < user_id.cultural_integrations.length; x++) {
								if (user_id.cultural_integrations[x] == remove_elements[i]) {
									user_id.cultural_integrations.splice(x, 1);
								}
							}
						}
						remove_elements = [];
					}
				}
			}
			
			//Politics
			{
				//Political Discontent Modifiers - Keep at top, applies modifiers
				{
					//Subtract first to level the playing field
					user_id.modifiers.political_capital_gain = user_id.modifiers.political_capital_gain - user_id.political_capital_gain_modifier;
					user_id.modifiers.reform_desire_gain = user_id.modifiers.reform_desire_gain - user_id.political_reform_desire_modifier;
					user_id.modifiers.stability_modifier = user_id.modifiers.stability_modifier - user_id.political_instability_modifier;
					user_id.political_capital_gain_modifier = 0;
					user_id.political_reform_desire_modifier = 0;
					user_id.political_instability_modifier = 0;
					
					//Negatively impacts stability, reform desire gain, and political capital gain; only begins impacting if party discontent is over 25.
					//Max political_capital_gain_modifier = -5
					//Max political_reform_desire_modifier = 0.2
					//Max political_instability_modifier = -35
					for (var i = 0; i < config.government_list.length; i++) {
						if (user_id.politics[config.government_list[i]] > 0) {
							if (user_id.modifiers[config.government_list[i] + "_discontent"] > 25) {
								user_id.political_capital_gain_modifier = user_id.political_capital_gain_modifier + (-5*user_id.politics[config.government_list[i]]*(user_id.modifiers[config.government_list[i] + "_discontent"]/100));
								user_id.political_reform_desire_modifier = user_id.political_reform_desire_modifier + (0.2*user_id.politics[config.government_list[i]]*(user_id.modifiers[config.government_list[i] + "_discontent"]/100));
								user_id.political_instability_modifier = user_id.political_instability_modifier + (-35*user_id.politics[config.government_list[i]]*(user_id.modifiers[config.government_list[i] + "_discontent"]/100));
							} else {
								user_id.political_capital_gain_modifier = user_id.political_capital_gain_modifier + (5*user_id.politics[config.government_list[i]]*(user_id.modifiers[config.government_list[i] + "_discontent"]/100));
								user_id.political_reform_desire_modifier = user_id.political_reform_desire_modifier - (0.2*user_id.politics[config.government_list[i]]*(user_id.modifiers[config.government_list[i] + "_discontent"]/100));
								user_id.political_instability_modifier = user_id.political_instability_modifier - (-35*user_id.politics[config.government_list[i]]*(user_id.modifiers[config.government_list[i] + "_discontent"]/100));
							}
						}
					}
					
					//Stability cap, cap before re-adding
					if (user_id.political_instability_modifier < -35) {
						user_id.political_instability_modifier = -35;
					}
					if (user_id.political_instability_modifier > 50) {
						user_id.political_instability_modifier = 50;
					}
					
					if (user_id.political_capital_gain_modifier < 0) {
						user_id.political_capital_gain_modifier = 0;
					}
					
					//Reapply modifiers
					user_id.modifiers.political_capital_gain = user_id.modifiers.political_capital_gain + user_id.political_capital_gain_modifier;
					user_id.modifiers.reform_desire_gain = user_id.modifiers.reform_desire_gain + user_id.political_reform_desire_modifier;
					user_id.modifiers.stability_modifier = user_id.modifiers.stability_modifier + user_id.political_instability_modifier;
					
					//Institute cap
					if (user_id.modifiers.political_capital_gain < 5) {
						user_id.modifiers.political_capital_gain = 5;
					}
					if (user_id.modifiers.political_capital_gain > 200) {
						user_id.modifiers.political_capital_gain = 200;
					}
					if (user_id.modifiers.reform_desire_gain > 0.2) {
						user_id.modifiers.reform_desire_gain = 0.2;
					}
					if (user_id.modifiers.reform_desire_gain < -0.25) {
						user_id.modifiers.reform_desire_gain = -0.25;
					}
				}
				
				//Political Capital
				{
					user_id.political_capital = user_id.political_capital + user_id.modifiers.political_capital_gain;
					user_id.political_capital = user_id.political_capital - (user_id.modifiers.political_capital_gain*(0.2*user_id.vassals.length));
					
					//accepted_cultures maintenance for political capital, 1 per accepted culture.
					for (var i = 0; i < user_id.accepted_cultures.length; i++) {
						if (user_id.accepted_cultures[i] != user_id.culture) {
							user_id.political_capital = user_id.political_capital - config.accepted_culture_maintenance_cost;
						}
					}
					
					user_id.political_capital = Math.round(user_id.political_capital);
				}
				
				//Politics
				{
					var most_popular_percentage = 0;
					var most_popular_party = "";
					for (var i = 0; i < config.government_list.length; i++) {
						if (user_id.politics[config.government_list[i]] >= most_popular_percentage) {
							most_popular_percentage = user_id.politics[config.government_list[i]];
							most_popular_party = config.government_list[i];
						}
					}
					
					var total_change = 0;
					for (var i = 0; i < config.government_list.length; i++) {
						var valid_ideology = false;
						for (var x = 0; x < user_id.available_governments.length; x++) {
							if (user_id.available_governments[x] == config.government_list[i]) {
								valid_ideology = true;
							}
						}
						
						if (valid_ideology) {
							total_change = total_change + user_id.modifiers[config.government_list[i]];
							user_id.politics[config.government_list[i]] = user_id.politics[config.government_list[i]] + user_id.modifiers[config.government_list[i]];
						}
					}
					console.log("[Triumph & Tragedy]: Most Popular Party in " + user_id.name + " is: " + most_popular_party);
					console.log("[Triumph & Tragedy]: Total Change in Popularity: " + total_change);
					
					user_id.politics[most_popular_party] = user_id.politics[most_popular_party] - total_change;
					
					//Make sure all percentages equal 100%.
					var total_percentage = 0;
					
					for (var i = 0; i < config.government_list.length; i++) {
						if (user_id.politics[config.government_list[i]] < 0) {
							user_id.politics[config.government_list[i]] = 0;
						}
						total_percentage = total_percentage + user_id.politics[config.government_list[i]];
					}
					if (total_percentage < 100) {
						user_id.politics[most_popular_party] = user_id.politics[most_popular_party] + (100-total_percentage);
					} else if (total_percentage > 100) {
						user_id.politics[most_popular_party] = user_id.politics[most_popular_party] - (total_percentage-100);
					}
					
					if (user_id.politics[most_popular_party] < 0) {
						user_id.politics[most_popular_party] = 0;
					}
					
					//Reconduct check after processing
					for (var i = 0; i < config.government_list.length; i++) {
						if (user_id.politics[config.government_list[i]] >= most_popular_percentage) {
							most_popular_percentage = user_id.politics[config.government_list[i]];
							most_popular_party = config.government_list[i];
						}
					}
					
					//Conduct election - 8 >= 5
					if (main.roundCount >= user_id.last_election+5) {
						var election_winner = most_popular_party;
						
						if (config.governments[user_id.government].has_elections == true) {
							setGovernment(user_id, most_popular_party);
							user_id.last_election = main.roundCount;
							national_news = national_news + "\nThe " + config.governments[most_popular_party].name[1].toLowerCase() + " managed to secure an electoral victory for themselves in the country of **" + user_id.name + "**.";
						} else {
							national_news = national_news + "\nThe country of " + user_id.name + " " + randomElement(config.localisation.rigged_elections);
							user_id.last_election = main.roundCount;
						}
					}
					
					//Reset political parties if anarchy
					if (user_id.government == "anarchy") {
						for (var i = 0; i < config.government_list.length; i++) {
							user_id.politics[config.government_list[i]] = 0;
						}
						user_id.politics.anarchy = 100;
					}
				}
				
				//Reform Desire
				{
					var total_reform_desire_gain = user_id.modifiers.reform_desire_gain;
					for (var i = 0; i < config.government_list.length; i++) {
						if (user_id.politics[config.government_list[i]] > 0) {
							if (config.governments[config.government_list[i]].reform_desire != undefined) {
								total_reform_desire_gain = total_reform_desire_gain + config.governments[config.government_list[i]].reform_desire*(user_id.politics[config.government_list[i]]/100);
							}
						}
					}
					if (total_reform_desire_gain > 0.09) { //9% cap
						total_reform_desire_gain = 0.09;
					}
					
					user_id.modifiers.reform_desire = user_id.modifiers.reform_desire + total_reform_desire_gain;
					
					if (user_id.modifiers.reform_desire < 0) {
						user_id.modifiers.reform_desire = 0;
					} else if (user_id.modifiers.reform_desire > 1) {
						user_id.modifiers.reform_desire = 1;
					}
					
					//If no reforms are unlocked, reset Reform Desire
					if (user_id.available_reforms.length == 0) {
						user_id.modifiers.reform_desire = 0;
					}
					
					//Check if reform desire is at 100%, if so, add discontent to all parties with a popularity greater than 0%.
					if (user_id.modifiers.reform_desire == 1) {
						for (var i = 0; i < config.government_list.length; i++) {
							if (user_id.politics[config.government_list[i]] > 0) {
								user_id.modifiers[config.government_list[i] + "_discontent"] = user_id.modifiers[config.government_list[i] + "_discontent"] + 10;
								if (user_id.modifiers[config.government_list[i] + "_discontent"] > 100) {
									user_id.modifiers[config.government_list[i] + "_discontent"] = 0;
								}
							}
						}
					}
				}
				
				//Stability and revolt risk
				{
					var stab_tax_rate = user_id.tax_rate*100;
					var stab_party_popularity = (user_id.politics[user_id.government]*0.75);
					var stab_government_modifier = 0;
					var age_modifier = 0;
					
					if (config.governments[user_id.government].stability != undefined) {
						if (main.year < 1815 && config.governments[user_id.government].early_game_stability != undefined) {
							stab_government_modifier = config.governments[user_id.government].early_game_stability;
						} else {
							stab_government_modifier = config.governments[user_id.government].stability;
						}
					}
					
					if (!is_simulation) {
						user_id.overextension = returnSafeNumber(getOverextension(user_id.id));
					}
					
					user_id.stability = Math.ceil(stab_party_popularity + stab_government_modifier - Math.ceil(stab_tax_rate) - user_id.overextension + age_modifier + user_id.stability_decay + user_id.modifiers.stability_modifier);
					
					if (user_id.stability > 100) {
						user_id.stability = 100;
					} else if (user_id.stability < 0) {
						user_id.stability = 0;
					}
					
					if (user_id.stability_decay > 0) {
						user_id.stability_decay--;
						user_id.stability--;
					}
					
					if (user_id.country_age > 10) {
						var dice_roll = randomNumber(0, 100);
						if (dice_roll > user_id.stability+config.revolt_threshold || user_id.coup_this_turn == true) {
							var coup_list = [];
							for (var i = 0; i < user_id.available_governments.length; i++) {
								if (user_id.politics[user_id.available_governments[i]] >= 30) {
									coup_list.push(user_id.available_governments[i]);
								}
							}
							var element_to_remove = 0;
							for (var i = 0; i < coup_list.length; i++) {
								if (coup_list[i] == user_id.government) {
									element_to_remove = i;
								}
							}
							coup_list.splice(element_to_remove, 1);
							
							if (coup_list.length > 0) {
								var new_government = randomElement(coup_list);
								
								console.log("[Triumph & Tragedy]: Couped to: " + new_government + " out of the following available governments: " + coup_list.join(", ") + ". This decision was made by the AI.");
								//Revolt
								setGovernment(user_id, new_government);
								
								national_news = national_news + "The country of " + user_id.name + " fell into a state of civil unrest, allowing supporters of " + user_id.government + " to coup the government!\n";
								national_news = national_news + "Rioters then went on strike, leading the country of " + user_id.name + " to lose all their actions!\n";
								user_id.coup_this_turn = false;
								user_id.actions = 0;
								if (!is_simulation) user_id.tax_rate = 0;
							}
						}
						
						if (user_id.overthrow_this_turn != "") {
							user_id.tax_rate = 0;
							var new_government = "";
							var valid_government = false;
							
							//Check if valid ideology
							for (var i = 0; i < user_id.available_governments.length; i++) {
								if (user_id.available_governments[i] == user_id.overthrow_this_turn) {
									valid_government = true;
								}
							}
							
							if (valid_government) {
								setGovernment(user_id, user_id.overthrow_this_turn);
							}
							
							national_news = national_news + "The country of " + user_id.name + " fell into a state of civil unrest, leading supporters of " + user_id.government + " to overthrow the government!\n";
							national_news = national_news + "A general strike was called across " + user_id.name + ", causing them to lose all their actions!\n";
							user_id.overthrow_this_turn = "";
							user_id.actions = 0;
						}
					}
				}
			}
			
			//Resources and RGO
			{
				for (var i = 0; i < config.materials.length; i++) {
					user_id.modifiers[config.materials[i]] = 1;
				}
				for (var i = 0; i < cities.city_array.length; i++) {
					user_id.modifiers[cities[cities.city_array[i]].resource] = user_id.modifiers[cities[cities.city_array[i]].resource] + user_id.modifiers.rgo_throughput;
				}
			}
			
			//Technology
			{
				if (is_simulation == false) {
					var research_removal_array = [];
					var emptied_research_slots = 0;
					var knowledge_investment = config.max_knowledge_investment*user_id.modifiers.knowledge_investment_limit;
					
					if (user_id.researching.length == 1) {
						knowledge_investment = 1;
					}
					if (user_id.researching.length > 0) {
						for (var i = 0; i < user_id.researching.length; i++) {
							var max_knowledge_investment = Math.floor((user_id.inventory.knowledge/user_id.researching.length));
							if (max_knowledge_investment > user_id.researching[i][2]) {
								max_knowledge_investment = user_id.researching[i][2]*knowledge_investment;
							}
							if (user_id.researching[i][0]+max_knowledge_investment >= user_id.researching[i][2]) {
								var already_researched = false;
								
								for (var x = 0; x < user_id.researched_technologies.length; x++) {
									if (user_id.researched_technologies == user_id.researching[i][1]) {
										already_researched = true;
									}
								}
								
								if (already_researched == false) {
									national_news = national_news + "\nThe nation of " + user_id.name + " finished researching **" + user_id.researching[i][1] + "**!";
									//Technology effect
									config.technology[user_id.researching[i][1]].unlocks(user_id);
									user_id.researched_technologies.push(user_id.researching[i][1]);
									user_id.techs_researched++;
									user_id[config.technology[user_id.researching[i][1]].category + "_researched"]++;
									research_removal_array.push(user_id.researching[i]);
									emptied_research_slots++;
									
									if (config.technology[user_id.researching[i][1]].research_cost > user_id.highest_tier) {
										user_id.highest_tier = config.technology[user_id.researching[i][1]].research_cost;
									}
								} else {
									research_removal_array.push(user_id.researching[i]);
									emptied_research_slots++;
								}
							} else {
								user_id.researching[i][0] = user_id.researching[i][0] + Math.round(max_knowledge_investment);
							}
						}
						
						if (is_simulation == false) {
							user_id.inventory.knowledge = 0;
						}
					}
					
					for (var i = 0; i < research_removal_array.length; i++) {
						if (user_id.researching.length > 0) {
							for (var x = 0; x < user_id.researching.length; x++) {
								if (user_id.researching[x] == research_removal_array[i]) {
									user_id.researching.splice(x, 1);
								}
							}
						}
					}
					
					//Run through queue array until a valid technology is discovered, then append and remove from queue array. Iterate through for as many times as needed.
					var research_queue_removal_array = [];
					
					console.log("Emptied Research Slots: " + emptied_research_slots);
					if (emptied_research_slots > 0) {
						console.log("More than one empty research slot was detected!");
						for (var a = 0; a < emptied_research_slots; a++) {
							for (var i = 0; i < user_id.research_queue.length; i++) {
								var technology_exists = false;
								
								for (var x = 0; x < config.valid_technologies.length; x++) {
									if (config.valid_technologies[x] == user_id.research_queue[i]) {
										technology_exists = true;
									}
								}
								
								if (technology_exists) {
									console.log("Research Queue tech exists and is valid!");
									var tech_array_dump = [];
									var tech_category_techs_available = [];
									
									for (var x = 0; x < config.valid_technologies.length; x++) {
										var tech_available = false;
										
										if (config.technology[config.valid_technologies[x]].prerequisite_techs != undefined) {
											var prerequisite_checks = 0;
											for (var y = 0; y < config.technology[config.valid_technologies[x]].prerequisite_techs.length; y++) {
												for (var z = 0; z < user_id.researched_technologies.length; z++) {
													if (config.technology[config.valid_technologies[x]].prerequisite_techs[y] == user_id.researched_technologies[z]) {
														prerequisite_checks++;
													}
												}
											}
											
											if (prerequisite_checks == config.technology[config.valid_technologies[x]].prerequisite_techs.length) {
												tech_available = true;
											}
										} else { //No prerequisite checks found, so must be a starting tech
											tech_available = true;
										}
										
										//Check if user has already researched tech
										for (var y = 0; y < user_id.researched_technologies.length; y++) {
											if (user_id.researched_technologies[y] == config.valid_technologies[x]) {
												tech_available = false;
											}
										}
										
										//Append to valid tech dump for later categorisation
										if (tech_available) {
											tech_array_dump.push(config.valid_technologies[x]);
										}
									}
									
									//Execute research function
									
									var can_research = false;
									for (var x = 0; x < tech_array_dump.length; x++) {
										if (tech_array_dump[x] == user_id.research_queue[i]) {
											can_research = true;
										}
									}
									
									if (can_research) {
										var cached_tech = user_id.research_queue[i];
										console.log("Attempting to research tech " + user_id.research_queue[i] + "!");
										
										user_id.research_queue[i] = "TEMP_CACHE";
										research(user_id.id, cached_tech, "none");
										user_id.research_queue[i] = cached_tech;
										
										for (var x = 0; x < user_id.researching.length; x++) {
											if (user_id.researching[x][1] == user_id.research_queue[i]) {
												research_queue_removal_array.push(user_id.research_queue[i]);
											}
										}
									}
								}
							}
						}
						
						console.log("Research Queue Removal Array: " + research_queue_removal_array);
							
						for (var i = 0; i < research_queue_removal_array.length; i++) {
							for (var x = 0; x < user_id.research_queue.length; x++) {
								if (user_id.research_queue[x] == research_queue_removal_array[i]) {
									user_id.research_queue.splice(x, 1);
								}
							}
						}
					}
				}
			}
					
			//Trade
			{
				user_id.total_transactions_this_turn = 0;
				//[[3, "iron"], "213287117017710593", 3]
				if (is_simulation == false) {
					if (user_id.auto_trades.length > 0) {
						//[other_user_id, amount, item_type]
						for (var i = 0; i < user_id.auto_trades.length; i++) {
							if (main.users[user_id.auto_trades[i][0]].blockaded == false) {
								give(user_id.id, user_id.auto_trades[i][0], user_id.auto_trades[i][1], user_id.auto_trades[i][2], "item", "none");
							}
						}
					}
				}
				
				if (is_simulation == false) {
					if (user_id.trade_array.length > 0) {
						for (var i = 0; i < user_id.trade_array.length; i++) {
							//Decrease shipment timer by 1
							if (user_id.trade_array[i][2] > 0) {
								user_id.trade_array[i][2]--;
							}
							//Check if shipment is ready
							if (user_id.trade_array[i][2] == 0) {
								if (main.users[user_id.trade_array[i][1]] != undefined) {
									if (main.users[user_id.trade_array[i][1]].blockaded == false) {
										if (user_id.trade_array[i][0][1] != "money") {
											main.users[user_id.trade_array[i][1]].inventory[user_id.trade_array[i][0][1]] = main.users[user_id.trade_array[i][1]].inventory[user_id.trade_array[i][0][1]] + user_id.trade_array[i][0][0];
										} else {
											main.users[user_id.trade_array[i][1]].money = main.users[user_id.trade_array[i][1]].money + user_id.trade_array[i][0][0];
										}
									}
								}
								user_id.trade_array.splice(i, 1);
							}
						}
					}
				}
			}
			
			if (is_simulation == false) {
				if (ignore_news == false) {
					news.push(national_news);
				}
			}
			user_id.pops.pop_array = Object.keys(user_id.pops);
			user_id.pops.pop_array.pop();
			
			if (is_simulation) {
				return user_id;
			}
			
			logicCheck(user_id.id);
		}
	
		function processEvents (arg0_user) {
			var user_id = main.users[arg0_user];
			var user = main.users[arg0_user];
			
			//Check for event trigger
			var all_events = Object.keys(config.events);
			
			if (all_events.length > 0) {
				for (var i = 0; i < all_events.length; i++) {
					console.log("[Triumph & Tragedy]: Going through Event " + all_events[i]);
					if (config.events[all_events[i]].trigger != undefined) {
						if (config.events[all_events[i]].trigger(user_id)) {
							printEvent(arg0_user, all_events[i]);
							
							if (user_id.triggered_events[all_events[i]] == undefined) {
								user_id.triggered_events[all_events[i]] = 0;
							} else {
								user_id.triggered_events[all_events[i]]++;
							}
						}
					}
				}
			}
			
			//Auto-expiry
			if (user_id.events.length > 0) {
				for (var i = 0; i < user_id.events.length; i++) {
					if (user_id.events[i][0][1] > 0) {
						user_id.events[i][0][1]--;
					}
					if (user_id.events[i][0][1] == 0 || user_id.last_active_turn < main.roundCount-config.inactive_turns) {
						//Automatically pick an option
						console.log("[Triumph & Tragedy]: " + user_id.events[i][2]);
						var all_options = [];
						for (var x = 0; x < user_id.events[i][2].length+1; x++) {
							var alphabet = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z"];
							if (config.events[user_id.events[i][0][0]]["option_" + alphabet[x]] != undefined) {
								all_options.push("option_" + alphabet[x]);
							}
							if (x == user_id.events[i][2].length) {
								config.events[user_id.events[i][0][0]][randomElement(all_options)];
							} else {
								var random_chance = randomNumber(0, 100);
								if (random_chance <= user_id.events[i][2][x]) {
									if (config.events[user_id.events[i][0][0]]["option_" + alphabet[x]] != undefined) {
										main.users.global.current_scope = user_id.events[i][3];
										config.events[user_id.events[i][0][0]]["option_" + alphabet[x]](user_id);
										if (user != undefined) {
											try {
												user.send("<:old_scroll:716828676880334881> Event **" + user_id.events[i][0][0] + "** was automatically resolved.");
											} catch {}
										}
									}
								}
							}
						}
						user_id.events.splice(i, 1);
					}
				}
			}
		}
	}
	
	//Command functions
	{
		//Basic command functions
		{
			function buy (arg0_user, arg1_msg, arg2_amount, arg3_type) {
				var msg = arg1_msg;
				
				if (main.users[arg0_user] != undefined) {
					var user_id = main.users[arg0_user];
					var usr = main.users[arg0_user];
					var inventory = main.users[arg0_user].inventory;
					var resource_name = arg3_type.toLowerCase();
					console.log("Resource name: " + resource_name);
					var resource_exists = false;
					
					//Market processing
					for (var i = 0; i < config.resource_list.length; i++) {
						if (resource_name == config.resource_list[i][0]) {
							resource_exists = true;
							if (user_id.blockaded == true) {
								arg1_msg.channel.send("You can't buy items whilst blockaded!");
							} else {
								if (isNaN(parseInt(arg2_amount)) == false) {
									var market = main.users.global;
									var total_cost = 0;
									var temp_market = JSON.parse(JSON.stringify(main.users.global));
									
									for (var x = 0; x < arg2_amount; x++) {
										total_cost = total_cost + temp_market[resource_name + "_buy_price"];
										var previous_stock = temp_market[resource_name + "_stock"];
										temp_market[resource_name + "_stock"]--;
										
										//Increase buy price
										temp_market[resource_name + "_buy_price"] = temp_market[resource_name + "_buy_price"]*(previous_stock/temp_market[resource_name + "_stock"]);
										temp_market[resource_name + "_sell_price"] = temp_market[resource_name + "_sell_price"]*(previous_stock/temp_market[resource_name + "_stock"]);
									}
									
									if (user_id.money <= total_cost) {
										arg1_msg.channel.send("You don't have enough money to buy that much " + config.resource_list[i][0] + "! You need another <:money:716817688718213192>" + parseNumber(Math.ceil(total_cost)-user_id.money) + " to fulfil this purchase request.");
									} else {
										if (arg2_amount < market[resource_name + "_stock"]) {
											var valid_purchase = true;
											
											if (market[resource_name + "_stock"] >= 50) {
												if (arg2_amount > market[resource_name + "_stock"]*0.2) {
													valid_purchase = false;
												}
											}
											
											if (arg2_amount > 1000) {
												valid_purchase = false;
											}
											
											if ((arg2_amount+user_id.total_transactions_this_turn) > Math.ceil(user_id.modifiers.shipment_capacity*usr.maximum_transaction_amount)) {
												msg.channel.send("You can only buy/sell up to **" + (usr.maximum_transaction_amount*100) + "%** of your Shipment Capacity each turn from the World Market! This equates to about **" + parseNumber(Math.ceil((user_id.modifiers.shipment_capacity*usr.maximum_transaction_amount))) + "** items per turn, meaning you can purchase only up to **" + parseNumber(Math.ceil((user_id.modifiers.shipment_capacity*usr.maximum_transaction_amount)-user_id.total_transactions_this_turn)) + "** more items this turn.");
											} else {
												if (valid_purchase) {
													var total_buy_price = 0;
													
													user_id.total_transactions_this_turn = user_id.total_transactions_this_turn + arg2_amount;
													for (var x = 0; x < arg2_amount; x++) {
														user_id.money = user_id.money - market[resource_name + "_buy_price"];
														total_buy_price = total_buy_price + market[resource_name + "_buy_price"];
														inventory[resource_name]++;
														var previous_stock = market[arg3_type + "_stock"];
														market[resource_name + "_stock"]--;
														//Increase buy price
														market[resource_name + "_buy_price"] = market[resource_name + "_buy_price"]*(previous_stock/market[arg3_type + "_stock"]);
														market[resource_name + "_sell_price"] = market[resource_name + "_sell_price"]*(previous_stock/market[arg3_type + "_stock"]);
													}
													
													market[resource_name + "_amount_sold"] = market[resource_name + "_amount_sold"] + arg2_amount;
													arg1_msg.channel.send("You bought " + arg2_amount + " " + resource_name + " for **£" + parseNumber(total_buy_price) + "**.");
												} else {
													arg1_msg.channel.send("You can only buy up to **20%** of the goods in a large market at once! This equates to about **" + parseNumber(Math.floor(market[resource_name + "_stock"]*0.2)) + "** " + resource_name + ".");
												}
											}
										} else {
											arg1_msg.channel.send("There isn't enough stock remaining in the global market to purchase this much **" + resource_name + "**!");
										}
									}
								} else {
									arg1_msg.channel.send("You must specify a valid number in order to buy items!");
								}
							}
						}
					}
					
					if (resource_exists == false && arg3_type != "list") {
						arg1_msg.channel.send("That resource isn't for sale!");
					}
				}
			}
			
			function claimAI (arg0_user, arg1_name, arg2_message) {
				//Convert from parameters
				var user_id = arg0_user;
				var usr = (main.users[arg0_user]) ? main.users[arg0_user] : undefined;
				var ai_name = arg1_name.toLowerCase();
				var msg = arg2_message;
				
				//Check to make sure that user isn't defined
				if (!usr || usr.eliminated) {
					//Check to make sure that the country the user is referring to actually exists
					var country_exists = [false, ""];
					
					//Soft match first
					for (var i = 0; i < main.user_array.length; i++) {
						var local_user = main.users[main.user_array[i]];
						if (local_user.type == "ai") {
							country_exists = (!local_user.ai.ai_disabled && local_user.name.toLowerCase().indexOf(ai_name) != -1) ? [true, main.user_array[i]] : country_exists;
						}
					}
					//Hard match second
					for (var i = 0; i < main.user_array.length; i++) {
						var local_user = main.users[main.user_array[i]];
						if (local_user.type == "ai") {
							country_exists = (!local_user.ai.ai_disabled && local_user.name.toLowerCase() == ai_name) ? [true, main.user_array[i]] : country_exists;
						}
					}
					
					if (country_exists[0]) {
						//Disable AI and tag switch it over to new owner
						var local_user = main.users[country_exists[1]];
						local_user.ai.ai_disabled = true;
						main.users.global.user_map[user_id] = country_exists[1];
						
						msg.channel.send("You have successfully claimed **" + local_user.name + "**! Type `" + bot_prefix + "stats` to see your new nation.");
					} else {
						msg.channel.send("The country you have specified, **" + ai_name + "**, does not exist!");
					}
				} else {
					msg.channel.send("You are already playing as **" + usr.name + "**! Ask an admin to delete your country first before trying to claim an AI country.");
				}
			}
			
			function demolish (arg0_user, arg1_msg, arg2_building, arg3_amount, arg4_city) {
				var usr = main.users[arg0_user];
				
				var building_exists = false;
				var building_id = 0;
				var building_name = returnBuilding(arg2_building);
				var city_exists = [false, 0];
				
				for (var i = 0; i < config.buildings.length; i++) {
					if (config.buildings[i] == arg2_building) {
						building_exists = true;
						building_id = i;
					}
				}
				
				//Soft match
				for (var i = 0; i < usr.cities.city_array.length; i++) {
					if (usr.cities[usr.cities.city_array[i]].name.toLowerCase().indexOf(arg4_city.toLowerCase()) != -1) {
						city_exists = [true, usr.cities.city_array[i]];
					}
				}
				
				//Hard match
				for (var i = 0; i < usr.cities.city_array.length; i++) {
					if (usr.cities[usr.cities.city_array[i]].name.toLowerCase() == arg4_city.toLowerCase()) {
						city_exists = [true, usr.cities.city_array[i]];
					}
				}
				
				console.log("[Triumph & Tragedy]: Fetched city_exists as the following value: " + city_exists[1]);
				
				var is_being_justified_on = false;
				
				for (var i = 0; i < main.user_array.length; i++) {
					if (main.users[main.user_array[i]].justifications.length > 0) {
						for (var x = 0; x < main.users[main.user_array[i]].justifications.length; x++) {
							if (main.users[main.user_array[i]].justifications[x][1] == arg0_user) {
								is_being_justified_on = true;
							}
						}
					}
				}
				
				if (is_being_justified_on == false) {
					if (usr.demolish_disabled) {
						msg.channel.send("You cannot nation ruin your country by demolishing buildings! Locked in place by moderator action.");
					} else {
						if (building_exists) {
							//Get manpower cost
							var building_manpower_cost = 0;
							
							for (var i = 0; i < config.building_stats[building_name].costs.length; i++) {
								if (config.pop_array.includes(config.building_stats[building_name].costs[i][1])) {
									console.log(config.building_stats[building_name].costs);
									building_manpower_cost += config.building_stats[building_name].costs[i][0];
								} 
							}
							
							if (city_exists) {
								if (usr.cities[city_exists[1]].buildings[arg2_building] >= arg3_amount) {
									var pop_type = "";
									for (var i = 0; i < config.building_stats[arg2_building].costs.length; i++) {
										var is_pop = false;
										var local_comparison = config.building_stats[arg2_building]["costs"][i][1];
										for (var x = 0; x < config.pop_array.length; x++) {
											if (config.pop_array[x] == local_comparison) {
												is_pop = true;
											}
										}
										if (is_pop) {
											pop_type = local_comparison;
										}
									}
									
									if (pop_type != "") {
										usr["used_" + pop_type] = usr["used_" + pop_type] - building_manpower_cost*arg3_amount;
									}
									
									for (var i = 0; i < arg3_amount; i++) {
										if (config.building_stats[arg2_building].demolish_effect != undefined) {
											config.building_stats[arg2_building].demolish_effect(usr);
										}
									}
									
									usr.cities[city_exists[1]].buildings[arg2_building] = usr.cities[city_exists[1]].buildings[arg2_building] - arg3_amount;
									
									if (config[config.building_stats[arg2_building].category + "_disable_slots"] != true) {
										usr.cities[city_exists[1]].building_count = usr.cities[city_exists[1]].building_count - arg3_amount;
									}
									
									if (config.building_stats[arg2_building].supply_limit != undefined) {
										for (var x = 0; x < config.infrastructure_range*2; x++) {
											var province_id = ((parseInt(usr.cities[city_exists[1]].province)-config.infrastructure_range)+x).toString();
											if (getProvince(province_id, "owner") == arg0_user) {
												if (getProvince(province_id).supply_limit != undefined) {
													getProvince(province_id).supply_limit = getProvince(province_id).supply_limit - config.building_stats[arg2_building].supply_limit;
												} else {
													getProvince(province_id).supply_limit = config.building_stats[arg2_building].supply_limit;
												}
											}
										}
									}
									
									if (arg2_building == "aerodromes") {
										usr.buildings.aerodromes--;
									} else if (arg2_building == "aeroports") {
										usr.buildings.aeroports--;
									} else if (arg2_building == "artillery_encampments") {
										usr.buildings.artillery_encampments--;
									} else if (arg2_building == "auto_plants") {
										usr.buildings.auto_plants--;
									} else if (arg2_building == "barracks") {
										usr.buildings.barracks--;
									} else if (arg2_building == "dockyards") {
										usr.buildings.dockyards--;
									}
									
									if (pop_type != "") {
										arg1_msg.channel.send(arg3_amount + " " + arg2_building + " were demolished. You were refunded **" + parseNumber(Math.ceil((building_manpower_cost*arg3_amount))) + "** " + pop_type + ", and **" + arg3_amount + "** building slots were freed up.");
									} else {
										arg1_msg.channel.send(arg3_amount + " " + arg2_building + " were demolished.");
									}
								} else {
									arg1_msg.channel.send("You don't have that many **" + arg2_building + "**! You can only demolish up to **" + parseNumber(usr.cities[city_exists[1]].buildings[arg2_building]) + "** " + arg2_building + " in this city.");
								}
							} else {
								arg1_msg.channel.send("The city you have specified proved as elusive as El Dorado!");
							}
						} else {
							arg1_msg.channel.send("The type of building that you have specified does not exist!");
						}
					}
				} else {
					arg1_msg.channel.send("You can't demolish buildings whilst being justified on!");
				}
			}
			
			function forage (arg0_user, arg1_msg, arg2_actions) {
				//Convert from parameters
				var user_id = main.users[arg0_user];
				var inventory = main.users[arg0_user].inventory;
				var msg = arg1_msg;
				var action_count = Math.abs(parseInt(arg2_actions));
				
				var salvaged_wood = 0;
				var out_of_actions = false;
				
				if (!isNaN(action_count)) {
					if (action_count < 1001) {
						for (var i = 0; i < action_count; i++) {
							if (user_id.actions > 0) {
								user_id.actions--;
								inventory.wood = inventory.wood + 5;
								salvaged_wood = salvaged_wood + 5;
							} else {
								out_of_actions = true;
							}
						}
					} else {
						if (msg != "none") {
							msg.channel.send("The number you have specified is too large!");
						}
					}
					
					if (msg != "none") {
						if (salvaged_wood != 0) {
							msg.channel.send("You chopped " + salvaged_wood + " <:wood:716791408928751636> wood.");
							if (out_of_actions) {
								msg.channel.send("You then proceeded to run out of actions.");
							}
						} else {
							msg.channel.send("Your loggers were too exhausted to continue logging!");
						}
					}
				} else {
					if (msg != "none") {
						msg.channel.send("You must specify a valid number of actions to log with!");
					}
				}
			}
			
			function mine (arg0_user, arg1_msg, arg2_actions) {
				//Convert from parameters
				var user_id = main.users[arg0_user];
				var inventory = main.users[arg0_user].inventory;
				var msg = arg1_msg;
				var action_count = Math.abs(parseInt(arg2_actions));
				
				var resource_list = "";
				var out_of_actions = false;
				
				var resources_dug_array = [];
				var resources_dug = {
				};
				
				var output_array = [];
				var output_string = "";
				
				if (!isNaN(action_count)) {
					if (action_count < 1001) {
						for (var i = 0; i < action_count; i++) {
							if (user_id.actions > 0) {
								var random_resource = randomElement(config.mineable_materials);
								user_id.actions--;
								inventory[random_resource] = inventory[random_resource] + 5;
								
								var resource_already_exists = false;
								for (var x = 0; x < resources_dug_array.length; x++) {
									if (resources_dug_array[x] == random_resource) {
										resource_already_exists = true;
									}
								}
								
								if (resource_already_exists == false) {
									resources_dug_array.push(random_resource);
									resources_dug[random_resource] = 5;
								} else {
									resources_dug[random_resource] = resources_dug[random_resource] + 5;;
								}
							} else {
								out_of_actions = true;
							}
						}
						console.log("[Triumph & Tragedy]: Resources were dug up as: " + resources_dug_array);
					} else {
						if (msg != "none") {
							msg.channel.send("The number you have specified is too large!");
						}
					}
					
					
					if (resources_dug_array.length != 0) {
						//Generate output array:
							
						var material_icon = [];
						
						for (var i = 0; i < resources_dug_array.length; i++) {
							for (var x = 0; x < config.resource_icons.length; x++) {
								if (config.materials[x] == resources_dug_array[i]) {
									material_icon.push(config.resource_icons[x]);
								}
							}
							
							if (i == resources_dug_array.length-1) {
								var resource_dug_up = resources_dug_array[i];
								
								if (resources_dug_array.length > 1) {
									output_array.push(" and " + resources_dug[resources_dug_array[i]] + " " + material_icon[i] + " " + resources_dug_array[i]);
								} else {
									output_array.push(" " + resources_dug[resources_dug_array[i]] + " " + material_icon[i] + " " + resources_dug_array[i]);
								}
							} else {
								output_array.push(" " + resources_dug[resources_dug_array[i]] + " " + material_icon[i] + " " + resources_dug_array[i]);
							}
						}
						output_string = "You dug up" + output_array.join(",") + ".";
					} else {
						output_string = "Your miners were too exhausted to continue mining!";
					}
					
					if (msg != "none") {
						msg.channel.send(output_string);
						if (out_of_actions) {
							if (output_string != "Your miners were too exhausted to continue mining!") {
								msg.channel.send("You then proceeded to run out of actions.");
							}
						}
					}
				} else {
					if (msg != "none") {
						msg.channel.send("You have entered an invalid number of actions to mine with!");
					}
				}
			}
			
			function printTutorial (arg0_msg, arg1_page) {
				var msg = arg0_msg;
				var page = 0;
				
				if (isNaN(arg1_page) == false) {
					page = parseInt(arg1_page-1);
				}
				if (page < 0 || page > 3) {
					page = 0;
				}
				
				const tutorial_embed_1 = new Discord.MessageEmbed()
					.setColor('#a98ac7')
					.setAuthor('Triumph & Tragedy:', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
					.setTitle('How do I play Triumph & Tragedy? (Page 1 of 4).')
					.setDescription("━━━━\n\n**Founding A Country:**\n__Triumph & Tragedy__ can be at first a confusing, or even frustrating game to one who’s not aware of what they’re doing. To spare you from falling into the same pitfalls as many previous users, we’ve established this tutorial to help you get to understand the bot -- and its interface, a bit better.\n\nTo get started, you’ll need to type `" + bot_prefix + "found <nation name>` in an rp-commands channel.\n\nPlease understand that angled brackets in help commands are not meant to be typed out, and that the words in between them simply describe what the user should put in there. So, unless you want your country to be named ‘nation name’, replace ‘nation name’ with whatever you want your country to be named.")
					.setTimestamp()
					.setFooter('To access this menu again, type ' + bot_prefix + 'tutorial.', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png');
					
				const tutorial_embed_2 = new Discord.MessageEmbed()
					.setColor('#a98ac7')
					.setAuthor('Triumph & Tragedy:', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
					.setTitle('How do I play Triumph & Tragedy? (Page 2 of 4).')
					.setDescription("━━━━\n\n**Getting Started:**\nAfter you’ve founded your nation, you’ll need people to inhabit it, and a government to rule them with. The first thing you’ll want to do is deal with the prompt in your DMs. Type `" + bot_prefix + "resolve 0` to resolve the event. Whilst it should tell you the origin story of your nation, the event will have no practical effect on your country.\n\nAfterwards, make sure to check your local map channel for available provinces by opening it in a new browser tab (if on Desktop), or by downloading it and zooming in (if on mobile). Each province will have a number accompanying it. Simply type `" + bot_prefix + "settle <province number>` to settle a province.\n\nAfter settling your province, you’ll have to establish your capital city on it by typing `" + bot_prefix + "city-new`. The bot will automatically ask you where you want your city to be and what name you wish to give it. Input your previous settled province ID as the location of your new city.\n\nFinally, give yourself a government. Type `" + bot_prefix + "governments` for a full list of available governments, and select the command written next to each government listing, which typically shows up in `" + bot_prefix + "this format`. Now, simply copy/paste the command in that font into your chat bar and press enter to set your government.\n\n**Congratulations!** You have now put your country on the map. If you wish to customise your nation further, you can type `" + bot_prefix + "customisation` for a full list of options, including changing your map colour, renaming your country, creating a motto, setting a flag, or changing your people’s culture. Type `" + bot_prefix + "overview` to view your new country.")
					.setTimestamp()
					.setFooter('To access this menu again, type ' + bot_prefix + 'tutorial.', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png');
					
				const tutorial_embed_3 = new Discord.MessageEmbed()
					.setColor('#a98ac7')
					.setAuthor('Triumph & Tragedy:', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
					.setTitle('How do I play Triumph & Tragedy? (Page 3 of 4).')
					.setDescription("━━━━\n\n**Setting Up:**\nThe first thing you’ll notice about your nation’s interface is that there seems to still be some things left undone, and your cities are empty. You’ll want to acquire a stable income from turn to turn first: consider taxing your people: this can be accomplished by typing `" + bot_prefix + "set-tax`. Taxes are based on actions, but since it’s your first turn, you’ll need to use them up. Each country has 5 starting actions, which can either be used for mining, or for chopping wood.\n\nTo dig up resources, type `" + bot_prefix + "mine [number]`. To gather wood, type `" + bot_prefix + "chop [number]`. `" + bot_prefix + "quarry [number]` can also be used for stone. Please note that the square brackets here, similar to angled brackets, are not meant to be typed out literally.\n\nAfter expending your actions, you should check your resources by typing `" + bot_prefix + "inventory`. Resources, money, and manpower (which shows up in your `" + bot_prefix + "stats` screen) can be used to construct various buildings, and later on, military units. You can view a valid list of buildings to construct (and the resources needed to build them) by typing `" + bot_prefix + "build list`, after which you can simply type `" + bot_prefix + "build` to attempt the construction of a building. Sawmills and schools are recommended as starter buildings. Keep in mind that you must have the resources and spare manpower on hand to construct a building successfully.\n\nYou can also buy up additional resources by typing `" + bot_prefix + "buy list` to bring up a list of all current resources on the market, and `" + bot_prefix + "buy [number] <resource>` to purchase a good. To finish, type `" + bot_prefix + "expeditions` to skip over to the colonisation menu, and issue the `" + bot_prefix + "settle <province id>` command for as many colonial units remaining as it says that you have.")
					.setTimestamp()
					.setFooter('To access this menu again, type ' + bot_prefix + 'tutorial.', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png');
				
				const tutorial_embed_4 = new Discord.MessageEmbed()
					.setColor('#a98ac7')
					.setAuthor('Triumph & Tragedy:', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
					.setTitle('How do I play Triumph & Tragedy? (Page 4 of 4).')
					.setDescription("━━━━\n\n**Looking Into The Future:**\nWith your nation all set up, the future's looking bright. Below is a shortlist of commands that you may find the most useful. If you have any questions, or if you need any help, please DM <@213287117017710593>, the original developer of __Triumph & Tragedy__.\n\n`" + bot_prefix + "overview` - View your national interface. Keep in mind that anything written in `" + bot_prefix + "this font` with the bot prefix attached is a valid command.\n\n`" + bot_prefix + "build list` - View a list of all valid buildings, type `" + bot_prefix + "build` to begin building them.\n`" + bot_prefix + "buy list` - Access a list of purchasable resources.\n`" + bot_prefix + "chop` - Use your actions to gather resources.\n`" + bot_prefix + "craft list` - View a list of all craftable units, type `" + bot_prefix + "craft` to begin training them.\n`" + bot_prefix + "mine` - Use your actions to dig up resources.\n\n`" + bot_prefix + "city` - View an existing city.\n`" + bot_prefix + "city-new` - Found a new city.\n\n`" + bot_prefix + "army-new` - Create a new army.\n`" + bot_prefix + "reserves` - Check your reserves.\n\n`" + bot_prefix + "diplomacy-view` - View your diplomatic options with another user.\n\nAs **Triumph & Tragedy** relies mostly on contextual commands, everything has been designed such that a user can use the bot without ever accessing an actual help menu outside of `" + bot_prefix + "overview`. Keep in mind that at the bottom of each embed, there will be a message in smaller font telling you how to access that menu again. We wish you the best of luck as we continue to develop Triumph & Tragedy into the game we want it to be.")
					.setTimestamp()
					.setFooter('To access this menu again, type ' + bot_prefix + 'tutorial.', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png');
					
				scrollMessage(msg, [tutorial_embed_1, tutorial_embed_2, tutorial_embed_3, tutorial_embed_4], page);
			}
			
			function quarry (arg0_user, arg1_msg, arg2_actions) {
				//Convert from parameters
				var usr = main.users[arg0_user];
				var msg = arg1_msg;
				var demanded_actions = Math.abs(parseInt(arg2_actions));
				var cut_stone = 0;
				
				if (usr.actions != 0) {
					if (!isNaN(demanded_actions)) {
						if (usr.actions < demanded_actions) {
							cut_stone = usr.actions*5;
							usr.inventory.stone = usr.inventory.stone + cut_stone;
							usr.actions = 0;
							if (msg != "none") {
								msg.channel.send("You cut " + cut_stone + " <:stone:716796878649426020> stone.\nYou then proceeded to run out of actions.");
							}
						} else {
							usr.actions = usr.actions - demanded_actions;
							cut_stone = demanded_actions*5;
							usr.inventory.stone = usr.inventory.stone + cut_stone;
							if (msg != "none") {
								msg.channel.send("You cut " + cut_stone + " <:stone:716796878649426020> stone.");
							}
						}
					} else {
						if (msg != "none") {
							msg.channel.send("You must specify a valid number of actions to cut stone with!");
						}
					}
				} else {
					if (msg != "none") {
						msg.channel.send("Your workers are too exhausted to be able to cut up any more stone!");
					}
				}
			}
			
			function sell (arg0_user, arg1_msg, arg2_amount, arg3_type) {
				var msg = arg1_msg;
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					var inventory = usr.inventory;
					
					var resource_name = arg3_type.toLowerCase();
					var resource_exists = false;
					
					//Market processing
					for (var i = 0; i < config.resource_list.length; i++) {
						if (resource_name == config.resource_list[i][0]) {
							resource_exists = true;
							if (usr.blockaded) {
								arg1_msg.channel.send("You can't sell items whilst blockaded!");
							} else {
								if (isNaN(parseInt(arg2_amount)) == false) {
									var market = main.users.global;
									if (arg2_amount > inventory[resource_name]) {
										arg1_msg.channel.send("You don't have enough **" + resource_name + "** to do that! You're " + parseNumber(arg2_amount-inventory[resource_name]) + " " + resource_name + " short.");
									} else {
										var total_sell = 0;
										if ((arg2_amount+usr.total_transactions_this_turn) > Math.ceil(usr.modifiers.shipment_capacity*usr.maximum_transaction_amount)) {
											msg.channel.send("You can only buy/sell up to **" + (usr.maximum_transaction_amount*100) + "%** of your Shipment Capacity each turn from the World Market! This equates to about **" + parseNumber(Math.ceil((usr.modifiers.shipment_capacity*usr.maximum_transaction_amount))) + "** items per turn, meaning you can only sell up to **" + parseNumber(Math.ceil((usr.modifiers.shipment_capacity*usr.maximum_transaction_amount)-usr.total_transactions_this_turn)) + "** more items this turn.");
										} else {
											usr.total_transactions_this_turn = usr.total_transactions_this_turn + arg2_amount;
											
											for (var x = 0; x < arg2_amount; x++) {
												usr.money = usr.money + market[resource_name + "_sell_price"];
												total_sell = total_sell + market[resource_name + "_sell_price"];
												inventory[resource_name]--;
												var previous_stock = market[resource_name + "_stock"];
												market[resource_name + "_stock"]++;
												//Decrease buy/sell price
												market[resource_name + "_buy_price"] = market[resource_name + "_buy_price"]*(previous_stock/market[resource_name + "_stock"]);
												market[resource_name + "_sell_price"] = market[resource_name + "_sell_price"]*(previous_stock/market[resource_name + "_stock"]);
											}
											
											arg1_msg.channel.send("You sold " + arg2_amount + " " + resource_name + " for **£" + parseNumber(total_sell) + "**.");
											market[resource_name + "_amount_sold"] = market[resource_name + "_amount_sold"] + arg2_amount;
										}
									}
								} else {
									msg.channel.send("You must specify a valid number in order to sell items!");
								}
							}
						}
					}
					
					if (resource_exists == false) {
						msg.channel.send("The resource you have specified doesn't even exist! Make sure you've spelled it correctly and used the command in the correct way.");
					}
				} else {
					msg.channel.send("You must found a nation in order to sell goods to the **World Market**!");
				}
			}
			
			function setGovernment (arg0_user, arg1_type) {
				var user_id = arg0_user;
				var government_type = arg1_type;
				
				if (government_type != "") {
					user_id.government = arg1_type;
					user_id.politics.anarchy = 0;
					
					var local_config = config.governments[arg1_type];
					if (local_config.maximum_manpower != undefined) {
						user_id.manpower_percentage = local_config.maximum_manpower;
					}
					if (local_config.maximum_tax_rate != undefined) {
						user_id.max_tax = local_config.maximum_tax_rate;
					}
					if (local_config.civilian_actions != undefined) {
						user_id.civilian_actions_percentage = local_config.civilian_actions;
					}
				}
			}
			
			function settle (arg0_user, arg1_msg, arg2_provs) { //arg2_provs is an array type
				var msg = arg1_msg;
				var usr = main.users[arg0_user];
				
				if (usr.expeditions.length < usr.modifiers.maximum_expeditions) {
					var provs = arg2_provs;
					var prov_checks = 0;
					var has_unit = false;
					var unit_type = "";
					
					//Check for appropriate unit type
					for (var i = config.units.length-1; i >= 0; i--) {
						if (config.unit_stats[config.units[i]].colonise_provinces != undefined) {
							if (provs.length <= config.unit_stats[config.units[i]].colonise_provinces) {
								if (usr.military[config.units[i]] > 0) {
									unit_type = config.units[i];
								}
							}
						}
					}
					
					console.log("[Triumph & Tragedy]: Colonisation command run with " + provs.length + " provinces, appropriate unit type detected as " + unit_type);
					
					if (unit_type != "") {
						if (usr.military[unit_type] > 0) {
							has_unit = true;
							usr.used_soldiers = usr.used_soldiers - config.unit_stats[unit_type].manpower_cost;
						}
					} else {
						has_unit = false;
					}
					
					if (usr.used_soldiers < 0) {
						usr.used_soldiers = 0;
					}
					
					if (has_unit) {
						var taken_provinces = [];
						var colonised_provinces = [];
						var specified_number = true;
						var valid_province = true;
						
						for (var i = 0; i < provs.length; i++) {
							var province_taken = getProvince(provs[i]);
							var being_colonised = false;
							
							for (var x = 0; x < main.user_array.length; x++) {
								if (main.users[main.user_array[x]].pops[provs[i]] != undefined) {
									province_taken = true;
								}
								for (var y = 0; y < main.users[main.user_array[x]].cities.province_array.length; y++) {
									if (main.users[main.user_array[x]].cities.province_array[y] == provs[i]) {
										province_taken = true;
									}
								}
								for (var y = 0; y < main.users[main.user_array[x]].expeditions.length; y++) {
									var local_el = main.users[main.user_array[x]].expeditions[y];
									for (var z = 0; z < local_el[2].length; z++) {
										if (local_el[2][z] == provs[i]) {
											being_colonised = true;
										}
									}
								}
							}
							
							if (province_taken) {
								prov_checks--;
								taken_provinces.push(provs[i]);
							} else if (being_colonised == true) {
								prov_checks--;
								colonised_provinces.push(provs[i]);
							} else if (provs[i].match(/[a-zA-Z]/)) {
								prov_checks--;
								specified_number = false;
							} else if (parseInt(provs[i]) > config.max_provinces || parseInt(provs[i]) < config.min_provinces) {
								prov_checks--;
								valid_province = false;
							} else {
								prov_checks++;
							}
							
							if (/^[0-9]+$/.test(provs[i]) == false) {
								specified_number = false;
								prov_checks--;
							}
						}
						
						if (prov_checks == provs.length) {
							for (var i = 0; i < provs.length; i++) {
								provs[i] = parseInt(provs[i]).toString();
							}
							
							if (usr.provinces == 0) { //Ensure that the first settler has zero travel time.
								for (var i = 0; i < provs.length; i++) {
									main.province_array.push(provs[i]);
									usr.cities.province_array.push(provs[i]);
									usr.provinces++;
								}
								usr.military[unit_type]--;
								
								usr.capital_id = parseInt(provs[0]); //Set capital ID
								if (msg != "none") {
									msg.channel.send("Settlers from **" + usr.name + "** settled the province of **" + provs.join(", ") + "**!");
								}
								original_svg = processSVG([usr.colour, provs[0]], original_svg);
								writeSVGS();
								
								setTimeout(function(){
									cacheSVG();
									setTimeout(function(){
										for (var i = 0; i < map_channel.length; i++) {
											displaySVG(returnChannel(map_channel[i]));
										}
									}, 2000);
								}, 2500);
							} else {
								usr.military[unit_type]--;
								
								//Get distance and colonisation time
								var average_prov_id = 0;
								var prov_distance = 0;
								var prov_colonisation_turns = 0;
								
								average_prov_id = parseInt(randomElement(provs));
								
								console.log("Capital ID: " + usr.capital_id.toString());
								console.log("Average Province ID: " + average_prov_id.toString());
								
								try {
									prov_distance = moveTo(usr.capital_id.toString(), average_prov_id.toString()).length;
									prov_colonisation_turns = Math.ceil(prov_distance/(config.colonisation_speed*usr.modifiers.colonist_travel_speed));
									
									//Cap it off at a certain point so that things can't get too crazy
									if (!(config.max_colonisation_speed == 0 || config.max_colonisation_speed == undefined)) {
										prov_colonisation_turns = (prov_colonisation_turns > config.max_colonisation_speed) ? config.max_colonisation_speed : prov_colonisation_turns;
									}
						
									//["conquistadors", turn_amount, [province_ids]]
									
									usr.expeditions.push([unit_type, prov_colonisation_turns+2, provs]);
									if (msg != "none") {
										msg.channel.send("Settlers from **" + usr.name + "** have set out to colonise the province(s) of " + provs.join(", ") + ". They will arrive in **" + prov_colonisation_turns + "** turns. They will then take an additional **2** turns to colonise.");
									}
								} catch (e) {
									if (msg != "none") {
										var invalid_provinces = [];
										
										for (var i = 0; i < provs.length; i++) {
											if (!provinces[provs[i]]) {
												invalid_provinces.push(provs[i]);
											}
										}
										
										if (invalid_provinces.length == 0) {
											msg.channel.send("Some of the provinces to which your colonists were going to are invalid! This applies to the province(s) of **" + invalid_provinces.join(", ") + "**.");
										} else if (usr.capital_id == 0) {
											msg.channel.send("You need a set capital in order to start colonising provinces!");
										} else {
											msg.channel.send("An error was run into whilst trying this command. Please contact the developers for more information.");
										}
									}
									console.log(e);
								}
							}
						} else {
							var suffix = "";
							if (taken_provinces.length > 0) {
								suffix = suffix + "Province(s) **" + taken_provinces.join(", ") + "** were already settled. ";
							}
							if (specified_number == false) {
								suffix = suffix + "One of the provinces you specified was not numeric! Specify Province IDs, not names. ";
							}
							if (valid_province == false) {
								suffix = suffix + "You specified an invalid province. Provinces only exist between the ranges of **" + parseNumber(config.min_provinces) + "** and **" + parseNumber(config.max_provinces) + "**.";
							}
							if (colonised_provinces.length > 0) {
								suffix = suffix + "At least one of the provinces you have specified are already being colonised by another country! This applies to the province(s) of **" + colonised_provinces.join(", ") + "**.";
							}
							if (arg1_msg != "none") {
								arg1_msg.channel.send("One of the provinces you have specified turned out to be invalid! " + suffix);
							}
						}
					} else {
						if (arg1_msg != "none") {
							var has_colonial_unit = false;
							var greatest_colonial_capability = 0;
							for (var i = 0; i < config.units.length; i++) {
								if (config.unit_stats[config.units[i]].colonise_provinces != undefined && usr.military[config.units[i]] > 0) {
									greatest_colonial_capability = config.unit_stats[config.units[i]].colonise_provinces;
									has_colonial_unit = true;
								}
							}
							
							if (has_colonial_unit) {
								arg1_msg.channel.send("Your best colonial unit is only capable of colonising up to **" + parseNumber(greatest_colonial_capability) + "** province(s) at once!");
							} else {
								arg1_msg.channel.send("You have no colonial units currently capable of colonising new provinces!");
							}
						}
					}
				} else {
					if (arg1_msg != "none") {
						arg1_msg.channel.send("You have reached your maximum limit of **" + usr.modifiers.maximum_expeditions + "** ongoing expeditions!");
					}
				}
			}
		}
		
		//Cheat functions and API (Cheats)
		{
			function addPops (arg0_user, arg1_amount, arg2_type) {
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					
					var random_province = randomElement(usr.pops.pop_array);
					if (config.pops[arg2_type] != undefined) {
						usr.pops[random_province][arg2_type] = usr.pops[random_province][arg2_type] + parseInt(arg1_amount);
						usr[arg2_type] = usr[arg2_type] + parseInt(arg1_amount);
						usr.population = usr.population + parseInt(arg1_amount);
					}
				}
			}
			
			function addWargoal (arg0_user, arg1_user, arg2_wargoal, arg3_message) {
				var msg = arg3_message;
				var all_wargoals = Object.keys(config.casus_belli);
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					
					if (main.users[arg1_user] != undefined) {
						var ot_user = main.users[arg1_user];
						
						if (arg0_user != arg1_user) {
							var wargoal_exists = [false, ""];
							
							if (config.casus_belli[arg2_wargoal.toLowerCase()] != undefined) {
								wargoal_exists = [true, arg2_wargoal.toLowerCase()];
							}
							
							if (wargoal_exists[0]) {
								usr.wargoals.push([wargoal_exists[1], arg1_user]);
								msg.channel.send("You have successfully acquired a **" + wargoal_exists[1] + "** wargoal on the nation of **" + ot_user.name + "**. Type `" + bot_prefix + "declare-war` to use it.");
							} else {
								msg.channel.send("The wargoal you have specified, **" + arg2_wargoal + "** does not actually exist! Here is a list of valid wargoals:\n\n```" + all_wargoals.join("\n") + "```");
							}
						} else {
							msg.channel.send("You cannot add wargoals on yourself!");
						}
					} else {
						msg.channel.send("The person you are trying to add a wargoal on is nonexistent!");
					}
				} else {
					msg.channel.send("You must have a nation to have a valid wargoal on another country!");
				}
			}
		
			function armyDeserts (arg0_user, arg1_percentage) {
				var user_id = main.users[arg0_user];
				
				user_id.used_soldiers = user_id.used_soldiers - Math.ceil(user_id.used_soldiers*arg1_percentage);
				
				for (var i = 0; i < config.units.length; i++) {
					user_id.military[config.units[i]] = Math.ceil(user_id.military[config.units[i]]*(1-arg1_percentage));
				}
				
				if (user_id.armies.army_array.length > 0) {
					for (var x = 0; x < user_id.armies.army_array.length; x++) {
						for (var i = 0; i < config.units.length; i++) {
							user_id["armies"][user_id.armies.army_array[x]][config.units[i]] = Math.ceil(user_id.armies[user_id.armies.army_array[x]][config.units[i]]*(1-arg1_percentage));
						}
					}
				}
			}
			
			function createAllMaterials (arg0_user, arg1_amount, arg2_message) {
				var msg = arg2_message;
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					
					if (isNaN(parseInt(arg1_amount)) == false) {
						usr.money = usr.money + parseInt(arg1_amount);
						for (var i = 0; i < config.materials.length; i++) {
							usr.inventory[config.materials[i]] = usr.inventory[config.materials[i]] + parseInt(arg1_amount);
						}
						msg.channel.send("You have granted to yourself **" + parseNumber(parseInt(arg1_amount)) + "** of every type of material.");
					} else {
						msg.channel.send("You must grant yourself a defined number of materials!");
					}
				} else {
					msg.channel.send("You must have a valid country in order to grant all materials to yourself!");
				}
			}
			
			function generatePops (arg0_user, arg1_province, arg2_total_pop, arg3_cap) {
				var user_id = main.users[arg0_user];
				var prov_id = arg1_province;
				var minimum_pop = 0;
				var maximum_pop = 0;
				var minimum_cap = 0;
				var maximum_cap = 0;
				
				if (Array.isArray(arg2_total_pop)) {
					minimum_pop = arg2_total_pop[0];
					maximum_pop = arg2_total_pop[1];
				} else {
					minimum_pop = arg2_total_pop;
					maximum_pop = arg2_total_pop;
				}
				
				if (Array.isArray(arg3_cap)) {
					minimum_cap = arg3_cap[0];
					maximum_cap = arg3_cap[1];
				} else {
					minimum_cap = arg3_cap;
					maximum_cap = arg3_cap;
				}
				
				var total_population = randomNumber(minimum_pop, maximum_pop);
				var remaining_population = total_population;
				user_id.pops[prov_id] = {};
				
				for (var i = 0; i < config.pop_array.length; i++) {
					if (config.pops[config.pop_array[i]].specialised_pop) {
						console.log("[Triumph & Tragedy]: Generating " + config.pop_array[i] + " for Province " + prov_id + "...");
						
						var randomPercentage = randomNumber((config.pops[config.pop_array[i]].chance*100)/2, (config.pops[config.pop_array[i]].chance*100)*2);
						console.log(randomPercentage + "% - " + Math.ceil(remaining_population*(randomPercentage/100)) + " Pops");
						user_id.pops[prov_id][config.pop_array[i]] = Math.ceil(remaining_population*(randomPercentage/100));
						console.log(user_id.pops[prov_id][config.pop_array[i]]);
						remaining_population = remaining_population - Math.ceil(remaining_population*(randomPercentage/100));
					}
				}
				user_id.pops[prov_id].workers = remaining_population;
				user_id.pops[prov_id].population = total_population;
				user_id.pops[prov_id].culture = user_id.culture;
				user_id.pops[prov_id].pop_cap = randomNumber(minimum_cap, maximum_cap);
				user_id.pops[prov_id].political_concern = {};
				remaining_population = 0;
			}
			
			function instantBuild (arg0_user, arg1_city, arg2_amount, arg3_building, arg4_message) {
				var msg = arg4_message;
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					var city_exists = [false, ""];
					
					//Soft match first
					for (var i = 0; i < usr.cities.city_array.length; i++) {
						if (usr.cities[usr.cities.city_array[i]].name.toLowerCase().indexOf(arg1_city.toLowerCase()) != -1) {
							city_exists = [true, usr.cities.city_array[i]];
						}
					}
					//Hard match second
					for (var i = 0; i < usr.cities.city_array.length; i++) {
						if (usr.cities[usr.cities.city_array[i]].name.toLowerCase() == arg1_city.toLowerCase()) {
							city_exists = [true, usr.cities.city_array[i]];
						}
					}
					
					if (city_exists[0]) {
						var building_name = returnBuilding(arg3_building);
						if (building_name != "invalid") {
							if (isNaN(parseInt(arg2_amount)) == false) {
								var local_el = usr.cities[city_exists[1]];
								
								for (var i = 0; i < parseInt(arg2_amount); i++) {
									if (config.building_stats[building_name].immediate_effect != undefined) {
										config.building_stats[building_name].immediate_effect(usr);
									}
									if (config.building_stats[building_name].houses != undefined) {
										local_el.housing = local_el.housing + config.building_stats[building_name].houses;
									}
									if (config.building_stats[building_name].supply_limit != undefined) {
										for (var x = 0; x < config.infrastructure_range*2; x++) {
											var province_id = ((parseInt(local_el.province)-config.infrastructure_range)+x).toString();
											if (getProvince(province_id, "owner") == arg0_user) {
												if (getProvince(province_id).supply_limit != undefined) {
													getProvince(province_id).supply_limit = getProvince(province_id).supply_limit + config.building_stats[building_name].supply_limit;
												} else {
													getProvince(province_id).supply_limit = config.building_stats[building_name].supply_limit;
												}
											}
										}
									}
								}
								
								local_el.buildings[building_name] = local_el.buildings[building_name] + parseInt(arg2_amount);
								msg.channel.send("Working overtime, builders in **" + usr.name + "** have managed to construct **" + parseNumber(parseInt(arg2_amount)) + "** " + building_name + " instantaneously!");
							} else {
								msg.channel.send("You must specify a valid number of buildings to construct!");
							}
						} else {
							msg.channel.send("The building you have specified could not be found!");
						}
					} else {
						msg.channel.send("The city you have specified proved as elusive as El Dorado!");
					}
				} else {
					msg.channel.send("The user you have specified is undefined!");
				}
			}
			
			function instantResearch (arg0_user, arg1_name, arg2_message) {
				var msg = arg2_message;
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					
					if (arg1_name != undefined) {
						if (config.technology[arg1_name.toLowerCase()] != undefined) {
							var already_researched = false;
							
							for (var i = 0; i < usr.researched_technologies.length; i++) {
								if (usr.researched_technologies[i] == arg1_name.toLowerCase()) {
									already_researched = true;
								}
							}
							
							if (already_researched == false) {
								var tech = arg1_name.toLowerCase();
								config.technology[tech].unlocks(usr);
								usr.researched_technologies.push(tech);
								usr.techs_researched++;
								usr[config.technology[tech].category + "_researched"]++;
								if (config.technology[tech].research_cost > usr.highest_tier) {
									usr.highest_tier = config.technology[tech].research_cost;
								}
								
								for (var i = 0; i < usr.researching.length; i++) {
									if (usr.researching[i][1] == tech) {
										usr.researching.splice(i, 1);
									}
								}
								
								if (arg2_message != "none") {
									msg.channel.send("Your scientists, working overtime, have finished researching **" + tech + "**!");
								}
							} else {
								if (arg2_message != "none") {
									msg.channel.send("You have already researched this technology!");
								}
							}
						} else {
							if (arg2_message != "none") {
								msg.channel.send("The technology you have specified, **" + arg1_name.toLowerCase() + "**, could not be found.");
							}
						}
					}
				} else {
					if (arg2_message != "none") {
						msg.channel.send("You must have a nation before using debug commands!");
					}
				}
			}
			
			function removeParticipant (arg0_user, arg1_war, arg2_side) {
				var war_obj = main.users.global.wars[arg1_war];
				var opp_side;
				
				//arg2_side: attackers/defenders
				if (arg2_side == "attackers") {
					opp_side = "defenders";
				} else if (arg2_side == "defenders") {
					opp_side = "attackers";
				}
				
				for (var i = 0; i < war_obj[opp_side].length; i++) {
					//Remove from all at war arrays
					for (var x = 0; x < main.users[war_obj[opp_side][i]].at_war.length; x++) {
						if (main.users[war_obj[opp_side][i]].at_war == main.users[arg0_user].name) {
							main.users[war_obj[opp_side][i]].at_war.splice(x, 1);
						}
					}
				}
				//Remove from friendly side array itself
				for (var i = 0; i < war_obj[arg2_side].length; i++) {
					if (war_obj[arg2_side][i] == arg0_user) {
						war_obj[arg2_side].splice(i, 1);
					}
				}
			}
			
			function removePops (arg0_user, arg1_amount, arg2_type) {
				//Convert from parameters
				var user_id = arg0_user;
				var usr = main.users[arg0_user];
				var amount = arg1_amount;
				var pop_type = arg2_type;
				
				//Shuffle pops
				var shuffled_provinces = usr.pops.pop_array;
				var current_index = usr.pops.pop_array.length, temporary_value, random_index;
				while (0 != current_index) {
					random_index = Math.floor(Math.random()*current_index);
					current_index -= 1;
					temporary_value = shuffled_provinces[current_index];
					shuffled_provinces[current_index] = shuffled_provinces[random_index];
					shuffled_provinces[random_index] = temporary_value;
				}
				
				var remaining_population = returnSafeNumber(amount);
				
				//Begin subtracting
				for (var i = 0; i < shuffled_provinces.length; i++) {
					if (remaining_population > 0) {
						if (usr.pops[shuffled_provinces[i]] != undefined) {
							if (usr.pops[shuffled_provinces[i]][pop_type] >= remaining_population) {
								usr.pops[shuffled_provinces[i]][pop_type] = usr.pops[shuffled_provinces[i]][pop_type] - remaining_population;
								remaining_population = 0;
							} else if (usr.pops[shuffled_provinces[i]][pop_type] < remaining_population) {
								remaining_population = remaining_population - usr.pops[shuffled_provinces[i]][pop_type];
								usr.pops[shuffled_provinces[i]][pop_type] = 0;
							}
						}
					}
				} 
				
				//Append to either recent_civilian_casualties or recent_military_casualties depending on pop type. Very unoptimised
				if (pop_type == "soldiers") {
					usr.recent_military_casualties[usr.recent_military_casualties.length-1] += returnSafeNumber(amount);
				} else {
					usr.recent_civilian_casualties[usr.recent_civilian_casualties.length-1] += returnSafeNumber(amount);
				}
			}
			
			function researchAllTechs (arg0_user, arg1_msg) {
				var msg = arg1_msg;
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					var all_technologies = Object.keys(config.technology);
					
					for (var i = 0; i < all_technologies.length; i++) {
						var tech_already_researched = false;
						
						for (var x = 0; x < usr.researched_technologies.length; x++) {
							if (usr.researched_technologies[x] == all_technologies[i]) {
								tech_already_researched = true;
							}
						}
						
						if (tech_already_researched == false) {
							usr.researched_technologies.push(all_technologies[i]);
							usr[config.technology[all_technologies[i]].category + "_researched"]++;
							usr.techs_researched++;
							if (config.technology[all_technologies[i]].unlocks != undefined) {
								config.technology[all_technologies[i]].unlocks(usr);
							}
						}
					}
					
					msg.channel.send("**You have successfully researched all valid technologies!**");
				} else {
					msg.channel.send("Remember to register a country first before using debug commands!");
				}
			}
			
			function spawnUnits (arg0_user, arg1_amount, arg2_name, arg3_msg) {
				var msg = arg3_msg;
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					var unit_exists = false;
					
					if (config.unit_stats[arg2_name.toLowerCase()] != undefined) {
						unit_exists = true;
					}
					
					if (unit_exists) {
						if (isNaN(parseInt(arg1_amount)) == false) {
							usr.military[arg2_name.toLowerCase()] = usr.military[arg2_name.toLowerCase()] + parseInt(arg1_amount);
							msg.channel.send("You have spawned in **" + parseNumber(parseInt(arg1_amount)) + "** " + arg2_name.toLowerCase() + " to your reserves. Type `" + bot_prefix + "reserves` to check them out.");
						} else {
							msg.channel.send("You must specify a numeric value for the number of units you wish to spawn in!");
						}
					} else {
						msg.channel.send("The unit you have specified, **" + arg2_name.toLowerCase() + "** was not a valid unit that could be spawned in!");
					}
				} else {
					msg.channel.send("The user you have specified could not be found!");
				}
			}
			
			function unlockAllBuildings (arg0_user, arg1_msg) {
				var msg = arg1_msg;
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					usr.available_buildings = config.buildings;
					
					msg.channel.send("**You have successfully unlocked all buildings.**");
				} else {
					msg.channel.send("You must have a country first in order to unlock all buildings!");
				}
			}
			
			function unlockAllReforms (arg0_user, arg1_msg) {
				var msg = arg1_msg;
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					var all_reform_categories = Object.keys(config.reforms);
					
					usr.available_reforms = all_reform_categories;
					msg.channel.send("**You have successfully unlocked all reforms.**");
				} else {
					msg.channel.send("You must have a country first in order to unlock all reforms!");
				}
			}
			
			function unlockReform (arg0_user, arg1_reform) {
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					var reform_exists = false;
					var reform_already_unlocked = false;
					var all_reform_categories = Object.keys(config.reforms);
					
					//Check if reform exists or is already added
					for (var i = 0; i < all_reform_categories.length; i++) {
						if (all_reform_categories[i] == arg1_reform) {
							reform_exists = true;
						}
					}
					for (var i = 0; i < usr.available_reforms.length; i++) {
						if (usr.available_reforms[i] == arg1_reform) {
							reform_already_unlocked = true;
						}
					}
					
					if (reform_exists == true && reform_already_unlocked == false) {
						var all_reforms_in_category = Object.keys(config.reforms[arg1_reform]);
						for (var i = 0; i < all_reforms_in_category.length; i++) {
							if (all_reforms_in_category[i] == "name") {
								all_reforms_in_category.splice(i, 1);
							}
						}
						
						var reform_obj = config.reforms[arg1_reform][all_reforms_in_category[0]];
						usr.available_reforms.push(arg1_reform);
						
						if (reform_obj.political_appeasement != undefined) {
							for (var i = 0; i < config.government_list.length; i++) {
								if (reform_obj.political_appeasement[config.government_list[i] + "_discontent"] != undefined) {
									usr.modifiers[config.government_list[i] + "_discontent"] = usr.modifiers[config.government_list[i] + "_discontent"] + reform_obj.political_appeasement[config.government_list[i] + "_discontent"];
								}
							}
						}
						if (reform_obj.effects != undefined) {
							for (var i = 0; i < reform_obj.effects.length; i++) {
								if (reform_obj.effects[i][0] == "stability" || reform_obj.effects[i][0] == "max_tax" || reform_obj.effects[i][0] == "manpower_percentage" || reform_obj.effects[i][0] == "pop_growth_modifier") {
									usr[reform_obj.effects[i][0]] = usr[reform_obj.effects[i][0]] + reform_obj.effects[i][1];
								} else {
									usr.modifiers[reform_obj.effects[i][0]] = usr.modifiers[reform_obj.effects[i][0]] + reform_obj.effects[i][1];
								}
							}
						}
					}
				}
			}
		}
		
		//Actual Moderation functions
		{
			function deleteMessage (arg0_message_id, arg1_message, arg2_keep_message) {
				//Convert from parameters
				var message_id = arg0_message_id;
				var msg = arg1_message;
				var keep_message = (arg2_keep_message.toLowerCase() == "ca");
				
				if (hasRole(msg, "Senior Developer")) {
					msg.channel.messages.fetch(message_id).then((message) => {
						msg.channel.send("Soi hab en Lett delt; Coment en '" + message.content + "'.\n\n:warning: **Notte!** D dictat aer vo 2FA nepas e. Ej soi ré Permes, bis soi Lett-Delt manuelle.").then((message) => {
							if (!keep_message) msg.delete();
							if (!keep_message) setTimeout(function(){ message.delete(); }, 10000);
						});
						message.delete();
					});
				} else {
					msg.channel.send("Soi hab ne Permes en d dictat carei!").then((message) => {
						if (!keep_message) setTimeout(function(){ message.delete(); }, 10000);
					});
				}
			}
			
			function deoublier (arg0_user, arg1_message) {
				//Convert from parameters
				var user_id = arg0_user;
				var msg = arg1_message;
				
				if (hasRole(msg, "Senior Developer")) {
					var guild_obj = client.guilds.cache.get(msg.guild.id);
					var member = guild_obj.members.fetch(user_id).then((member) => {
						if (member) {
							try {
								member.roles.set(["549011232133349376"]);
								member.setNickname("");
								msg.channel.send("Rís hab d Gleder deoublién.\n\n:warning: **Notte!** D dictat aer vo 2FA nepas e. Ej soi ré Permes, bis soi Rol-Assignment manuelle.");
							} catch (e) {
								console.log(e);
								msg.channel.send("D dictat e vo d Comunite suport ne.");
							}
						} else {
							msg.channel.send("D Gleder var zéi lódt.");
						}
					});
				} else {
					msg.channel.send("Soi hab ne Permes en d dictat carei!");
				}
			}
			
			function oublier (arg0_user, arg1_message) {
				//Convert from parameters
				var user_id = arg0_user;
				var msg = arg1_message;
				
				//Imported ES5 one liner for leading zero formatting
				const zeroPad = (num, places) => String(num).padStart(places, '0');
				
				if (hasRole(msg, "Senior Developer")) {
					var guild_obj = client.guilds.cache.get(msg.guild.id);
					var member = guild_obj.members.fetch(user_id).then((member) => {
						if (member) {
							try {
								member.roles.set(["851549383514128444"]);
								member.setNickname(`Inmate ${zeroPad(guild_obj.roles.cache.get("851549383514128444").members.size+1, 4)}`);
								msg.channel.send("Rís hab d Gleder oublién.\n\n:warning: **Notte!** D dictat aer vo 2FA nepas e. Ej soi ré Permes, bis soi Rol-Assignment manuelle.");
							} catch (e) {
								console.log(e);
								msg.channel.send("D dictat e vo d Comunite suport ne.");
							}
						} else {
							msg.channel.send("D Gleder var zéi lódt.");
						}
					});
				} else {
					msg.channel.send("Soi hab ne Permes en d dictat carei!");
				}
			}
		}
		
		//RP Moderation functions
		{
			//NOT COMPLETED - DO NOT USE
			function assumeControl (arg0_id, arg1_user, arg2_message) {
				var msg = arg2_message;
					
				if (main.users[arg1_user] != undefined) {
					var process_data = JSON.stringify(main);
					var local_regex = new RegExp("/" + arg1_user + "/g");
					process_data.replace(local_regex, arg0_id);
					main = JSON.parse(process_data);
					writeSave();
					
					/*setTimeout(function(){
						msg.channel.send("**" + main.users[arg0_id].name + "** was taken over by user ID " + arg0_id + " (<@" + arg0_id + ">).");
					}, 1000);*/
				} else {
					msg.channel.send("The user you are attempting to take control of could not be found!");
				}
			}
			
			function deleteCountry (arg0_user, arg1_message) {
				//Convert from parameters
				var user_id = arg0_user;
				var msg = arg1_message;
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					
					//Remove all the user's armies
					if (usr.armies.army_array > 0) {
						for (var i = 0; i < usr.armies.army_array; i++) {
							deleteArmy(usr.id, "none", usr.armies[usr.armies.army_array[i]].name);
						}
					}
					
					//Check if user is in any wars
					var all_wars = Object.keys(main.users.global.wars);
					for (var i = 0; i < all_wars.length; i++) {
						var war_obj = main.users.global.wars[all_wars[i]];
						var user_involved = [false, ""];
						
						for (var x = 0; x < war_obj.attackers.length; x++) {
							if (war_obj.attackers[x] == usr.id) {
								user_involved = [true, "attackers"];
							}
						}
						for (var x = 0; x < war_obj.defenders.length; x++) {
							if (war_obj.defenders[x] == usr.id) {
								user_involved = [true, "defenders"];
							}
						}
						
						if ((user_involved[1] == "defenders" && war_obj.defenders.length == 1) || (user_involved[1] == "attackers" && war_obj.attackers.length == 1)) {
							//Remove occupations
							var remove_occupations = [];
							
							for (var x = 0; x < main.users.global.occupations.length; x++) {
								var belongs_to_belligerent = false;
								//[prov_id, city, original_country, new_country]; ["0", true, "<user_id>", "<user_id>"];
								for (var y = 0; y < war_obj.attackers.length; y++) {
									if (main.users.global.occupations[x][2] == war_obj.attackers[y]) {
										transferProvince(main.users.global.occupations[x][3], main.users.global.occupations[x][0], main.users.global.occupations[x][2], "none");
										remove_occupations.push(main.users.global.occupations[x]);
									}
								}
								for (var y = 0; y < war_obj.defenders.length; y++) {
									if (main.users.global.occupations[x][2] == war_obj.defenders[y]) {
										transferProvince(main.users.global.occupations[x][3], main.users.global.occupations[x][0], main.users.global.occupations[x][2], "none");
										remove_occupations.push(main.users.global.occupations[x]);
									}
								}
							}
							
							for (var x = 0; x < remove_occupations.length; x++) {
								for (var y = 0; y < main.users.global.occupations.length; y++) {
									if (main.users.global.occupations[y] == remove_occupations[x]) {
										main.users.global.occupations.splice(y, 1);
									}
								}
							}
							
							//Remove war object
							delete main.users.global.wars[all_wars[i]];
						}
					}
							
					//Remove from at_war array for all users
					for (var i = 0; i < main.user_array.length; i++) {
						if (main.users[main.user_array[i]].at_war.length > 0) {
							for (var x = 0; x < main.users[main.user_array[i]].at_war.length; x++) {
								if (main.users[main.user_array[i]].at_war[x] == usr.name) {
									main.users[main.user_array[i]].at_war.splice(x, 1);
								}
							}
						}
					}
					
					//Remove expeditions array and other data
					usr.expeditions = [];
					usr.researching = [];
					usr.research_queue = [];
					usr.auto_trades = [];
					
					var all_provinces = [];
					
					//Reset map colours
					for (var i = 0; i < usr.cities.province_array.length; i++) {
						var already_included = false;
						for (var x = 0; x < all_provinces.length; x++) {
							if (all_provinces[x] == usr.cities.province_array[i]) {
								already_included = true;
							}
						}
						
						if (already_included == false) {
							all_provinces.push(usr.cities.province_array[i]);
						}
					}
					for (var i = 0; i < usr.pops.pop_array.length; i++) {
						var already_included = false;
						for (var x = 0; x < all_provinces.length; x++) {
							if (all_provinces[x] == usr.pops.pop_array[i]) {
								already_included = true;
							}
						}
						
						if (already_included == false) {
							all_provinces.push(usr.pops.pop_array[i]);
						}
					}
					
					for (var i = 0; i < all_provinces.length; i++) {
						original_svg = processSVG([[179, 179, 179], all_provinces[i]], original_svg);
					}
					writeSVGS();
					
					//Delete all cities as well as pops
					for (var i = 0; i < usr.cities.province_array.length; i++) {
						for (var x = 0; x < main.province_array.length; x++) {
							if (main.province_array[x] == usr.cities.province_array[i]) {
								main.province_array.splice(x, 1);
							}
						}
					}
					for (var i = 0; i < usr.pops.pop_array.length; i++) {
						for (var x = 0; x < main.province_array.length; x++) {
							if (main.province_array[x] == usr.pops.pop_array[i]) {
								main.province_array.splice(x, 1);
							}
						}
					}
					
					//Reset pops and cities
					usr.pops = {};
					usr.pops.pop_array = [];
					usr.cities = {};
					usr.cities.province_array = [];
					usr.cities.city_array = [];
					
					usr.provinces = 0;
					
					//Remove from user array
					for (var i = 0; i < main.user_array.length; i++) {
						if (main.user_array[i] == arg0_user) {
							main.user_array.splice(i, 1);
						}
					}
					
					//Mark user as eliminated
					usr.eliminated = true;
					ignore_news = true;
					nextTurn(arg0_user);
					ignore_news = false;
					
					var all_user_maps = Object.keys(main.users.global.user_map);
					for (var i = 0; i < all_user_maps.length; i++) if (main.users.global.user_map[all_user_maps[i]] == user_id) delete main.users.global.user_map[all_user_maps[i]];
					
				} else {
					if (msg != "none") {
						msg.channel.send("The nation you are trying to delete is already nonexistent!");
					}
				}
			}
			
			function forceRename (arg0_user, arg1_name, arg2_message) {
				var msg = arg2_message;
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					
					msg.channel.send("You have changed the name of `" + usr.name + "` to **" + arg1_name + "**.");
					usr.name = arg1_name;
				} else {
					msg.channel.send("The user you have specified does not exist!");
				}
			}
			
			function lockAll (arg0_user, arg1_mode, arg2_message) {
				var msg = arg2_message;
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					
					if (arg1_mode == "lock") {
						usr.colour_locked = false;
						usr.culture_locked = false;
						usr.flag_locked = false;
						usr.name_locked = false;
						lockColour(usr.id, "none");
						lockCulture(usr.id, "none");
						lockFlag(usr.id, "none");
						lockName(usr.id, "none");
						msg.channel.send("You have successfully locked all customisation options for **" + usr.name + "**.");
					} else if (arg1_mode == "unlock") {
						usr.colour_locked = true;
						usr.culture_locked = true;
						usr.flag_locked = true;
						usr.name_locked = true;
						lockColour(usr.id, "none");
						lockCulture(usr.id, "none");
						lockFlag(usr.id, "none");
						lockName(usr.id, "none");
						msg.channel.send("You have successfully unlocked all customisation options for **" + usr.name + "**.");
					}
				} else {
					msg.channel.send("The user you have specified must have a valid country before you can lock all their customisation options!");
				}
			}
			
			function lockColour (arg0_user, arg1_message) {
				var msg = arg1_message;
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					
					if (usr.colour_locked) {
						usr.colour_locked = false;
						if (msg != "none") {
							msg.channel.send("You have unlocked the ability for **" + usr.name + "** to change their colour once again.");
						}
					} else {
						usr.colour_locked = true;
						if (msg != "none") {
							msg.channel.send("You have locked the ability for **" + usr.name + "** to change their colour. They will not be able to change it without the approval of moderators.");
						}
					}
				} else {
					if (msg != "none") {
						msg.channel.send("The user you have specified must have a valid country before you can lock their colour!");
					}
				}
			}
			
			function lockCulture (arg0_user, arg1_message) {
				var msg = arg1_message;
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					
					if (usr.culture_locked) {
						usr.culture_locked = false;
						if (msg != "none") {
							msg.channel.send("You have unlocked the ability for **" + usr.name + "** to change the name of their culture once again.");
						}
					} else {
						usr.culture_locked = true;
						if (msg != "none") {
							msg.channel.send("You have locked the ability for **" + usr.name + "** to change their culture name. They will not be able to change it without the approval of moderators.");
						}
					}
				} else {
					if (msg != "none") {
						msg.channel.send("The user you have specified must have a valid country before you can lock their culture!");
					}
				}
			}
			
			function lockFlag (arg0_user, arg1_message) {
				var msg = arg1_message;
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					
					if (usr.flag_locked) {
						usr.flag_locked = false;
						msg.channel.send("You have unlocked the ability for **" + usr.name + "** to change their flag once again.");
					} else {
						usr.flag_locked = true;
						msg.channel.send("You have locked the ability for **" + usr.name + "** to change their flag. They will not be able to change it without the approval of moderators.");
					}
				} else {
					if (msg != "none") {
						msg.channel.send("The user you have specified must have a valid country before you can lock their flag!");
					}
				}
			}
			
			function lockName (arg0_user, arg1_message) {
				var msg = arg1_message;
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					
					if (usr.name_locked) {
						usr.name_locked = false;
						if (msg != "none") {
							msg.channel.send("You have unlocked the ability for **" + usr.name + "** to change their name once again.");
						}
					} else {
						usr.name_locked = true;
						if (msg != "none") {
							msg.channel.send("You have locked the ability for **" + usr.name + "** to change their name. They will not be able to change it without the approval of moderators.");
						}
					}
				} else {
					if (msg != "none") {
						msg.channel.send("The user you have specified must have a valid country before you can lock their name!");
					}
				}
			}
		}
		
		//Army & Combat functions
		{
			//War interface
			{
				function printWar (arg0_user, arg1_war, arg2_msg) {
					//Convert from parameters
					var war_name = arg1_war;
					var msg = arg2_msg;
					
					var print_war_array = [];
					var is_involved = false;
					
					var war_obj = getWar(war_name);
					var all_wars = Object.keys(main.users.global.wars);
					
					checkWars();
					
					if (main.users[arg0_user] != undefined) {
						var usr = main.users[arg0_user];
						for (var i = 0; i < all_wars.length; i++) { //soft match first
							if (main.users.global.wars[all_wars[i]].name.toLowerCase().indexOf(arg1_war.toLowerCase()) != -1) {
								war_exists = [true, all_wars[i]];
							}
						}
						for (var i = 0; i < all_wars.length; i++) { //hard match second
							if (main.users.global.wars[all_wars[i]].name.toLowerCase() == arg1_war.toLowerCase()) {
								war_exists = [true, all_wars[i]];
							}
						}
						
						if (war_obj) {
							//Check to make sure they don't equal NaN
							var attacker_warscore = (!isNaN(Math.ceil(war_obj.attacker_warscore*100)/100)) ? Math.ceil(war_obj.attacker_warscore*100)/100 : 100,
								defender_warscore = (!isNaN(Math.ceil(war_obj.defender_warscore*100)/100)) ? Math.ceil(war_obj.defender_warscore*100)/100 : 100;
							
							//Dynamic command variables, create boolean variables first
							var currently_winning_score = Math.max(war_obj.attacker_warscore, war_obj.defender_warscore);
							var currently_winning_side = (war_obj.attacker_warscore == currently_winning_score) ? "attacker" : "target";
							var winning_war_leader = main.users[war_obj["original_" + currently_winning_side]];
							
							//Dynamic command variables - print variables
							var rename_war_command = (winning_war_leader.id == usr.id) ? "\nTo rename this war, type `" + bot_prefix + "rename-war`." : "";
							
							war_obj.name = war_obj.name.trim();
							print_war_array.push("__**" + war_obj.name.trim() + ":**__" + rename_war_command);
							print_war_array.push("Defender Warscore: **" + defender_warscore + "**% ¦ Attacker Warscore: **" + attacker_warscore + "%**");
							print_war_array.push("");
							print_war_array.push("**Defender Wargoals: **");
							for (var i = 0; i < war_obj.defender_wargoals.length; i++) {
								print_war_array.push(war_obj.defender_wargoals[i]);
							}
							print_war_array.push("");
							print_war_array.push("**Attacker Wargoals: **");
							for (var i = 0; i < war_obj.attacker_wargoals.length; i++) {
								print_war_array.push(war_obj.attacker_wargoals[i]);
							}
							print_war_array.push("------------------");
							if (usr.allies.length > 0 && is_involved) {
								if (war_obj.original_attacker == usr.id || war_obj.original_target == usr.id) {
									print_war_array.push("Type `" + bot_prefix + "call-ally` to call your allies into the war.");
								}
							}
							print_war_array.push("");
							print_war_array.push("`Participant Name ¦ User ¦ Military Casualties`");
							print_war_array.push("---");
							print_war_array.push("**Attackers:**\n");
							print_war_array.push("Total Military Casualties: **" + parseNumber(war_obj.attacker_total_casualties) + "**");
							
							//See if user is involved in the war
							for (var i = 0; i < war_obj.attackers.length; i++) {
								print_war_array.push("**" + main.users[war_obj.attackers[i]].name + "** ¦ <@" + war_obj.attackers[i] + "> ¦ " + parseNumber(war_obj[war_obj.attackers[i] + "_casualties"]));
								if (war_obj.attackers[i] == usr.id) {
									is_involved = true;
								}
							}
							print_war_array.push("---");
							print_war_array.push("**Defenders:**\n");
							print_war_array.push("Total Military Casualties: **" + parseNumber(war_obj.defender_total_casualties) + "**");
							for (var i = 0; i < war_obj.defenders.length; i++) {
								print_war_array.push("**" + main.users[war_obj.defenders[i]].name + "** ¦ <@" + war_obj.defenders[i] + "> ¦ " + parseNumber(war_obj[war_obj.defenders[i] + "_casualties"]));
								if (war_obj.defenders[i] == usr.id) {
									is_involved = true;
								}
							}
							if (is_involved) {
								print_war_array.push("------------------");
								print_war_array.push("**Settle for Peace:**");
								var has_peace_treaty_active = false;
								var all_peace_offers = Object.keys(war_obj.peace_offers);
								
								if (all_peace_offers.length > 0) {
									for (var i = 0; i < all_peace_offers.length; i++) {
										if (war_obj.peace_offers[all_peace_offers[i]].country == usr.id) {
											has_peace_treaty_active = true;
										}
									}
								}
								
								if (has_peace_treaty_active) {
									print_war_array.push("**View Peace Offer:** - `" + bot_prefix + 'view-peace-treaty "' + war_obj.name.trim() + '"`');
									print_war_array.push("**Add Wargoal:** - `" + bot_prefix + 'add-wargoal "' + war_obj.name.trim() + '" <wargoal>`');
									print_war_array.push("**Remove Wargoal:** - `" + bot_prefix + 'remove-wargoal "' + war_obj.name.trim() + '" <wargoal>`');
									print_war_array.push("**Send Peace Offer:** - `" + bot_prefix + 'send-peace-offer "' + war_obj.name.trim() + '"`');
								} else {
									print_war_array.push("To create a peace offer, type `" + bot_prefix + 'sign-peace-treaty "' + war_obj.name.trim() + '"`.');
								}
							}
						
							const embed_war_stats = new Discord.MessageEmbed()
								.setColor('#a98ac7')
								.setAuthor('Triumph & Tragedy:', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
								.setTitle('**War Overview:\n------------------**')
								.setThumbnail('https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
								.setDescription(print_war_array.join("\n"))
								.setTimestamp()
								.setFooter('To access this menu again, type ' + bot_prefix + 'view-war "' + war_obj.name.trim() + '".', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png');
								
							msg.channel.send(embed_war_stats);
						} else {
							msg.channel.send("The war you have specified does not even exist! Type `" + bot_prefix + "war-list` for a complete list of active conflicts.");
						}
					} else {
						msg.channel.send("You must have a nation registered in order to view this war!");
					}
				}
				
				function printWars (arg0_msg) {
					//Convert from parameters
					var msg = arg0_msg;
					
					//Make sure to check wars first before printing
					checkWars();
					var wars_list_array = [];
					
					var all_wars = Object.keys(main.users.global.wars);
					if (all_wars.length > 0) {
						wars_list_array.push("`War Name ¦ Number of Nations Involved ¦ Defender Warscore - Attacker Warscore ¦ Total Casualties`");
						if (all_wars.length > 0) {
							wars_list_array.push("");
							for (var i = 0; i < all_wars.length; i++) {
								var war_obj = main.users.global.wars[all_wars[i]];
								var number_of_nations = war_obj.attackers.length + war_obj.defenders.length;
								var total_casualties = war_obj.attacker_total_casualties + war_obj.defender_total_casualties;
								wars_list_array.push("**" + war_obj.name + "** ¦ " + parseNumber(number_of_nations) + " ¦ **" + parseNumber(war_obj.defender_warscore) + "%** - **" + parseNumber(war_obj.attacker_warscore) + "%** ¦ " + parseNumber(total_casualties));
								wars_list_array.push("`" + bot_prefix + 'view-war "' + war_obj.name.trim() + '"`');
								wars_list_array.push("");
							}
						}
					} else {
						wars_list_array.push("_There are currently no ongoing conflicts._");
					}
					
					const embed_war_list = new Discord.MessageEmbed()
						.setColor('#a98ac7')
						.setAuthor('Triumph & Tragedy:', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
						.setTitle('**War List:\n------------------**')
						.setThumbnail('https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
						.setDescription(wars_list_array.join("\n"))
						.setTimestamp()
						.setFooter('To access this menu again, type ' + bot_prefix + 'war-list.', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png');
					
					msg.channel.send(embed_war_list);
				}
				
				function renameWar (arg0_user, arg1_war, arg2_new_war_name, arg3_msg) {
					//Convert from parameters
					var war_name = arg1_war;
					var new_name = arg2_new_war_name;
					var msg = arg3_msg;
					
					if (main.users[arg0_user] != undefined) {
						var usr = main.users[arg0_user];
						var war_obj = getWar(war_name);
						
						if (war_obj) {
							//Determine war leader of currently winning side
							var currently_winning_score = Math.max(war_obj.attacker_warscore, war_obj.defender_warscore);
							var currently_winning_side = (war_obj.attacker_warscore == currently_winning_score) ? "attacker" : "target";
							
							var winning_war_leader = (war_obj.attacker_warscore != war_obj.defender_warscore) ? main.users[war_obj["original_" + currently_winning_side]] : main.users[war_obj.original_attacker];
							
							//Check to see if user is able to rename war
							if (winning_war_leader.id == usr.id) {
								//User is able to rename war, so do it
								war_obj.name = parseString(new_name);
								msg.channel.send("You have renamed this conflict to the **" + war_obj.name + "**!");
							} else {
								if (war_obj.attacker_warscore == war_obj.defender_warscore) {
									msg.channel.send("Since both sides are at a stalemate currently, only the war leader of the attacking side, **" + winning_war_leader.name + "**, is able to rename this conflict!");
								} else {
									msg.channel.send("Only the war leader of the side currently winning, **" + winning_war_leader.name + "**, is able to rename this conflict!");
								}
							}
						} else {
							msg.channel.send("The war you have specified, **" + war_name + "**, is either no longer ongoing, or has never existed!");
						}
					} else {
						msg.channel.send("You can't rename a war if you don't even have a nation!");
					}
				}
			}
			
			//Army order functions
			{
				function carpetSiege (arg0_user, arg1_target, arg2_msg, arg3_armies) {
					//Convert from parameters
					var user_id = arg0_user;
					var usr = (main.users[arg0_user]) ? main.users[arg0_user] : undefined;
					var target_id = arg1_target;
					var ot_user = (main.users[arg1_target]) ? main.users[arg1_target] : undefined;
					var msg = arg2_msg;
					var army_list = (arg3_armies && arg3_armies != "none") ? parseOrdinals(arg3_armies) : [];
					
					
					//Check to see if user is defined
					if (usr != undefined) {
						if (ot_user != undefined) {
							//Make sure user is actually at war with the other user before carpet sieging
							if (usr.at_war.includes(ot_user.name)) {
								//Begin drafting target list
								var occupation_target_list = [];
								
								//Add all provinces first
								for (var i = 0; i < ot_user.pops.pop_array.length; i++) {
									if (!occupation_target_list.includes(ot_user.pops.pop_array[i])) {
										occupation_target_list.push(ot_user.pops.pop_array[i]);
									}
								}
								for (var i = 0; i < ot_user.cities.province_array.length; i++) {
									if (!occupation_target_list.includes(ot_user.cities.province_array[i])) {
										occupation_target_list.push(ot_user.cities.province_array[i]);
									}
								}
								
								//Deselect provinces already going to be occupied by other armies
								for (var i = 0; i < usr.armies.army_array.length; i++) {
									var local_army = usr.armies[usr.armies.army_array[i]];
									
									//Check if the province they're moving to is included in occupation_target_list
									if (local_army.moving_to.length > 0) {
										if (occupation_target_list.includes(local_army.moving_to[local_army.moving_to.length-1])) {
											//Remove the province from the occupation target list
											for (var x = 0; x < occupation_target_list.length; x++) {
												if (occupation_target_list[x] == local_army.moving_to[local_army.moving_to.length-1]) {
													occupation_target_list.splice(x, 1);
												}
											}
										}
									}
								}
								
								//Get acceptable armies as array
								var acceptable_armies = (army_list.length > 0) ? army_list : [];
								
								if (acceptable_armies.length == 0) {
									//Acceptable armies are immediately just whatever land armies are not currently busy and have actual troops in them
									for (var i = 0; i < usr.armies.army_array.length; i++) {
										var local_army = usr.armies[usr.armies.army_array[i]];
										
										//Check if the army has units
										var has_units = false;
										for (var x = 0; x < config.units.length; x++) {
											has_units = (local_army[config.units[x]] > 0) ? true : has_units;
										}
										
										if (local_army.type == "army" && has_units) {
											if (usr.ignore_orders_when_carpet_sieging || local_army.order == "stationed") acceptable_armies.push(local_army.name);
										}
									}
								}
								
								//Begin moving armies
								var nonexistent_armies = 0;
								var missing_armies = 0;
								var failed_moves = 0;
								var successful_moves = 0;
								
								var targets_to_remove = [];
								for (var i = 0; i < occupation_target_list.length; i++) {
									try {
										var local_army = getArmy(user_id, acceptable_armies[i]);
										
										if (local_army) {
											var army_status = moveArmy(user_id, "none", local_army.name, occupation_target_list[i]);
											
											if (army_status != "moving") {
												failed_moves++;
											} else {
												successful_moves++;
											}
											
											targets_to_remove.push(occupation_target_list[i]);
										} else {
											nonexistent_armies++;
										}
									} catch (e) {
										console.log(e);
										missing_armies++;
									}
								}
								
								//Remove targets_to_remove from occupation_target_list
								for (var i = 0; i < targets_to_remove.length; i++) for (var x = 0; x < occupation_target_list.length; x++) if (occupation_target_list[x] == targets_to_remove[i]) occupation_target_list.splice(x, 1);
								
								var required_armies = occupation_target_list.length-(usr.armies.army_array.length-successful_moves-failed_moves);
								
								//Print out error/success message
								var ending_msg = (failed_moves > 0 || missing_armies > 0) ? "**" + parseNumber(nonexistent_armies) + "** of the armies specified could not be found, and **" + parseNumber(failed_moves) + "** failed to move to their destinations. " : "all managed to successfully move to their destinations. ";
								var fully_occupied = (occupation_target_list.length > 0) ? "**" + parseNumber(missing_armies) + "** remaining armies are required to be created for the full occupation of **" + ot_user.name + "** out of **" + parseNumber(ot_user.provinces) + "** total." : "**" + ot_user.name + "** will be fully occupied when all units arrive at their destination.";
								
								msg.channel.send("You have successfully begun sending out **" + parseNumber(successful_moves) + "** armies to occupy **" + ot_user.name + "**.\n\nOf the **" + parseNumber(acceptable_armies.length) + "** total armies sent out, " + ending_msg + fully_occupied);
							} else {
								msg.channel.send("You are currently not in a state of war with **" + ot_user.name + "**! Declare war first before trying to siege their entire country.");
							}
						} else {
							msg.channel.send("The user you are trying to siege down, **" + target_id + "**, proved to be just beyond the edges of the known world!");
						}
					} else {
						msg.channel.send("You can't just start sieging down other people if you don't even have a nation of your own!");
					}
				}
				
				function createArmies (arg0_user, arg1_string, arg2_msg) {
					//Convert from parameters
					var user_id = arg0_user;
					var usr = (main.users[arg0_user]) ? main.users[arg0_user] : undefined;
					var army_creation_string = arg1_string;
					var msg = arg2_msg;
					
					//Make sure that user is defined before supporting the mass creation of armies
					if (usr != undefined) {
						var new_army_array = parseOrdinals(army_creation_string);
						
						if (new_army_array.length <= config.max_army_creation_limit || config.max_army_creation_limit == 0) {
							//Make sure users can't exceet the maximum army limit set in config
							if (new_army_array.length+usr.armies.army_array.length <= config.max_army_limit || config.max_army_limit == 0) {
								if (new_army_array.length > 0) {
									for (var i = 0; i < new_army_array.length; i++) {
										newArmy(user_id, "none", new_army_array[i]);
									}
									msg.channel.send("You have successfully created up to **" + parseNumber(new_army_array.length) + "** new armies in Province **" + usr.capital_id.toString() + "**!");
								} else {
									msg.channel.send("The input you have entered proved to be invalid! Try creating more than **0** valid armies, and check your spelling and formatting.");
								}
							} else {
								msg.channel.send("You have already reached the maximum army limit of **" + parseNumber(config.max_army_limit) + "**! You can only create up to **" + parseNumber(config.max_army_limit-usr.armies.army_array.length) + "**, whilst you attempted to create up to **" + parseNumber(new_army_array.length) + "** new armies.");
							}
						} else {
							msg.channel.send("You can only create up to a maximum of **" + parseNumber(config.max_army_creation_limit) + "** armies at once!");
						}
					} else {
						msg.channel.send("You must have a nation before you can start turning out armies left and right!");
					}
				}
				
				function deleteAllArmies (arg0_user, arg1_msg) {
					//Convert from parameters
					var user_id = arg0_user;
					var usr = (main.users[arg0_user]) ? main.users[arg0_user] : undefined;
					var msg = arg1_msg;
					
					//Make sure user is defined before purging all armies
					if (usr != undefined) {
						if (usr.armies.army_array.length > 0) {
							//Begin removing all armies
							var old_army_count = usr.armies.army_array.length;
							
							while (true) {
								if (usr.armies.army_array.length > 0) {
									for (var i = 0; i < usr.armies.army_array.length; i++) {
										var local_army = usr.armies[usr.armies.army_array[i]];
										deleteArmy(user_id, "none", local_army.name);
									}
								} else {
									break;
								}
							}
							
							msg.channel.send("You have successfully deleted all of your **" + parseNumber(old_army_count) + "** armies. Their men and materiel have been returned to your reserves.\n\nTo mass-create new armies, type `" + bot_prefix + "create-armies`. To create an individual army unit, type `" + bot_prefix + "create-army`.");
						} else {
							msg.channel.send("You currently have no armies in active service!");
						}
					} else {
						msg.channel.send("You can't have armies without a state!");
					}
				}
				
				function deleteArmies (arg0_user, arg1_string, arg2_msg) {
					//Convert from parameters
					var user_id = arg0_user;
					var usr = (main.users[arg0_user]) ? main.users[arg0_user] : undefined;
					var army_deletion_string = arg1_string;
					var msg = arg2_msg;
					
					//Make sure user is defined before attempting to delete armies
					if (usr != undefined) {
						if (usr.armies.army_array.length > 0) {
							var new_army_array = parseOrdinals(army_deletion_string);
							
							//Get old_army_count so that we can display how many armies were successfully deleted out of the request
							var old_army_count = usr.armies.army_array.length;
							if (new_army_array.length > 0) {
								//Remove the actual armies by running the deleteArmy command
								for (var i = 0; i < new_army_array.length; i++) {
									deleteArmy(user_id, "none", new_army_array[i]);
								}
								
								//Return success/error messages
								if (old_army_count == usr.armies.army_array.length) {
									msg.channel.send("No armies of the specified name(s) could be found! Please check your spelling and formatting.");
								} else {
									var end_suffix = (old_army_count-usr.armies.army_array.length != new_army_array.length) ? "**" + parseNumber(new_army_array.length-(old_army_count-usr.armies.army_array.length)) + "** failed to be deleted, or could not be found." : "";
									msg.channel.send("You have successfully deleted **" + parseNumber(old_army_count-usr.armies.army_array.length) + "**/**" + parseNumber(old_army_count) + "** total armies. Their men and materiel have been returned to your reserves.\n" + end_suffix);
								}
							} else {
								msg.channel.send("You have specified invalid army input(s)! Please check your spelling and formatting.");
							}
						} else {
							msg.channel.send("You currently have no active armies in service, empty or not!");
						}
					} else {
						msg.channel.send("You don't even have armies in the first place due to your lack of a country!");
					}
				}
				
				function garrisonCities (arg0_user, arg1_string, arg2_msg) {
					//Convert from parameters
					var user_id = arg0_user;
					var usr = (main.users[arg0_user]) ? main.users[arg0_user] : undefined;
					var army_list = parseOrdinals(arg1_string);
					var msg = arg2_msg;
					
					//Check to see if user is defined
					if (usr) {
						if (usr.cities.city_array.length > 0) {
							//Begin moving armies
							var nonexistent_armies = 0;
							var missing_armies = 0;
							var failed_moves = 0;
							var successful_moves = 0;
							var total_cities = 0;
							
							for (var i = 0; i < army_list.length; i++) {
								//Fetch target city index to divide armies evenly
								var target_city_index = 0;
								for (var x = 1; x < usr.cities.city_array.length+1; x++) {
									target_city_index = (i % x == 0) ? x-1 : target_city_index;
								}
								
								try {
									var local_army = getArmy(user_id, army_list[i]);
									
									if (local_army) {
										var army_status = moveArmy(user_id, "none", local_army.name, usr.cities[usr.cities.city_array[i]].province);
										
										if (army_status != "moving") {
											failed_moves++;
										} else {
											successful_moves++;
										}
									} else {
										nonexistent_armies++;
									}
								} catch {
									missing_armies++;
								}
							}
							
							//Print out error/success message
							var ending_msg = (failed_moves > 0 || missing_armies > 0) ?
								"**" + parseNumber(nonexistent_armies) + "** of the armies specified could not be found, and **" + parseNumber(failed_moves) + "** failed to move to their destinations. " : 
								"all managed to successfully moved to their destinations. ";
							var fully_garrisoned = (successful_moves < usr.cities.city_array.length) ? 
								"**" + parseNumber(missing_armies) + "** remaining armies are required to be created for the full garrisoning of all **" + parseNumber(usr.cities.city_array.length) + "** cities underneath your control." : 
								"All **" + parseNumber(usr.cities.city_array.length) + "** cities currently under your control will be garrisoned by **" + parseNumber(successful_moves) + "** armies.";
								
							msg.channel.send("You have successfully begun sending out **" + parseNumber(successful_moves) + "** armies to guard your cities.\n\nOf the **" + parseNumber(army_list.length-nonexistent_armies) + "** total armies sent out, " + ending_msg + fully_garrisoned);
						} else {
							msg.channel.send("You might as well try guarding Atlantis with that amount of cities.");
						}
					} else {
						msg.channel.send("You can't guard any cities if you don't have any cities to begin with!");
					}
				}
				
				function garrisonProvinces (arg0_user, arg1_string, arg2_msg) {
					//Convert from parameters
					var user_id = arg0_user;
					var usr = (main.users[arg0_user]) ? main.users[arg0_user] : undefined;
					var army_list = parseOrdinals(arg1_string);
					var msg = arg2_msg;
					
					//Check to see if user is defined
					if (usr) {
						if (usr.pops.pop_array.length > 0) {
							//Begin moving armies
							var nonexistent_armies = 0;
							var missing_armies = 0;
							var successful_moves = 0;
							var failed_moves = 0;
							var total_cities = 0;
							
							for (var i = 0; i < army_list.length; i++) {
								//Fetch target city index to divide armies evenly
								var target_province_index = 0;
								for (var x = 1; x < usr.pops.pop_array.length+1; x++) {
									target_province_index = (i % x == 0) ? x-1 : target_province_index;
								}
								
								try {
									var local_army = getArmy(user_id, army_list[i]);
									
									if (local_army) {
										var army_status = moveArmy(user_id, "none", local_army.name, usr.pops.pop_array[target_province_index]);
										
										if (army_status != "moving") {
											failed_moves++;
										} else {
											successful_moves++;
										}
									} else {
										nonexistent_armies++;
									}
								} catch {
									missing_armies++;
								}
							}
							
							//Print out error/success message
							var ending_msg = (failed_moves > 0 || missing_armies > 0) ?
								"**" + parseNumber(nonexistent_armies) + "** of the armies specified could not be found, and **" + parseNumber(failed_moves) + "** failed to move to their destinations. " : 
								"all managed to successfully moved to their destinations. ";
							var fully_garrisoned = (successful_moves < usr.cities.city_array.length) ? 
								"**" + parseNumber(missing_armies) + "** remaining armies are required to be created for the full garrisoning of all **" + parseNumber(usr.provinces) + "** province(s) underneath your control." : 
								"All **" + parseNumber(usr.provinces) + "** province(s) currently under your control will be garrisoned by **" + parseNumber(successful_moves) + "** armies.";
								
							msg.channel.send("You have successfully begun sending out **" + parseNumber(successful_moves) + "** armies to guard your cities.\n\nOf the **" + parseNumber(army_list.length-nonexistent_armies) + "** total armies sent out, " + ending_msg + fully_garrisoned);
						} else {
							msg.channel.send("You can't guard imaginary provinces!");
						}
					} else {
						msg.channel.send("You can't guard any provinces if you don't even have a country!");
					}
				}
				
				function massDeploy (arg0_user, arg1_armies_string, arg2_amount, arg3_unit_type, arg4_msg) {
					//Convert from parameters
					var user_id = arg0_user;
					var usr = (main.users[arg0_user]) ? main.users[arg0_user] : undefined;
					var armies_string = arg1_armies_string;
					var raw_unit_amount = arg2_amount;
					var unit_amount = (!isNaN(parseInt(arg2_amount))) ? parseInt(arg2_amount) : undefined;
					var raw_unit_type = arg3_unit_type;
					var unit_type = (returnCrafting(arg3_unit_type.toLowerCase()) != "invalid") ? returnCrafting(arg3_unit_type.toLowerCase()) : undefined;
					var msg = arg4_msg;
					
					//Check to see if user is defined
					if (usr != undefined) {
						if (unit_amount) {
							if (unit_type) {
								var deploy_in_armies = parseOrdinals(armies_string);
								
								if (deploy_in_armies.length > 0) {
									//Get old number of units in reserves, and compare it to the new number to see how many units have been successfully deployed
									var old_unit_count = usr.military[unit_type];
									
									for (var i = 0; i < deploy_in_armies.length; i++) {
										editArmy(usr.id, "none", deploy_in_armies[i], unit_amount, unit_type, ["add"]);
									}
									
									var new_unit_count = usr.military[unit_type];
									var successful_deployments = old_unit_count-new_unit_count;
									
									//Return success/error messages
									if (successful_deployments != 0) {
										msg.channel.send("You have successfully deployed up to **" + parseNumber(successful_deployments) + "** " + unit_type + " in **" + parseNumber(deploy_in_armies.length) + "** armies.");
									} else {
										msg.channel.send("The armies you have specified could not be found! Please double-check spelling and type `" + bot_prefix + "army-list` for a full list of your armies.");
									}
								} else {
									msg.channel.send("The names you have specified could not turn up any valid armies! Please check your spelling and formatting and try again.");
								}
							} else {
								msg.channel.send("**" + raw_unit_type + "** could not be recognised as a valid unit type! Type `" + bot_prefix + "reserves` for a list of units that you can deploy.");
							}
						} else {
							msg.channel.send("Please enter a valid number of units! **" + raw_unit_amount + "** was not recognised as a valid number.");
						}
					} else {
						msg.channel.send("You can't just start mass deploying troops out of nowhere! Found a nation first.");
					}
				}
				
				function massRelieve (arg0_user, arg1_armies_string, arg2_amount, arg3_unit_type, arg4_msg) {
					//Convert from parameters
					var user_id = arg0_user;
					var usr = (main.users[arg0_user]) ? main.users[arg0_user] : undefined;
					var armies_string = arg1_armies_string;
					var raw_unit_amount = arg2_amount;
					var unit_amount = (!isNaN(parseInt(arg2_amount))) ? parseInt(arg2_amount) : undefined;
					var raw_unit_type = arg3_unit_type;
					var unit_type = (returnCrafting(arg3_unit_type.toLowerCase()) != "invalid") ? returnCrafting(arg3_unit_type.toLowerCase()) : undefined;
					var msg = arg4_msg;
					
					//Check to see if user is defined
					if (usr != undefined) {
						if (unit_amount) {
							if (unit_type) {
								var withdraw_from_armies = parseOrdinals(armies_string);
								
								if (withdraw_from_armies.length > 0) {
									//Get old number of units in reserves, and compare it to the new number to see how many units have been successfully deployed
									var old_unit_count = usr.military[unit_type];
									
									for (var i = 0; i < withdraw_from_armies.length; i++) {
										editArmy(usr.id, "none", withdraw_from_armies[i], unit_amount, unit_type, ["remove"]);
									}
									
									var new_unit_count = usr.military[unit_type];
									var successfully_withdrawn = new_unit_count-old_unit_count;
									
									//Return success/error messages
									if (successfully_withdrawn != 0) {
										msg.channel.send("You have successfully withdrawn up to **" + parseNumber(successfully_withdrawn) + "** " + unit_type + " from **" + parseNumber(withdraw_from_armies.length) + "** armies, and placed them back in your reserves.");
									} else {
										msg.channel.send("The armies you have specified could not be found! Please double-check spelling and type `" + bot_prefix + "army-list` for a full list of your armies.");
									}
								} else {
									msg.channel.send("The names you have specified could not turn up any valid armies! Please check your spelling and formatting and try again.");
								}
							} else {
								msg.channel.send("**" + raw_unit_type + "** could not be recognised as a valid unit type! Type `" + bot_prefix + "reserves` for a list of units that you can deploy.");
							}
						} else {
							msg.channel.send("Please enter a valid number of units! **" + raw_unit_amount + "** was not recognised as a valid number.");
						}
					} else {
						msg.channel.send("You can't just start mass deploying troops out of nowhere! Found a nation first.");
					}
				}
				
				function mergeArmies (arg0_user, arg1_merging_armies, arg2_merged_army, arg3_msg) {
					//Convert from parameters
					var user_id = arg0_user;
					var usr = (main.users[arg0_user]) ? main.users[arg0_user] : undefined;
					var merging_armies_string = arg1_merging_armies;
					var merging_army_string = arg2_merged_army;
					var msg = arg3_msg;
					
					//Make sure user is defined before attempting to merge armies
					if (usr != undefined) {
						if (usr.armies.army_array.length > 0) {
							var merging_armies_array = parseOrdinals(merging_armies_string);
							
							//Get old_army_count so that we can calculate and display any errors that may occur with merging_armies_array
							var old_army_count = JSON.parse(usr.armies.army_array.length);
							if (merging_armies_array.length > 0) {
								//Begin attempting to merge armies
								for (var i = 0; i < merging_armies_array.length; i++) {
									mergeArmy(user_id, "none", merging_army_string, merging_armies_array[i]);
								}
								
								//How many armies were successfully merged?
								var successfully_merged = (old_army_count-usr.armies.army_array.length);
								
								//Display user success/error messages
								if (old_army_count == usr.armies.army_array.length) {
									msg.channel.send("Your Military High Command were unable to merge all the specified armies into the **" + merging_army_string + "**! Make sure to check your spelling and formatting before trying again.");
								} else {
									var army_string = (getArmy(user_id, merging_army_string)) ? " into the **" + getArmy(user_id, merging_army_string).name + "**": "";
									msg.channel.send("You have successfully merged **" + parseNumber(successfully_merged) + "**/**" + parseNumber(merging_armies_array.length) + "** total requested armies" + army_string + ".");
								}
							} else {
								msg.channel.send("No armies of the specified name(s) could be found! Please check your spelling and formatting before trying again.");
							}
						} else {
							msg.channel.send("You currently don't have any active armies in serice that you can merge! Create some new ones either by typing `" + bot_prefix + "create-armies` to create multiple armies, or by typing `" + bot_prefix + "create-army` to create an individual army unit.");
						}
					} else {
						msg.channel.send("You can't have any armies deployed in the field if you don't have a nation, let alone merge them ro give them orders!");
					}
				}
				
				function mergeArmy (arg0_user, arg1_msg, arg2_name, arg3_name) {
					//Convert from parameters
					var user_id = arg0_user;
					var msg = arg1_msg;
					var merging_into_army_string = arg2_name;
					var merging_army_string = arg3_name;
					
					//Check to see that user isn't undefined
					if (main.users[arg0_user] != undefined) {
						var usr = main.users[arg0_user];
						//Check if armies exist
						var army1_exists = [false, ""];
						var army2_exists = [false, ""];
						var fatal_error = [false, ""];
						
						//arg2_name - Army 1, Army to merge into
						//arg3_name - Army 2, Army to merge
						
						//Check if either armies exist
						army1_exists = (getArmy(user_id, merging_into_army_string)) ? [true, getArmy(user_id, merging_into_army_string)] : [false, ""];
						army2_exists = (getArmy(user_id, merging_army_string)) ? [true, getArmy(user_id, merging_army_string)] : [false, ""];
						
						
						var aeroplane_capacity = 0;
						var aeroplane_count = 0;
						var total_units = 0;
						if (army1_exists[0] && army2_exists[0]) {
							console.log("ARMIES EXIST!");
							//Army computations: potential errors if user is trying to merge (navy, air);
							//Get aeroplane capacity of first army
							for (var i = 0; i < config.units.length; i++) {
								total_units += army1_exists[1][config.units[i]];
								total_units += total_units + army2_exists[1][config.units[i]];
								if (config.unit_stats[config.units[i]].carrier_capacity != undefined) {
									aeroplane_capacity += army1_exists[1][config.units[i]]*config.unit_stats[config.units[i]].carrier_capacity;
									aeroplane_capacity += army2_exists[1][config.units[i]]*config.unit_stats[config.units[i]].carrier_capacity;
								}
							}
							for (var i = 0; i < config.aeroplanes.length; i++) {
								aeroplane_count += army1_exists[1][config.aeroplanes[i]];
								aeroplane_count += army2_exists[1][config.aeroplanes[i]];
							}
							if ((army1_exists[1].type == "air force" && army2_exists[1].type == "navy") || (army1_exists[1].type == "navy" && army2_exists[1].type == "air force")) {
								if (aeroplane_capacity == 0) {
									fatal_error = [true, "You don't have any ships capable of carrying aircraft in the fleet you are trying to merge to!"];
								} else if (aeroplane_count > aeroplane_capacity) {
									fatal_error = [true, "You don't have enough air capacity in the fleet you are trying to merge to! Consider assigning another aircraft carrier to your fleet."];
								}
							} else if ((army1_exists[1].type == "army" && army2_exists[1].type == "navy") || (army1_exists[1].type == "navy" && army2_exists[1].type == "army")) {
								fatal_error = [true, "Your ships are not capable of going on land!"];
							}
							
							if (fatal_error[0] == false) {
								//Merge the two armies
								for (var i = 0; i < config.units.length; i++) {
									army1_exists[1][config.units[i]] += army2_exists[1][config.units[i]];
									army2_exists[1][config.units[i]] = 0;
								}
								
								//Delete army2
								if (msg != "none") {
									msg.channel.send("The **" + army2_exists[1].name + "** was merged into the **" + army1_exists[1].name + "**.");
								}
								
								deleteArmy(arg0_user, "none", army2_exists[1].name);
							} else {
								if (msg != "none") {
									msg.channel.send(fatal_error[1]);
								}
							}
						} else {
							if (msg != "none") {
								msg.channel.send("One of the armies you have specified did not exist!");
							}
						}
					} else {
						if (msg != "none") {
							msg.channel.send("You are trying to merge two nonexistent armies from a nonexistent country!");
						}
					}
				}
				
				function moveAllArmies (arg0_user, arg1_msg, arg2_province) {
					//Convert from parameters
					var msg = arg1_msg;
					var province_id = arg2_province;
					
					if (main.users[arg0_user] != undefined) {
						var usr = main.users[arg0_user];
						
						if (usr.armies.army_array.length > 0) {
							for (var i = usr.armies.army_array.length-1; i >= 0; i--) {
								var local_army = usr.armies[usr.armies.army_array[i]];
								
								moveArmy(usr.id, "none", local_army.name, province_id);
							}
							msg.channel.send("You have begun moving **" + parseNumber(usr.armies.army_array.length) + "** armies to Province **" + province_id + "**, wherever possible.");
						} else {
							msg.channel.send("You don't have any armies currently deployed!");
						}
					} else {
						msg.channel.send("You don't even have a country!");
					}
				}
				
				function moveArmies (arg0_user, arg1_string, arg2_province, arg3_msg) {
					//Convert from parameters
					var user_id = arg0_user;
					var usr = (main.users[arg0_user]) ? main.users[arg0_user] : undefined;
					var armies_string = arg1_string;
					var prov_id = arg2_province;
					var msg = arg3_msg;
					
					//Check to see that user isn't undefined
					if (usr != undefined) {
						if (usr.armies.army_array.length > 0) {
							var moving_armies = parseOrdinals(armies_string);
							
							if (moving_armies.length > 0) {
								var successfully_moved_armies = 0;
								for (var i = 0; i < moving_armies.length; i++) {
									var local_army = getArmy(user_id, moving_armies[i]);
									try {
										var return_order = moveArmy(user_id, "none", local_army.name, prov_id);
										
										successfully_moved_armies = (["hold", "moving"].includes(return_order)) ? successfully_moved_armies + 1 : successfully_moved_armies;
									} catch {}
								}
								msg.channel.send("You have begun successfully moving **" + parseNumber(successfully_moved_armies) + "**/**" + parseNumber(moving_armies.length) + "** requested armies to their destination, Province **" + prov_id + "**.\n\nDifferent armies may arrive at different times. Type `" + bot_prefix + "army` to see when an army will arrive a given province.");
							} else {
								msg.channel.send("You can't move a bunch of nonexistent armies around! Check your spelling and formatting first.");
							}
						} else {
							msg.channel.send("You don't even have any armies to move around!");
						}
					} else {
						msg.channel.send("You can't start moving armies without a military!");
					}
				}
				
				function moveArmy (arg0_user, arg1_msg, arg2_name, arg3_province) {
					//Convert from parameters
					var user_id = arg0_user;
					var msg = arg1_msg;
					var army_name = arg2_name;
					var province_id = arg3_province;
					
					if (main.users[arg0_user] != undefined) {
						var usr = main.users[arg0_user];
						var army_exists = [false, ""];
						
						//Check if army exists
						for (var i = usr.armies.army_array.length-1; i >= 0; i--) {
							if (usr.armies[usr.armies.army_array[i]].name.toLowerCase().indexOf(arg2_name.toLowerCase()) != -1) {
								army_exists = [true, usr.armies.army_array[i]];
							}
						}
						
						for (var i = usr.armies.army_array.length-1; i >= 0; i--) {
							if (usr.armies[usr.armies.army_array[i]].name.toLowerCase() == arg2_name.toLowerCase()) {
								army_exists = [true, usr.armies.army_array[i]];
							}
						}
						
						if (army_exists[0]) {
							if (arg2_name != "deleted-army") {
								//Check if army can move
								if (usr.armies[army_exists[1]].can_move[0]) {
									//Check if army has anyone in it
									var has_at_least_one_unit = false;
									for (var i = 0; i < config.units.length; i++) {
										if (usr.armies[army_exists[1]][config.units[i]] > 0) {
											has_at_least_one_unit = true;
										}
									}
									
									if (has_at_least_one_unit) {
										//Check if province exists
										if (usr.armies[army_exists[1]].type == "army" || usr.armies[army_exists[1]].type == "air force") {
											if (parseInt(arg3_province) > config.min_provinces && parseInt(arg3_province) < config.max_provinces) {
												if (parseInt(arg3_province) != usr.armies[army_exists[1]].province) {
													var new_moving_to = smartMove(user_id, usr.armies[army_exists[1]].name, province_id);
													
													if (new_moving_to) {
														usr.armies[army_exists[1]].moving_to = smartMove(user_id, usr.armies[army_exists[1]].name, province_id);
														console.log("New Moving To String:");
														console.log(usr.armies[army_exists[1]].moving_to);
														var time_to_arrival = Math.ceil(usr.armies[army_exists[1]].moving_to.length/(config.army_speed*usr.modifiers.army_travel_speed));
														if (msg != "none") {
															msg.channel.send("The **" + usr.armies[army_exists[1]].name + "** is now en route to Province **" + arg3_province + "**. It will arrive in approximately **" + time_to_arrival + "** turns.");
														}
														
														//Set status and orders
														usr.stationary_turns = 0;
														usr.armies[army_exists[1]].order = "moving";
														usr.armies[army_exists[1]].state = "moving";
														
														return "moving";
													} else {
														if (msg != "none") {
															msg.channel.send("The **" + usr.armies[army_exists[1]].name + "** was not able to move to the province you have specified! Check your `" + bot_prefix + "military-headquarters` to better adjust your movement options if you still wish to move your army here.");
														}
													}
												} else {
													usr.armies[army_exists[1]].moving_to = [];
													if (msg != "none") {
														msg.channel.send("You have ordered the **" + usr.armies[army_exists[1]].name + "** to remain still.");
													}
													usr.stationary_turns = 0;
													usr.armies[army_exists[1]].state = "stationed";
													usr.armies[army_exists[1]].order = "stationed";
													
													return "hold";
												}
											} else {
												if (msg != "none") {
													msg.channel.send("You must enter a valid province ID between **0** and **" + config.max_provinces + "**!");
												}
											}
										} else {
											if (msg != "none") {
												msg.channel.send("You can't move navies around on dry land!");
											}
										}
									} else {
										if (msg != "none") {
											msg.channel.send("You can't move around empty armies!");
										}
									}
								} else {
									if (msg != "none") {
										msg.channel.send("The army you have specified cannot move at the current time! It can move again in **" + usr.armies[army_exists[1]].can_move[1] + "** turns.");
									}
								}
							} else {
								if (msg != "none") {
									msg.channel.send("You can't move a deleted army!");
								}
							}
						} else {
							if (msg != "none") {
								msg.channel.send("No army by the name of **" + arg2_name + "** could be found!");
							}
						}
					} else {
						if (msg != "none") {
							msg.channel.send("You don't even have a country!");
						}
					}
				}
			
				function splitArmies (arg0_user, arg1_original_army, arg2_string, arg3_msg) {
					//Convert from parameters
					var user_id = arg0_user;
					var usr = (main.users[arg0_user]) ? main.users[arg0_user] : undefined;
					var original_army_name = arg1_original_army;
					var armies_string = arg2_string;
					var msg = arg3_msg;
					
					//Check to see if user is defined
					if (usr != undefined) {
						if (usr.armies.army_array.length > 0) {
							//Check if original army is valid
							var original_army_obj = getArmy(original_army_name);
							
							if (original_army_obj) {
								//Check to see if armies_string is valid or not
								var new_armies = parseOrdinals(armies_string);
								var successful_army_creations = 0;
								
								if (new_armies.length > 0) {
									if (new_armies.length <= config.max_army_creation_limit) {
										for (var i = 0; i < new_armies.length; i++) {
											var new_army_created = splitArmy(usr.id, msg, original_army_obj, new_armies[i]);
											if (new_army_created == "army_created") {
												successful_army_creations++;
											}
										}
										
										//Error/success return message
										if (successful_army_creations != 0) {
											var army_limit_suffix = (successful_army_creations != new_armies.length) ? "The remaining request of **" + parseNumber(new_armies.length-successful_army_creations) + "** armies exceeded your maximum army limit of **" + parseNumber(config.max_army_limit) + "**, and could therefore not be created." : "";
											
											msg.channel.send("You have successfully split off **" + parseNumber(successful_army_creations) + "** armies from the **" + original_army_obj.name + "**. " + army_limit_suffix);
										} else {
											msg.channel.send("No new armies could be split off from the **" + original_army_obj.name + "** due to having reached the maximum army limit of **" + parseNumber(config.max_army_limit) + "**!");
										}
									} else {
										msg.channel.send("You may only split off up to **" + parseNumber(config.max_army_creation_limit) + "** amrmies at once, whilst you specified up to **" + new_armies.length + "** armies for immediate creation!");
									}
								} else {
									msg.channel.send("The armies you have specified could not be created! Please check your formatting and numbering before trying again, or use `" + bot_prefix + "create-army` to create a single new army.");
								}
							} else {
								msg.channel.send("The army you have specified, **" + original_army_obj + "**, could not be found! Please check your spelling and spaces before attempting to split off armies from this unit again.");
							}
						} else {
							msg.channel.send("You currently have no active armies deployed in the field! Try to create a new empty army by typing out `" + bot_prefix + "create-army` and deploying troops in it before attempting this command again.");
						}
					} else {
						msg.channel.send("You can't start splitting off armies from nothing!");
					}
				}
			}
			
			//Naval order functions
			{
				function blockade (arg0_user, arg1_user, arg2_name, arg3_mode, arg4_msg) {
					//Convert from parameters
					var user_id = arg0_user;
					var ot_user_id = arg1_user;
					var fleet_name = arg2_name;
					var mode = arg3_mode;
					var msg = arg4_msg;
					
					if (main.users[arg0_user] != undefined) {
						var usr = main.users[arg0_user];
						
						if (main.users[arg1_user] != undefined) {
							var ot_user = main.users[arg1_user];
							var fleet_exists = [false, ""];
							
							//Find fleet, soft match first, hard match last
							for (var i = usr.armies.army_array.length; i--;) {
								if (usr.armies[usr.armies.army_array[i]].name.toLowerCase().indexOf(arg2_name.toLowerCase()) != -1) {
									if (usr.armies[usr.armies.army_array[i]].type == "navy") {
										fleet_exists = [true, usr.armies.army_array[i]];
									}
								}
							}
							
							for (var i = usr.armies.army_array.length; i--;) {
								if (usr.armies[usr.armies.army_array[i]].name.toLowerCase() == arg2_name.toLowerCase()) {
									if (usr.armies[usr.armies.army_array[i]].type == "navy") {
										fleet_exists = [true, usr.armies.army_array[i]];
									}
								}
							}
							
							console.log("Fleet exists: " + fleet_exists);
							
							if (fleet_exists[0]) {
								if (arg3_mode == "add") {
									var fleet_already_in_blockade = false;
									var all_blockades = Object.keys(main.users.global.blockades);
									
									for (var i = 0; i < all_blockades.length; i++) {
										for (var x = 0; x < main.users.global.blockades[all_blockades[i]].length; x++) {
											if (main.users.global.blockades[all_blockades[i]][x] == fleet_exists[1]) {
												fleet_already_in_blockade = true;
											}
										}
									}
									
									if (fleet_already_in_blockade == false) {
										if (usr.blockaded == false) {
											if (user_id != ot_user_id) {
												if (usr.armies[fleet_exists[1]].blockade_recovery_turns == 0) {
													if (main.users.global.blockades[arg1_user] == undefined) {
														if (usr["blockade_cooldown_" + arg1_user] == undefined) {
															if (usr.enable_blockades) {
																main.users.global.blockades[arg1_user] = [fleet_exists[1]];
																main.users.global.blockade_arrays[arg1_user] = [arg0_user];
																msg.channel.send("You have instituted a blockade on <@" + arg1_user + ">. They may challenge it any time by typing `" + bot_prefix + "challenge-blockade`.");
																returnChannels.send(war_channel, "**A blockade was instituted on <@" + arg1_user + "> by <@" + arg0_user + ">.**");
																main.users[arg1_user].blockaded = true;
																usr.armies[fleet_exists[1]].state = "blockading";
																usr.armies[fleet_exists[1]].order = "blockading";
																
																//Check if users are already at war, if not, give the blockaded user the 'Theft' CB.
																var already_at_war = false;
																if (usr.at_war.length > 0) {
																	for (var i = 0; i < usr.at_war.length; i++) {
																		if (usr.at_war[i] == main.users[arg1_user].name) {
																			already_at_war = true;
																		}
																	}
																}
																
																if (already_at_war == false) {
																	returnChannels.send(war_channel, "They have gained <:infamy:716817688453709905> 5 infamy from this action, as **" + usr.name + "** was not in a state of war with **" + ot_user.name + "** at the time of the blockade!");
																	ot_user.casus_belli.push(["theft", usr.id, 10]);
																	usr.infamy = usr.infamy + 5;
																	returnChannels.send(war_channel, "<@" + ot_user.id + "> has gained the **Theft** CB on <@" + usr.id + ">!");
																}
															} else {
																msg.channel.send("You have not unlocked the ability to blockade users yet! Research **Naval Blockades** in your tech tree first.");
															}
														} else {
															msg.channel.send("You have blockaded this user too recently to impose another blockade on them! Wait at least **" + usr["blockade_cooldown_" + arg1_user] + "** turns before trying again.");
														}
													} else {
														var already_at_war = false;
														if (usr.at_war.length > 0) {
															for (var i = 0; i < usr.at_war.length; i++) {
																if (usr.at_war[i] == main.users[arg1_user].name) {
																	already_at_war = true;
																}
															}
														}
														
														if (already_at_war) {
															main.users.global.blockades[arg1_user].push(fleet_exists[1]);
															main.users.global.blockade_arrays[arg1_user].push(arg0_user);
															msg.channel.send("You have assigned the **" + usr.armies[fleet_exists[1]].name + "** to reinforce the blockade on <@" + arg1_user + ">."); 
															usr.armies[fleet_exists[1]].state = "blockading **" + ot_user.name + "**";
														} else {
															msg.channel.send("You can't reinforce a blockade of someone you're not at war with!");
														}
													}
												} else {
													msg.channel.send("The fleet you have specified is still recovering from a previous blockade! Wait at least **" + usr.armies[fleet_exists[1]].blockade_recovery_turns + "** more turns before sending them back out again.");
												}
											} else {
												msg.channel.send("You can't impose a blockade on yourself!");
											}
										} else {
											msg.channel.send("You can't blockade other users whilst blockaded!");
										}
									} else {
										msg.channel.send("The fleet you have specified is already instituting a blockade!");
									}
								} else if (arg3_mode == "remove") {
									if (main.users.global.blockades[arg1_user] != undefined) {
										var fleet_in_blockade_array = false;
										var fleet_index = 0;
										for (var i = 0; i < main.users.global.blockades[arg1_user].length; i++) {
											if (main.users.global.blockades[arg1_user][i] == fleet_exists[1]) {
												fleet_in_blockade_array = true;
												fleet_index = i;
											}
										}
										
										if (fleet_in_blockade_array) {
											if (main.users.global.blockades[arg1_user].length > 1) {
												main.users.global.blockades[arg1_user].splice(fleet_index, 1);
												main.users.global.blockade_arrays.splice(fleet_index, 1);
												msg.channel.send("You have withdrawn the **" + usr.armies[fleet_exists[1]].name + "** from the blockade on <@" + arg1_user + ">.");
											} else {
												delete main.users.global.blockades[arg1_user];
												msg.channel.send("You have ended your blockade on <@" + arg1_user + ">.");
												returnChannels.send(war_channel, "**The blockade on <@" + arg1_user + "> was lifted.**");
												usr["blockade_cooldown_" + arg1_user] = 3;
												main.users[arg1_user].blockaded = false;
											}
											usr.armies[fleet_exists[1]].state = "in harbour";
											usr.armies[fleet_exists[1]].order = "in harbour";
										} else {
											msg.channel.send("This fleet has already withdrawn from the blockade!");
										}
									} else {
										msg.channel.send("There is no blockade on this user, and traffic is flowing normally. To impose a blockade, type `" + bot_prefix + "blockade <@user>`.");
									}
								}
							} else {
								msg.channel.send("The fleet you have specified turned out to be nonexistent! Please check `" + bot_prefix + "army-list` to make sure you've spelled out the name correctly.");
							}
						} else {
							msg.channel.send("The user you are trying to blockade doesn't even have a country!");
						}
					} else {
						msg.channel.send("You must have a country first in order to blockade other users!");
					}
				}
				
				function challengeBlockade (arg0_user, arg1_user, arg2_name, arg3_msg) {
					var msg = arg3_msg;
					
					if (main.users[arg0_user] != undefined) {
						var usr = main.users[arg0_user];
						var fleet_exists = [false, ""];
						
						//Soft match first, hard match second
						for (var i = usr.armies.army_array.length; i--;) {
							if (usr.armies[usr.armies.army_array[i]].name.toLowerCase().indexOf(arg2_name.toLowerCase()) != -1) {
								if (usr.armies[usr.armies.army_array[i]].type == "navy") {
									fleet_exists = [true, usr.armies.army_array[i]];
								}
							}
						}
						for (var i = usr.armies.army_array.length; i--;) {
							if (usr.armies[usr.armies.army_array[i]].name.toLowerCase() == arg2_name.toLowerCase()) {
								if (usr.armies[usr.armies.army_array[i]].type == "navy") {
									fleet_exists = [true, usr.armies.army_array[i]];
								}
							}
						}
						
						if (main.users.global.blockades[arg1_user] != undefined) {
							if (fleet_exists[0]) {
								if (usr.armies[fleet_exists[1]].challenged_this_turn <= config.blockade_challenge_limit) {
									usr.armies[fleet_exists[1]].challenged_this_turn++;
									var random_navy = Math.floor(Math.random()*main.users.global.blockades[arg1_user].length);
									var random_navy_user = main.users.global.blockade_arrays[arg1_user][random_navy];
									var random_processed_navy_name = main.users[random_navy_user].armies[main.users.global.blockades[arg1_user][random_navy]].name;
									combat(random_navy_user, random_processed_navy_name, arg0_user, usr.armies[fleet_exists[1]].name, "sea", msg);
									msg.channel.send("**You have decided to challenge the blockade imposed on your nation ...**");
								} else {
									msg.channel.send("You can only challenge a blockade with the same fleet for up to **" + parseNumber(config.blockade_challenge_limit) + "** times this turn! Wait until next turn to challenge more blockades with this fleet.");
								}
							} else {
								msg.channel.send("The fleet you have specified could not be found!");
							}
						} else {
							msg.channel.send("There is currently no active blockade instituted on this user!");
						}
					} else {
						msg.channel.send("You must have a country in order to challenge blockades!");
					}
				}
				
				function submarineRaid (arg0_user, arg1_user, arg2_name, arg3_mode, arg4_msg) {
					var msg = arg4_msg;
					var mode = arg3_mode;
					
					//modes: ["convoy", "naval", "reserves"]
					
					if (main.users[arg0_user] != undefined) {
						var usr = main.users[arg0_user];
						
						if (main.users[arg1_user] != undefined) {
							var ot_user = main.users[arg1_user];
							var fleet_exists = [false, ""];
							
							//Soft match
							for (var i = usr.armies.army_array.length; i--;) {
								if (usr.armies[usr.armies.army_array[i]].name.toLowerCase().indexOf(arg2_name.toLowerCase()) != -1) {
									fleet_exists = [true, usr.armies.army_array[i]];
								}
							}
							//Hard match
							for (var i = usr.armies.army_array.length; i--;) {
								if (usr.armies[usr.armies.army_array[i]].name.toLowerCase() == arg2_name.toLowerCase()) {
									fleet_exists = [true, usr.armies.army_array[i]];
								}
							}
							
							if (fleet_exists[0]) {
								var has_navy = false;
								var navy_arrays = [];
								for (var i = 0; i < ot_user.armies.army_array.length; i++) {
									if (ot_user.armies[ot_user.armies.army_array[i]].type == "navy") {
										has_navy = true;
										navy_arrays.push(ot_user.armies.army_array[i]);
									}
								}
								
								if (has_navy) {
									var submarine_types = [];
									var destroyer_types = [];
									var cruiser_types = [];
									var helicopter_types = [];
									
									for (var i = 0; i < config.units.length; i++) {
										if (config.unit_stats[config.units[i]].submarine) {
											submarine_types.push(config.units[i]);
										}
									}
									for (var i = 0; i < config.units.length; i++) {
										if (config.unit_stats[config.units[i]].destroyer) {
											destroyer_types.push(config.units[i]);
										}
									}
									for (var i = 0; i < config.units.length; i++) {
										if (config.unit_stats[config.units[i]].cruiser) {
											cruiser_types.push(config.units[i]);
										}
									}
									for (var i = 0; i < config.units.length; i++) {
										if (config.unit_stats[config.units[i]].helicopter) {
											helicopter_types.push(config.units[i]);
										}
									}
									
									var pure_submarines = true;
									for (var i = 0; i < config.units.length; i++) {
										var is_submarine = false;
										for (var x = 0; x < submarine_types.length; x++) {
											if (config.units[i] == submarine_types[x]) {
												is_submarine = true;
											}
										}
										
										if (is_submarine == false) {
											if (usr.armies[fleet_exists[1]][config.units[i]] > 0) {
												pure_submarines = false;
											}
										}
									}
									
									if (pure_submarines) {
										var defender_ap = 0; //Sum up DP of all submarines, destroyers, and cruisers sitting in the selected scope. Cruisers count for half.
										var attacker_ap = 0;
										var submarines_lost = 0;
										
										//Calculate attacker AP
										for (var i = 0; i < usr.armies[fleet_exists[1]].length; i++) {
											for (var x = 0; x < submarine_types.length; x++) {
												attacker_ap = attacker_ap + usr.armies[fleet_exists[1]][submarine_types[x]]*config.unit_stats[submarine_types[x]].ap;
											}
										}
										
										var already_at_war = false;
										if (usr.at_war.length > 0) {
											for (var i = 0; i < usr.at_war.length; i++) {
												if (usr.at_war[i] == main.users[arg1_user].name) {
													already_at_war = true;
												}
											}
										}
										
										if (already_at_war) {
											if (usr.armies[fleet_exists[1]].submarine_cooldown == false) {
												if (mode == "convoy") { //Attacks a random import the user might have
													if (other_user.trade_array.length > 0) {
														for (var i = 0; i < ot_user.armies.army_array.length; i++) {
															for (var x = 0; x < submarine_types.length; x++) {
																defender_ap = defender_ap + ot_user.armies[ot_user.armies.army_array[i]][submarine_types[x]]*config.unit_stats[submarine_types[x]].ap;
															}
															for (var x = 0; x < destroyer_types.length; x++) {
																defender_ap = defender_ap + ot_user.armies[ot_user.armies.army_array[i]][destroyer_types[x]]*config.unit_stats[destroyer_types[x]].ap;
															}
															for (var x = 0; x < cruiser_types.length; x++) {
																defender_ap = defender_ap + Math.round(ot_user.armies[ot_user.armies.army_array[i]][cruiser_types[x]]*config.unit_stats[cruiser_types[x]].ap*0.5);
															}
															for (var x = 0; x < helicopter_types.length; x++) {
																defender_ap = defender_ap + ot_user.armies[ot_user.armies.army_array[i]][helicopter_types[x]]*config.unit_stats[helicopter_types[x]].ap;
															}
														}
														
														var succeed_chance = ((attacker_ap/defender_ap)*0.8)+0.2; //80% comes from the attacker to defender AP ratio, 20% base chance
														succeed_chance = succeed_chance*100;
														
														var random_chance = randomNumber(0, 100);
														
														if (random_chance <= succeed_chance) {
															//50-50 chance of losing a submarine or two
															submarines_lost = randomNumber(0,2);
															var submarines_lost_so_far = submarines_lost;
															var actual_sub_losses = 0;
															
															for (var i = 0; i < submarine_types.length; i++) {
																if (usr.armies[fleet_exists[1]][submarine_types[i]] > 0) {
																	if (usr.armies[fleet_exists[1]][submarine_types[i]] < submarines_lost) {
																		submarines_lost_so_far = submarines_lost_so_far + usr.armies[fleet_exists[1]][submarine_types[i]];
																		removePops(arg0_user, usr.armies[fleet_exists[1]][submarine_types[i]]*config.unit_stats[submarine_types[i]].manpower_cost, "soldiers");
																		usr.used_soldiers = usr.used_soldiers - usr.armies[fleet_exists[1]][submarine_types[i]]*config.unit_stats[submarine_types[i]].manpower_cost;
																		submarines_lost = submarines_lost - usr.armies[fleet_exists[1]][submarine_types[i]];
																		usr.armies[fleet_exists[1]][submarine_types[i]] = 0;
																	} else {
																		submarines_lost_so_far = submarines_lost_so_far + submarines_lost;
																		removePops(arg0_user, submarines_lost*config.unit_stats[submarine_types[i]].manpower_cost, "soldiers");
																		usr.used_soldiers = usr.used_soldiers - submarines_lost*config.unit_stats[submarine_types[i]].manpower_cost;
																		usr.armies[fleet_exists[1]][submarine_types[i]] + usr.armies[fleet_exists[1]][submarine_types[i]] - submarines_lost;
																		submarines_lost = 0;
																	}
																}
															}
															
															submarines_lost = submarines_lost_so_far;
															
															//Destroy random import
															var element_to_remove = Math.floor(Math.random()*other_user.trade_array.length);
															msg.channel.send("Your submarines intercepted a shipment of " + other_user.trade_array[element_to_remove][0][0] + " " + other_user.trade_array[element_to_remove][0][1] + " at the cost of **" + submarines_lost + "** of their own.");
															other_user.trade_array.splice(element_to_remove, 1);
														} else {
															//Failure, you just lose submarines
															var random_counter_roll = randomNumber(0, defender_ap);
															var submarines_lost = 0;
															
															for (var i = 0; i < submarine_types.length; i++) {
																if (usr.armies[fleet_exists[1]][submarine_types[i]]*config.unit_stats[submarine_types[i]].dp < random_counter_roll) {
																	submarines_lost = submarines_lost + usr.armies[fleet_exists[1]][submarine_types[i]];
																	random_counter_roll = random_counter_roll - usr.armies[fleet_exists[1]][submarine_types[i]]*config.unit_stats[submarine_types[i]].dp;
																	usr.used_soldiers = usr.used_soldiers - usr.armies[fleet_exists[1]][submarine_types[i]]*config.unit_stats[submarine_types[i]].manpower_cost;
																	removePops(arg0_user, usr.armies[fleet_exists[1]][submarine_types[i]]*config.unit_stats[submarine_types[i]].manpower_cost, "soldiers");
																	usr.armies[fleet_exists[1]][submarine_types[i]] = 0;
																} else {
																	submarines_lost = submarines_lost - Math.floor(random_counter_roll/config.unit_stats[submarine_types[i]].dp);
																	random_counter_roll = 0;
																	usr.used_soldiers = usr.used_soldiers - Math.floor(random_counter_roll/config.unit_stats[submarine_types[i]].dp)*config.unit_stats[submarine_types[i]].manpower_cost;
																	removePops(arg0_user, Math.floor(random_counter_roll/config.unit_stats[submarine_types[i]].dp)*config.unit_stats[submarine_types[i]].manpower_cost, "soldiers");
																	usr.armies[fleet_exists[1]][submarine_types[i]] = usr.armies[fleet_exists[1]][submarine_types[i]] - Math.floor(random_counter_roll/config.unit_stats[submarine_types[i]].dp);
																}
															}
															
															usr.armies[fleet_exists[1]].submarine_cooldown = true;
															msg.channel.send("Your submarines failed to intercept any merchant shipping. Instead, **" + submarines_lost + "** of our own submarines was sent to the deep blue depths of the high seas.");
														}
													} else {
														msg.channel.send("The target you have selected has no merchant shipping being conducted!");
													}
												} else if (mode == "naval") { //Attacks a random fleet
													var random_attacker_roll = randomNumber(0, attacker_ap);
													var random_defender_roll = randomNumber(0, defender_ap);
													var lost_defender_units = [];
													var lost_attacker_units = 0;
													
													var all_fleets = [];
													
													for (var i = 0; i < ot_user.armies.army_array.length; i++) {
														if (ot_user.armies[ot_user.armies.army_array[i]].type == "navy") {
															all_fleets.push(ot_user.armies.army_array[i]);
														}
													}
													
													var random_fleet = randomElement(all_fleets);
													
													//Calculate defender AP
													for (var x = 0; x < submarine_types.length; x++) {
														defender_ap = defender_ap + ot_user.armies[random_fleet][submarine_types[x]]*config.unit_stats[submarine_types[x]].ap;
													}
													for (var x = 0; x < destroyer_types.length; x++) {
														defender_ap = defender_ap + ot_user.armies[random_fleet][destroyer_types[x]]*config.unit_stats[destroyer_types[x]].ap;
													}
													for (var x = 0; x < cruiser_types.length; x++) {
														defender_ap = defender_ap + Math.round(ot_user.armies[random_fleet][cruiser_types[x]]*config.unit_stats[cruiser_types[x]].ap*0.5);
													}
													
													//Defender losses go first
													for (var i = 0; i < config.units.length; i++) {
														if (ot_user.armies[random_fleet][config.units[i]] > 0) {
															if (random_attacker_roll > ot_user.armies[random_fleet][config.units[i]]*config.unit_stats[config.units[i]].dp) {
																lost_defender_units.push(ot_user.armies[random_fleet][config.units[i]] + " " + config.unit_stats[config.units[i]].name);
																removePops(arg1_user, ot_user.armies[random_fleet][config.units[i]]*config.unit_stats[config.units[i]].manpower_cost, "soldiers");
																usr.used_soldiers = usr.used_soldiers - ot_user.armies[random_fleet][config.units[i]]*config.unit_stats[config.units[i]].manpower_cost;
																ot_user.armies[random_fleet][config.units[i]] = 0;
																random_attacker_roll = random_attacker_roll - ot_user.armies[random_fleet][config.units[i]]*config.unit_stats[config.units[i]].dp;
															} else {
																lost_defender_units.push(Math.floor(random_attacker_roll/(ot_user.armies[random_fleet][config.units[i]]*config.unit_stats[config.units[i]].dp)) + " " + config.unit_stats[config.units[i]].name);
																usr.used_soldiers = usr.used_soldiers - Math.floor(random_attacker_roll/(ot_user.armies[random_fleet][config.units[i]]*config.unit_stats[config.units[i]].dp))*config.unit_stats[config.units[i]].manpower_cost;
																removePops(arg1_user, Math.floor(random_attacker_roll/(ot_user.armies[random_fleet][config.units[i]]*config.unit_stats[config.units[i]].dp))*config.unit_stats[config.units[i]].manpower_cost, "soldiers");
																ot_user.armies[random_fleet][config.units[i]] = ot_user.armies[random_fleet][config.units[i]] - Math.floor(random_attacker_roll/(ot_user.armies[random_fleet][config.units[i]]*config.unit_stats[config.units[i]].dp));
																random_attacker_roll = 0;
															}
														}
													}
													
													//Attacker losses go second
													for (var i = 0; i < submarine_types.length; i++) {
														if (usr.armies[fleet_exists[1]][submarine_types[i]] > 0) {
															if (random_defender_roll > usr.armies[fleet_exists[1]][submarine_types[i]]*config.unit_stats[submarine_types[i]].dp) {
																lost_attacker_units = lost_attacker_units + usr.armies[fleet_exists[1]][submarine_types[i]];
																removePops(arg0_user, usr.armies[fleet_exists[1]][submarine_types[i]]*config.unit_stats[submarine_types[i]].manpower_cost, "soldiers");
																usr.used_soldiers = usr.used_soldiers - usr.armies[fleet_exists[1]][submarine_types[i]]*config.unit_stats[submarine_types[i]].manpower_cost;
																random_defender_roll = random_defender_roll - usr.armies[fleet_exists[1]][submarine_types[i]]*config.unit_stats[submarine_types[i]].dp;
																usr.armies[fleet_exists[1]][submarine_types[i]] = 0;
															} else {
																lost_attacker_units = lost_attacker_units + Math.floor(random_defender_roll/config.unit_stats[submarine_types[i]].dp);
																removePops(arg0_user, Math.floor(random_defender_roll/config.unit_stats[submarine_types[i]].dp)*config.unit_stats[submarine_types[i]].manpower_cost, "soldiers");
																usr.used_soldiers = usr.used_soldiers - Math.floor(random_defender_roll/config.unit_stats[submarine_types[i]].dp)*config.unit_stats[submarine_types[i]].manpower_cost;
																usr.armies[fleet_exists[1]][submarine_types[i]] = usr.armies[fleet_exists[1]][submarine_types[i]] - Math.floor(random_defender_roll/config.unit_stats[submarine_types[i]].dp);
																random_defender_roll = 0;
															}
														}
													}
													
													if (lost_defender_units.length == 0) {
														lost_defender_units = ["nothing"];
													}
													
													usr.armies[fleet_exists[1]].submarine_cooldown = true;
													console.log("<@" + arg1_user + "> lost " + lost_defender_units.join(", ") + " during a submarine attack on the **" + ot_user.armies[random_fleet].name + "**.\n\n<@" + arg0_user + "> also lost **" + lost_attacker_units + "** submarines.");
													returnChannels.send(war_channel, "<@" + arg1_user + "> lost " + lost_defender_units.join(", ") + " during a submarine attack on the **" + ot_user.armies[random_fleet].name + "**.\n\n<@" + arg0_user + "> also lost **" + lost_attacker_units + "** submarines.");
												} else if (mode == "reserves") { //Attacks naval reserves, air forces may intervene
													for (var i = 0; i < ot_user.armies.army_array.length; i++) {
														for (var x = 0; x < submarine_types.length; x++) {
															defender_ap = defender_ap + ot_user.armies[ot_user.armies.army_array[i]][submarine_types[x]]*config.unit_stats[submarine_types[x]].ap;
														}
														for (var x = 0; x < destroyer_types.length; x++) {
															defender_ap = defender_ap + ot_user.armies[ot_user.armies.army_array[i]][destroyer_types[x]]*config.unit_stats[destroyer_types[x]].ap;
														}
														for (var x = 0; x < cruiser_types.length; x++) {
															defender_ap = defender_ap + Math.round(ot_user.armies[ot_user.armies.army_array[i]][cruiser_types[x]]*config.unit_stats[cruiser_types[x]].ap*0.5);
														}
														for (var x = 0; x < helicopter_types.length; x++) {
															defender_ap = defender_ap + ot_user.armies[ot_user.armies.army_array[i]][helicopter_types[x]]*config.unit_stats[helicopter_types[x]].ap;
														}
													}
													for (var i = 0; i < submarine_types.length; i++) {
														defender_ap = defender_ap + ot_user.military[submarine_types[i]]*config.unit_stats[submarine_types[i]].ap;
													}
													for (var i = 0; i < destroyer_types.length; i++) {
														defender_ap = defender_ap + ot_user.military[destroyer_types[i]]*config.unit_stats[destroyer_types[i]].ap;
													}
													for (var i = 0; i < cruiser_types.length; i++) {
														defender_ap = defender_ap + ot_user.military[cruiser_types[i]]*config.unit_stats[cruiser_types[i]].ap;
													}
													for (var i = 0; i < helicopter_types.length; i++) {
														defender_ap = defender_ap + ot_user.military[helicopter_types[i]]*config.unit_stats[helicopter_types[i]].ap;
													}
													
													var random_attacker_roll = randomNumber(0, attacker_ap);
													var random_defender_roll = randomNumber(0, defender_ap);
													var lost_defender_units = [];
													var lost_attacker_units = 0;
													
													//Defender losses go first
													for (var i = 0; i < config.naval_units.length; i++) {
														if (ot_user.military[config.naval_units[i]] > 0) {
															if (random_attacker_roll > ot_user.military[config.naval_units[i]]*config.unit_stats[config.naval_units[i]].dp) {
																usr.used_soldiers = usr.used_soldiers - ot_user.military[config.naval_units[i]]*config.unit_stats[config.naval_units[i]].manpower_cost;
																removePops(arg0_user, ot_user.military[config.naval_units[i]]*config.unit_stats[config.naval_units[i]].manpower_cost, "soldiers");
																lost_defender_units.push(ot_user.military[config.naval_units[i]] + " " + config.unit_stats[config.naval_units[i]].name);
																ot_user.military[config.naval_units[i]] = 0;
																random_attacker_roll = random_attacker_roll - ot_user.military[config.naval_units[i]]*config.unit_stats[config.naval_units[i]].dp;
															} else {
																usr.used_soldiers = usr.used_soldiers - Math.floor(random_attacker_roll/config.unit_stats[config.naval_units[i]].dp)*config.unit_stats[config.naval_units[i]].manpower_cost;
																removePops(arg0_user, Math.floor(random_attacker_roll/config.unit_stats[config.naval_units[i]].dp)*config.unit_stats[config.naval_units[i]].manpower_cost, "soldiers");
																lost_defender_units.push(Math.floor(random_attacker_roll/config.unit_stats[config.naval_units[i]].dp) + " " + config.unit_stats[config.naval_units[i]].name);
																ot_user.military[config.naval_units[i]] = ot_user.military[config.naval_units[i]] - Math.floor(random_attacker_roll/config.unit_stats[config.naval_units[i]].dp);
															}
														}
													}
													
													//Attacker losses go second
													for (var i = 0; i < submarine_types.length; i++) {
														if (usr.armies[fleet_exists[1]][submarine_types[i]] > 0) {
															if (random_defender_roll > usr.armies[fleet_exists[1]][submarine_types[i]]*config.unit_stats[submarine_types[i]].dp) {
																lost_attacker_units = lost_attacker_units + usr.armies[fleet_exists[1]][submarine_types[i]];
																removePops(arg0_user, usr.armies[fleet_exists[1]][submarine_types[i]]*config.unit_stats[submarine_types[i]].manpower_cost, "soldiers");
																usr.used_soldiers = usr.used_soldiers - usr.armies[fleet_exists[1]][submarine_types[i]]*config.unit_stats[submarine_types[i]].manpower_cost;
																random_defender_roll = random_defender_roll - usr.armies[fleet_exists[1]][submarine_types[i]]*config.unit_stats[submarine_types[i]].dp;
																usr.armies[fleet_exists[1]][submarine_types[i]] = 0;
															} else {
																lost_attacker_units = lost_attacker_units + Math.floor(random_defender_roll/config.unit_stats[submarine_types[i]].dp);
																removePops(arg0_user, Math.floor(random_defender_roll/config.unit_stats[submarine_types[i]].dp)*config.unit_stats[submarine_types[i]].manpower_cost, "soldiers");
																usr.used_soldiers = usr.used_soldiers - Math.floor(random_defender_roll/config.unit_stats[submarine_types[i]].dp)*config.unit_stats[submarine_types[i]].manpower_cost;
																usr.armies[fleet_exists[1]][submarine_types[i]] = usr.armies[fleet_exists[1]][submarine_types[i]] - Math.floor(random_defender_roll/config.unit_stats[submarine_types[i]].dp);
																random_defender_roll = 0;
															}
														}
													}
													
													usr.armies[fleet_exists[1]].submarine_cooldown = true;
													returnChannels.send(war_channel, "<@" + arg1_user + "> lost " + lost_defender_units.join(", ") + " during a submarine attack on their reserves.\n\n<@" + arg0_user + "> also lost **" + lost_attacker_units + "** submarines.");
												}
											} else {
												msg.channel.send("You've already used up your submarine flotilla's special abilities for this turn! Wait until next round to attack again.");
											}
										} else {
											msg.channel.send("You may not torpedo the ships of neutral nations!");
										}
									} else {
										msg.channel.send("Your fleet must be comprised of only submarines in order to send them out on raiding missions!");
									}
								} else {
									msg.channel.send("The user you have specified has no active naval fleets in service!");
								}
							} else {
								msg.channel.send("A fleet by the name you have specified could not be found.");
							}
						} else {
							msg.channel.send("The user you are attempting to raid doesn't even have a navy!");
						}
					} else {
						msg.channel.send("You must have a country in order to start raiding shipping lanes!");
					}
				}
			}
			
			function newArmy (arg0_user, arg1_msg, arg2_name, arg3_province) {
				//Convert from parameters
				var msg = arg1_msg;
				var army_name = arg2_name;
				var province_id = arg3_province;
				var name_exists = false;
				
				if (main.users[arg0_user] != undefined) {
					if (army_name != "deleted-army") {
						var usr = main.users[arg0_user];
						var armies = main.users[arg0_user].armies;
						
						//Check if army already exists
						for (var i = 0; i < usr.armies.army_array.length; i++) {
							var local_el = usr.armies[usr.armies.army_array[i]];
							if (local_el.name.toLowerCase() == army_name.toLowerCase()) {
								name_exists = true;
							}
						}
						
						if (name_exists) {
							if (msg != "none") {
								msg.channel.send("There already exists an army by this name!");
							}
						} else {
							if (usr.armies.army_array.length+1 <= config.max_army_limit || config.max_army_limit == 0) {
								//Create the army
								armies.army_array.push(army_name);
								armies[army_name] = {};
								armies[army_name].name = army_name;
								armies[army_name].type = ""; //Land (air_land, land), Air, Sea (air_sea, sea).
								armies[army_name].in_battle = false; //Used to test whether army is currently in a battle when checking for same-province hostile armies.
								armies[army_name].can_move = [true, 0]; //[can_move, turns_until_can_move].
								armies[army_name].challenged_this_turn = 0; //How many blockades has this army challenged this turn?
								armies[army_name].blockade_recovery_turns = 0; //Turns before unit can reinforce a blockade.
								armies[army_name].stationary_turns = 0; //Turns that unit has not moved.
								armies[army_name].submarine_cooldown = false; //Submarine special ability cooldown, can only be activated once per turn.
								armies[army_name].army_size = 0; //How many men does this army have?
								armies[army_name].ap = 1; //Modifiers for AP, DP, MP and IP.
								armies[army_name].dp = 1;
								armies[army_name].mp = 1;
								armies[army_name].ip = 1;
								if (province_id != undefined) {
									armies[army_name].province = province_id;
									armies[army_name].moving_to = [];
								} else {
									armies[army_name].province = usr.capital_id;
									armies[army_name].moving_to = [];
								}
								
								armies[army_name].state = "stationed";
								for (var i = 0; i < config.units.length; i++) {
									armies[army_name][config.units[i]] = 0;
								}
								
								if (msg != "none") {
									msg.channel.send("You have created the **" + army_name + "**! Do `" + bot_prefix + "army-list` for a full list of all your armies.");
								}
								return "army_created";
							} else {
								if (msg != "none") {
									msg.channel.send("You have already reached the maximum army limit allowed of **" + parseNumber(config.max_army_creation_limit) + "**, and was therefore unable to create any new armies!");
								}
							}
						}
					} else {
						if (msg != "none") {
							msg.channel.send("Stop trying to cheese the system!");
						}
					}
				} else {
					if (msg != "none") {
						msg.channel.send("You don't have a country yet, you wannabe mercenary!");
					}
				}
			}
			
			function editArmy (arg0_user, arg1_msg, arg2_name, arg3_amount, arg4_unit, arg5_mode) {
				//Convert from parameters
				var user_id = arg0_user;
				var msg = arg1_msg;
				var army_name = arg2_name;
				var amount_to_deploy = Math.abs(parseInt(arg3_amount));
				
				//Declare instance variables
				var army_exists = [false, ""];
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					var armies = main.users[arg0_user].armies;
					var reserves = main.users[arg0_user].military;
					
					//Check if army exists - soft match
					for (var i = armies.army_array.length; i--;) {
						if (armies[armies.army_array[i]].name.toLowerCase().indexOf(arg2_name.toLowerCase()) != -1) {
							army_exists = [true, armies.army_array[i]];
						}
					}
					
					//Check if army exists - hard match
					for (var i = armies.army_array.length; i--;) {
						if (armies[armies.army_array[i]].name.toLowerCase() == arg2_name.toLowerCase()) {
							army_exists = [true, armies.army_array[i]];
						}
					}
					
					//Add units
					if (army_exists[0] && army_exists[1] != "deleted-army") {
						//Check if unit exists
						var unit_exists = false;
						for (var i = 0; i < config.units.length; i++) {
							if (config.units[i] == arg4_unit) {
								unit_exists = true;
							}
						}
						
						if (unit_exists) {
							//Check for mode ["add", "2nd Army"], ["add"], ["remove"]
							if (arg5_mode[0] == "add") {
								var conditions_not_fulfilled = [false, ""];
								var army2_exists = [false, ""];
								if (arg5_mode.length == 1) {
									if (amount_to_deploy > reserves[arg4_unit]) {
										conditions_not_fulfilled = [true, "You don't have that many troops in your reserves! You may only deploy up to **" + parseNumber(reserves[arg4_unit]) + "** " + arg4_unit + " in this army."];
									}
									
									if (usr.at_war.length == 0) {
										if (armies[army_exists[1]].type != "navy" && getProvince(armies[army_exists[1]].province.toString()).culture != usr.culture) {
											conditions_not_fulfilled = [true, "You can't deploy your reserves outside non-core provinces!"];
										}
									} else {
										if (armies[army_exists[1]].province.toString() != usr.capital_id.toString()) {
											conditions_not_fulfilled = [true, "You may only deploy forces in your capital city whilst at war!"];
										}
									}
								} else {
									//Check if army exists - soft match
									for (var i = armies.army_array.length; i--;) {
										if (armies[armies.army_array[i]].name.toLowerCase().indexOf(arg5_mode[1].toLowerCase()) != -1) {
											army2_exists = [true, armies.army_array[i]];
										}
									}
									
									//Check if army exists - hard match
									for (var i = armies.army_array.length; i--;) {
										if (armies[armies.army_array[i]].name.toLowerCase() == arg5_mode[1].toLowerCase()) {
											army2_exists = [true, armies.army_array[i]];
										}
									}
									
									if (army2_exists[0]) {
										if (amount_to_deploy > armies[army2_exists[1]][arg4_unit]) {
											conditions_not_fulfilled = [true, "You don't have enough " + arg4_unit + " in the **" + armies[army2_exists[1]].name + "** to fulfil this transfer request! There are only **" + parseNumber(armies[army2_exists[1]][arg4_unit]) + "** " + arg4_unit + " available for transfer in the " + armies[army2_exists[1]].name + "."];
										}
										
										if (armies[army2_exists[1]].province != armies[army_exists[1]].province) {
											conditions_not_fulfilled = [true, "The armies you have specified aren't even in the same province! The **" + armies[army2_exists[1]].name + "** is in Province **" + armies[army2_exists[1]].province + "**, whilst the **" + armies[army_exists[1]].name + "** is in Province **" + armies[army_exists[1]].province + "**."];
										}
									} else {
										conditions_not_fulfilled = [true, "The army you are trying to transfer these new units to does not exist!"];
									}
								}
								
								if (conditions_not_fulfilled[0]) {
									if (msg != "none") {
										msg.channel.send(conditions_not_fulfilled[1]);
									}
								} else {
									var receiving_air_unit = false;
									var receiving_naval_unit = false;
									var receiving_land_unit = false;
									
									var has_air_unit = false;
									var has_naval_unit = false;
									var has_land_unit = false;
									
									var error_code = [false, ""];
									
									var carrier_capacity_count = 0;
									var aeroplane_count = 0;
									
									for (var i = 0; i < config.ground_units.length; i++) {
										if (armies[army_exists[1]][config.ground_units[i]] > 0) {
											has_land_unit = true;
										}
									}
									for (var i = 0; i < config.ground_artillery.length; i++) {
										if (armies[army_exists[1]][config.ground_artillery[i]] > 0) {
											has_land_unit = true;
										}
									}
									for (var i = 0; i < config.ground_vehicles.length; i++) {
										if (armies[army_exists[1]][config.ground_vehicles[i]] > 0) {
											has_land_unit = true;
										}
									}
									for (var i = 0; i < config.aeroplanes.length; i++) {
										if (armies[army_exists[1]][config.aeroplanes[i]] > 0) {
											has_air_unit = true;
										}
									}
									for (var i = 0; i < config.naval_units.length; i++) {
										if (armies[army_exists[1]][config.naval_units[i]] > 0) {
											has_naval_unit = true;
											if (config.unit_stats[config.naval_units[i]].carrier_capacity != undefined) {
												carrier_capacity_count = carrier_capacity_count + armies[army_exists[1]][config.naval_units[i]]*config.unit_stats[config.naval_units[i]].carrier_capacity;
											}
										}
									}
									
									for (var i = 0; i < config.units.length; i++) {
										for (var x = 0; x < config.ground_units.length; x++) {
											if (arg4_unit == config.ground_units[i]) {
												receiving_land_unit = true;
											}
										}
										for (var x = 0; x < config.ground_artillery.length; x++) {
											if (arg4_unit == config.ground_artillery[i]) {
												receiving_land_unit = true;
											}
										}
										for (var x = 0; x < config.ground_vehicles.length; x++) {
											if (arg4_unit == config.ground_vehicles[i]) {
												receiving_land_unit = true;
											}
										}
										for (var x = 0; x < config.aeroplanes.length; x++) {
											if (arg4_unit == config.aeroplanes[i]) {
												receiving_air_unit = true;
											}
										}
										for (var x = 0; x < config.naval_units.length; x++) {
											if (arg4_unit == config.naval_units[i]) {
												receiving_naval_unit = true;
											}
										}
										if (config.unit_stats[arg4_unit].colonise_provinces != undefined) {
											error_code = [true, "To use your colonial units, type `$settle <prov1> <prov2> <...>` instead of transferring them to an army!"];
										}
									}
									
									//Aeroplane count
									for (var x = 0; x < config.aeroplanes.length; x++) {
										if (armies[army_exists[1]][config.aeroplanes[x]] > 0) {
											aeroplane_count = aeroplane_count + armies[army_exists[1]][config.aeroplanes[x]];
										}
									}
									
									if (has_naval_unit) { //Classified as a navy
										console.log("Carrier Capacity Count: " + carrier_capacity_count);
										console.log("Receiving a request to bring aboard " + parseNumber(amount_to_deploy) + " aeroplanes, in addition to the " + parseNumber(aeroplane_count) + " already aboard.");
										if (receiving_air_unit) {
											if (carrier_capacity_count == 0) {
												error_code = [true, "Your navy doesn't have air capabilities! Consider assigning aircraft carriers to your navy first."];
											} else {
												if ((amount_to_deploy+aeroplane_count) > carrier_capacity_count) {
													var local_ending_string = "";
													var total_amount_left = carrier_capacity_count-(amount_to_deploy+aeroplane_count);
													local_ending_string = "You may only bring up to **" + parseNumber(total_amount_left) + "** more aeroplanes aboard.";
													if (total_amount_left < 0) {
														total_amount_left = 0;
														local_ending_string = "Your aircraft carriers are all full up.";
													}
													
													error_code = [true, "Your aircraft carriers can't carry that many aeroplanes! " + local_ending_string];
												}
											}
										}
										if (receiving_land_unit) {
											error_code = [true, "Your soldiers can't swim that far!"];
										}
									} else if (has_air_unit) { //Classified as an air force
										if (receiving_naval_unit) {
											error_code = [true, "Research flying aircraft carriers somewhere else!"];
										}
									} else if (has_land_unit) { //Classified as an army
										if (receiving_naval_unit) {
											error_code = [true, "That's not what I meant when I said landship ..."];
										}
									}
									
									//Check if provinces of the capital id and army are the same
									if (armies[army_exists[1]].province != usr.capital_id) {
										if (usr.at_war.length > 0 && arg5_mode.length == 1) {
											error_code = [true, "You can't transfer to armies not in your capital province whilst at war!"];
										}
									}
									
									if (error_code[0]) {
										if (msg != "none") {
											msg.channel.send(error_code[1]);
										}
									} else {
										armies[army_exists[1]][arg4_unit] = armies[army_exists[1]][arg4_unit] + amount_to_deploy;
										var middle_term = "";
										
										if (arg5_mode[1] != undefined) {
											armies[army2_exists[1]][arg4_unit] = armies[army2_exists[1]][arg4_unit] - amount_to_deploy;
											middle_term = "transferred to";
										} else {
											reserves[arg4_unit] = reserves[arg4_unit] - amount_to_deploy;
											middle_term = "deployed in";
										}
										
										if (msg != "none") {
											msg.channel.send("**" + parseNumber(amount_to_deploy) + "** " + arg4_unit + " were " + middle_term + " the " + armies[army_exists[1]].name + ".");
										}
										
										//Recalculate army type
										for (var i = 0; i < config.units.length; i++) {
											for (var x = 0; x < config.ground_units.length; x++) {
												if (armies[army_exists[1]][config.ground_units[x]] > 0) {
													has_land_unit = true;
												}
											}
											for (var x = 0; x < config.ground_artillery.length; x++) {
												if (armies[army_exists[1]][config.ground_artillery[x]] > 0) {
													has_land_unit = true;
												}
											}
											for (var x = 0; x < config.ground_vehicles.length; x++) {
												if (armies[army_exists[1]][config.ground_vehicles[x]] > 0) {
													has_land_unit = true;
												}
											}
											for (var x = 0; x < config.aeroplanes.length; x++) {
												if (armies[army_exists[1]][config.aeroplanes[x]] > 0) {
													has_air_unit = true;
												}
											}
											for (var x = 0; x < config.naval_units.length; x++) {
												if (armies[army_exists[1]][config.naval_units[x]] > 0) {
													has_naval_unit = true;
												}
											}
										}
									
										{
											if ((has_naval_unit && has_air_unit) || (has_naval_unit)) {
												armies[army_exists[1]].type = "navy";
												armies[army_exists[1]].state = "in harbour";
												armies[army_exists[1]].order = "in harbour";
												console.log("Army type set to navy.");
											} else if ((has_land_unit && has_air_unit) || (has_land_unit)) {
												armies[army_exists[1]].type = "army";
												console.log("Army type set to army.");
											} else if (has_air_unit && has_land_unit != true && has_naval_unit != true) {
												armies[army_exists[1]].type = "air force";
												console.log("Army type set to air force.");
											}
										}
									}
								} 
							} else if (arg5_mode[0] == "remove") {
								if (armies[army_exists[1]].blockade_recovery_turns == 0) {
									if (armies[army_exists[1]].submarine_cooldown == false) {
										if (armies[army_exists[1]].challenged_this_turn == 0) {
											if (amount_to_deploy > armies[army_exists[1]][arg4_unit]) {
												if (msg != "none") {
													msg.channel.send("You don't have that many troops in " + armies[army_exists[1]].name + "! You only withdraw up to **" + parseNumber(armies[army_exists[1]][arg4_unit]) + "** " + arg4_unit + " from this force.");
												}
											} else {
												armies[army_exists[1]][arg4_unit] = armies[army_exists[1]][arg4_unit] - amount_to_deploy;
												reserves[arg4_unit] = reserves[arg4_unit] + amount_to_deploy;
												
												if (msg != "none") {
													msg.channel.send("You placed **" + parseNumber(amount_to_deploy) + "** " + arg4_unit + " from the " + armies[army_exists[1]].name + " back into reserve.");
												}
											}
										} else {
											if (msg != "none") {
												msg.channel.send("You have already used this fleet to challenge enemy blockade(s) this turn! Wait until next turn to be able to move ships in/out of this fleet.");
											}
										}
									} else {
										if (msg != "none") {
											msg.channel.send("The submarine flotilla you have specified is currently on cooldown! Wait until next turn to transfer submarines out of this flotilla.");
										}
									}
								} else {
									if (msg != "none") {
										msg.channel.send("The fleet you have specified is still recovering from a naval battle! The recovery is expected to take at least **" + armies[army_exists[1]].blockade_recovery_turns + "** more turns. Until then, no units can be transferred out of the fleet.");
									}
								}
							} else {
								if (msg != "none") {
									msg.channel.send("Something went wrong. Please DM Vis for more information.");
								}
							}
						} else {
							if (msg != "none") {
								msg.channel.send("The unit you have specified doesn't exist!");
							}
						}
					} else {
						if (msg != "none") {
							msg.channel.send("The army you have specified doesn't exist! Try putting it in double inverted commas if the name contains spaces.");
						}
					}
				} else {
					if (msg != "none") {
						msg.channel.send("You don't have a country yet, you wannabe mercenary!");
					}
				}
			}
			
			function renameArmy (arg0_user, arg1_msg, arg2_name, arg3_newname) {
				var msg = arg1_msg;
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					var armies = main.users[arg0_user].armies;
					var army_exists = [false, ""];
					
					//Check if army exists - soft match
					for (var i = armies.army_array.length; i--;) {
						if (armies[armies.army_array[i]].name.toLowerCase().indexOf(arg2_name.toLowerCase()) != -1) {
							army_exists = [true, armies.army_array[i]];
						}
					}
					
					//Check if army exists - hard match
					for (var i = armies.army_array.length; i--;) {
						if (armies[armies.army_array[i]].name.toLowerCase() == arg2_name.toLowerCase()) {
							army_exists = [true, armies.army_array[i]];
						}
					}
					
					var name_taken = false;
					for (var i = 0; i < main.user_array.length; i++) {
						for (var x = 0; x < main.users[main.user_array[i]].armies.army_array.length; x++) {
							var local_element = main.users[main.user_array[i]].armies[main.users[main.user_array[i]].armies.army_array[x]];
							if (local_element.name.toLowerCase() == arg3_newname.toLowerCase()) {
								name_taken = true;
							}
						}
					}
					
					if (army_exists[0]) {
						if (name_taken == false) {
							var old_name = armies[army_exists[1]].name;
							armies[army_exists[1]].name = arg3_newname;
							msg.channel.send("You have updated the name of the " + old_name + " to the **" + arg3_newname + "**!");
						} else {
							msg.channel.send("This army name is already in use!");
						}
					} else {
						msg.channel.send("The army you have specified is nonexistent!");
					}
				} else {
					msg.channel.send("You're stateless!");
				}
			}
			
			function disband (arg0_user, arg1_msg, arg2_unit, arg3_amount) {
				var usr = main.users[arg0_user];
				var amount_to_disband = Math.abs(parseInt(arg3_amount));
				
				var unit_exists = false;
				var unit_id = "";
				
				for (var i = 0; i < config.units.length; i++) {
					if (config.units[i] == arg2_unit) {
						unit_exists = true;
						unit_id = arg2_unit;
					}
				}
				
				if (unit_exists) {
					if (usr.military[arg2_unit] >= amount_to_disband) {
						var unit_manpower_cost = 0;
						
						if (config.unit_stats[unit_id].costs != undefined) {
							for (var i = 0; i < config.unit_stats[unit_id].costs.length; i++) {
								if (config.unit_stats[unit_id].costs[i][1] == "soldiers") {
									unit_manpower_cost = config.unit_stats[unit_id].costs[i][0];
								}
							}
						} else {
							unit_manpower_cost = 0;
						}
						
						usr.used_soldiers = usr.used_soldiers - (Math.ceil(unit_manpower_cost/config.unit_stats[unit_id].quantity))*amount_to_disband;
						usr.used_manpower = usr.used_manpower - (Math.ceil(unit_manpower_cost/config.unit_stats[unit_id].quantity))*amount_to_disband;
						usr.military[arg2_unit] = usr.military[arg2_unit] - amount_to_disband;
						
						arg1_msg.channel.send("**" + parseNumber(amount_to_disband) + "** " + arg2_unit + " were disbanded. You were refunded " + "**" + parseNumber(Math.ceil(Math.ceil(unit_manpower_cost/config.unit_stats[unit_id].quantity)*amount_to_disband)) + "** manpower.");
					} else {
						arg1_msg.channel.send("You don't have that many **" + arg2_unit + "**!");
					}
				} else {
					arg1_msg.channel.send("The type of unit that you have specified does not exist!");
				}
			}
			
			function deleteArmy (arg0_user, arg1_msg, arg2_name) {
				var msg = arg1_msg;
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					var armies = main.users[arg0_user].armies;
					var army_exists = [false, ""];
					
					//Check if army exists - soft match
					for (var i = armies.army_array.length; i--;) {
						if (armies[armies.army_array[i]].name.toLowerCase().indexOf(arg2_name.toLowerCase()) != -1) {
							army_exists = [true, armies.army_array[i]];
						}
					}
					
					//Check if army exists - hard match
					for (var i = armies.army_array.length; i--;) {
						if (armies[armies.army_array[i]].name.toLowerCase() == arg2_name.toLowerCase()) {
							army_exists = [true, armies.army_array[i]];
						}
					}
					
					if (army_exists[0] && army_exists[1] != "deleted-army") {
						var old_name = armies[army_exists[1]].name;
						
						for (var i = 0; i < config.units.length; i++) {
							usr.military[config.units[i]] = usr.military[config.units[i]] + armies[army_exists[1]][config.units[i]];
							armies[army_exists[1]][config.units[i]] = 0;
						}
						
						//Check if army was reinforcing a blockade, if so, remove it.
						var all_blockades = main.users.global.blockades;
						for (var i = 0; i < all_blockades.length; i++) {
							for (var x = 0; x < main.users.global.blockades[all_blockades[i]].length; x++) {
								if (main.users.global.blockades[all_blockades[i]][x] == army_exists[1]) {
									main.users.global.blockades[all_blockades[i]].splice(x, 1);
								}
							}
						}
						
						for (var i = 0; i < armies.army_array.length; i++) {
							if (armies.army_array[i] == army_exists[1]) {
								armies.army_array.splice(i, 1);
							}
						}
						delete armies[army_exists[1]];
						
						if (arg1_msg != "none") {
							msg.channel.send("You have demobilised the **" + old_name + "**! They have now been returned to the reserves.");
						}
					} else {
						if (arg1_msg != "none") {
							msg.channel.send("The army you have specified is nonexistent!");
						}
					}
				} else {
					if (arg1_msg != "none") {
						msg.channel.send("You're currently stateless!");
					}
				}
			}
			
			function printArmy (arg0_user, arg1_msg, arg2_name) {
				var msg = arg1_msg;
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					var armies = main.users[arg0_user].armies;
					var army_exists = [false, ""];
					
					//Check if army exists - soft match
					for (var i = armies.army_array.length; i--;) {
						if (armies[armies.army_array[i]].name.toLowerCase().indexOf(arg2_name.toLowerCase()) != -1) {
							army_exists = [true, armies.army_array[i]];
						}
					}
					
					//Check if army exists - hard match
					for (var i = armies.army_array.length; i--;) {
						if (armies[armies.army_array[i]].name.toLowerCase() == arg2_name.toLowerCase()) {
							army_exists = [true, armies.army_array[i]];
						}
					}
					
					if (army_exists[0] && army_exists[1] != "deleted-army") {
						var military_string = [];
						
						military_string.push("<:globe:716811246556545035> Country: **" + main.users[arg0_user].name + "**");
						
						var empty_army = true;
						var ap = 0;
						var dp = 0;
						
						var has_air_unit = false;
						var has_naval_unit = false;
						var has_land_unit = false;
						
						var army_icon = "";
						var carrier_capacity_count = 0;
						var aeroplane_count = 0;
						
						var carrier_capacity_string = "";
									
						for (var i = 0; i < config.units.length; i++) {
							for (var x = 0; x < config.ground_units.length; x++) {
								if (armies[army_exists[1]][config.ground_units[x]] > 0) {
									empty_army = false;
									has_land_unit = true;
									army_icon = "<:manpower:716817688705499177>";
								}
							}
							for (var x = 0; x < config.ground_artillery.length; x++) {
								if (armies[army_exists[1]][config.ground_artillery[x]] > 0) {
									empty_army = false;
									has_land_unit = true;
									army_icon = "<:artillery:716821195055431681>";
								}
							}
							for (var x = 0; x < config.ground_vehicles.length; x++) {
								if (armies[army_exists[1]][config.ground_vehicles[x]] > 0) {
									empty_army = false;
									has_land_unit = true;
									army_icon = "<:land_vehicles:716821195215077406>";
								}
							}
							for (var x = 0; x < config.aeroplanes.length; x++) {
								if (armies[army_exists[1]][config.aeroplanes[x]] > 0) {
									empty_army = false;
									has_air_unit = true;
									army_icon = "<:aeroplanes:716821195407884358>";
								}
							}
							for (var x = 0; x < config.naval_units.length; x++) {
								if (armies[army_exists[1]][config.naval_units[x]] > 0) {
									empty_army = false;
									has_naval_unit = true;
									army_icon = "<:naval_units:716821195277729832>";
								}
							}
							
							if (armies[army_exists[1]][config.units[i]] > 0) {
								empty_army = false;
							}
						}
						
						for (var x = 0; x < config.aeroplanes.length; x++) {
							if (armies[army_exists[1]][config.aeroplanes[x]] > 0) {
								aeroplane_count = aeroplane_count + armies[army_exists[1]][config.aeroplanes[x]];
							}
						}
						
						var submarine_types = [];
						var pure_submarines = true;
						var moving_string = "";
						
						for (var i = 0; i < config.units.length; i++) {
							if (config.unit_stats[config.units[i]].submarine) {
								submarine_types.push(config.units[i]);
							}
						}
						
						for (var i = 0; i < config.units.length; i++) {
							var is_submarine = false;
							for (var x = 0; x < submarine_types.length; x++) {
								if (config.units[i] == submarine_types[x]) {
									is_submarine = true;
								}
							}
										
							if (is_submarine == false) {
								if (usr.armies[army_exists[1]][config.units[i]] > 0) {
									pure_submarines = false;
								}
							}
						}
						
						if (usr.armies[army_exists[1]].moving_to.length > 0) {
							moving_string = "currently moving to Province **" + usr.armies[army_exists[1]].moving_to[usr.armies[army_exists[1]].moving_to.length-1] + "**.";
						} else {
							if (usr.armies[army_exists[1]].type != "navy") {
								moving_string = "currently stationed in Province **" + usr.armies[army_exists[1]].province + "**.";
							} else {
								if (usr.armies[army_exists[1]].challenged_this_turn == 0) {
									moving_string = "currently docked in harbour.";
								} else {
									if (usr.armies[army_exists[1]].challenged_this_turn <= config.blockade_challenge_limit) {
										moving_string = "fighting an enemy blockade! We can engage the enemy **" + parseNumber((config.blockade_challenge_limit-usr.armies[army_exists[1]].challenged_this_turn)+1) + "** more time(s) this turn.";
									} else {
										moving_string = "currently repairing in harbour after fighting off enemy blockades.";
									}
								}
							}
						}
						
						if (usr.armies[army_exists[1]].taking_attrition) {
							moving_string = moving_string + " Taking attrition at a rate of <:death:798009877469462530> **" + (100-Math.ceil((usr.modifiers.attrition_rate*config.base_attrition_rate)*100)) + "%**!";
						}
						
						for (var i = 0; i < config.units.length; i++) {
							if (config.unit_stats[config.units[i]].carrier_capacity > 0) {
								carrier_capacity_count = carrier_capacity_count + (usr.armies[army_exists[1]][config.units[i]]*config.unit_stats[config.units[i]].carrier_capacity);
							}
						}
						
						if (carrier_capacity_count > 0) {
							carrier_capacity_string = " (Carrier Capacity: **" + aeroplane_count + "**/**" + carrier_capacity_count + "**)";
						}
						
						if (usr.armies[army_exists[1]].submarine_cooldown) {
							moving_string = moving_string + " - Currently on cooldown, will be combat ready in **1** turn.";
						}
						
						if (usr.armies[army_exists[1]].blockade_recovery_turns > 0) {
							moving_string = moving_string + " Currently recovering from a blockade, will be combat ready in **" + usr.armies[army_exists[1]].blockade_recovery_turns + "** turn(s).";
						}
						
						military_string.push("------------------ \n" + army_icon + " **" + armies[army_exists[1]].name + "**" + carrier_capacity_string + ": " + moving_string);
						
						if (carrier_capacity_count > 0) {
							military_string.push("<:aeroplanes:716821195407884358> **Aeroplanes** receive a **+50%** attack bonus whilst at sea.");
						}
						
						var relieve_unit_string = "";
						var transfer_unit_string = "";
						var move_unit_string = "";
						var split_army_string = "";
						
						if (empty_army == false) {
							relieve_unit_string = " ¦ `" + bot_prefix + "relieve-units`";
							transfer_unit_string = " ¦ `" + bot_prefix + "transfer-units`";
							if (armies[army_exists[1]].type != "navy" && armies[army_exists[1]].type != "") {
								split_army_string = "`" + bot_prefix + "split-army` ¦ ";
							}
						}
						
						military_string.push("`" + bot_prefix + "rename-army` ¦ `" + bot_prefix + "deploy`" + transfer_unit_string + relieve_unit_string + " ¦ `" + bot_prefix + "delete-army`");
						//Army orders and commands display
						console.log("Army Type: " + armies[army_exists[1]].type);
						if (armies[army_exists[1]].type == "army") {
							military_string.push(split_army_string + "`" + bot_prefix + "merge-army` ¦ `" + bot_prefix + "move`");
						} else if (armies[army_exists[1]].type == "navy") {
							if (pure_submarines == false) {
								var fleet_already_in_blockade = false;
								var lift_blockade_string = "";
								var all_blockades = Object.keys(main.users.global.blockades);
									
								for (var i = 0; i < all_blockades.length; i++) {
									for (var x = 0; x < main.users.global.blockades[all_blockades[i]].length; x++) {
										if (main.users.global.blockades[all_blockades[i]][x] == army_exists[1]) {
											fleet_already_in_blockade = true;
										}
									}
								}
								
								if (fleet_already_in_blockade) {
									lift_blockade_string = " ¦ `" + bot_prefix + "lift-blockade`";
								}
								
								if (usr.enable_blockades) {
									military_string.push("`" + bot_prefix + "blockade` ¦ `" + bot_prefix + "challenge-blockade`" + lift_blockade_string);
								} else {
									military_string.push("`" + bot_prefix + "challenge-blockade`" + lift_blockade_string);
								}
							} else {
								military_string.push("`" + bot_prefix + "convoy-raid` ¦ `" + bot_prefix + "harbour-raid` ¦ `" + bot_prefix + "torpedo-fleet`");
							}
						} else if (armies[army_exists[1]].type == "air force") {
							military_string.push(split_army_string + "`" + bot_prefix + "merge-army` ¦ `" + bot_prefix + "move` ¦ `" + bot_prefix + "air-raid`");
						}
						
						military_string.push("");
						military_string.push("Army Size: " + parseNumber(armies[army_exists[1]].army_size));
						military_string.push("Current Province: " + armies[army_exists[1]].province);
						military_string.push("------------------");
						
						for (var i = 0; i < config.units.length; i++) {
							ap = ap + usr.armies[army_exists[1]][config.units[i]]*config.unit_stats[config.units[i]].ap;
							dp = dp + usr.armies[army_exists[1]][config.units[i]]*config.unit_stats[config.units[i]].dp;
						}
						for (var i = 0; i < config.ground_units.length; i++) {
							if (armies[army_exists[1]][config.ground_units[i]] > 0) {
								military_string.push("<:active_personnel:716820390474940426> **" + config.ground_units[i] + "**: " + armies[army_exists[1]][config.ground_units[i]]);
								empty_army = false;
							}
						}
						for (var i = 0; i < config.ground_artillery.length; i++) {
							if (armies[army_exists[1]][config.ground_artillery[i]] > 0) {
								military_string.push("<:artillery:716821195055431681> **" + config.ground_artillery[i] + "**: " + armies[army_exists[1]][config.ground_artillery[i]]);
								empty_army = false;
							}
						}
						for (var i = 0; i < config.ground_vehicles.length; i++) {
							if (armies[army_exists[1]][config.ground_vehicles[i]] > 0) {
								military_string.push("<:land_vehicles:716821195215077406> **" + config.ground_vehicles[i] + "**: " + armies[army_exists[1]][config.ground_vehicles[i]]);
								empty_army = false;
							}
						}
						for (var i = 0; i < config.aeroplanes.length; i++) {
							if (armies[army_exists[1]][config.aeroplanes[i]] > 0) {
								military_string.push("<:aeroplanes:716821195407884358> **" + config.aeroplanes[i] + "**: " + armies[army_exists[1]][config.aeroplanes[i]]);
								empty_army = false;
							}
						}
						for (var i = 0; i < config.naval_units.length; i++) {
							if (armies[army_exists[1]][config.naval_units[i]] > 0) {
								military_string.push("<:naval_units:716821195277729832> **" + config.naval_units[i] + "**: " + armies[army_exists[1]][config.naval_units[i]]);
								empty_army = false;
							}
						}
						for (var i = 0; i < config.colonists.length; i++) {
							if (armies[army_exists[1]][config.colonists[i]] > 0) {
								military_string.push("<:colonisation:716821194891853826> **" + config.colonists[i] + "**: " +armies[army_exists[1]][config.colonists[i]]);
								empty_army = false;
							}
						}
						
						if (empty_army == true) {
							military_string.push("_No units found._\nDo `" + bot_prefix + "transfer <number> <unit> <army name>` to transfer some over from your reserves.");
						} else {
							military_string.push("");
							military_string.push("AP: `" + parseNumber(ap) + "` ¦ DP: `" + parseNumber(dp) + "`");
						}
						
						const embed_army = new Discord.MessageEmbed()
							.setColor('#a98ac7')
							.setAuthor('Triumph & Tragedy:', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
							.setTitle('**' + armies[army_exists[1]].name + ', ' + main.users[arg0_user].name + ':\n------------------**')
							.setThumbnail('https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
							.setDescription(military_string.join("\n"))
							.setTimestamp()
							.setFooter('To access this menu again, type ' + bot_prefix + 'army <army name>.', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png');
					
						arg1_msg.channel.send(embed_army);
					} else {
						arg1_msg.channel.send("The army you have specified is nonexistent!");
					}
				} else {
					arg1_msg.channel.send("You don't even have a nation!");
				}
			}
				
			function printArmies (arg0_user, arg1_msg) {
				var msg = arg1_msg;
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					var armies_string = [];
					
					armies_string.push("<:manpower:716817688705499177> **Armies:**");
					for (var i = 0; i < usr.armies.army_array.length; i++) {
						if (usr.armies[usr.armies.army_array[i]].name != "deleted-army") {
							var icon = "";
							//army, navy, air force
							if (usr.armies[usr.armies.army_array[i]].type == "army") {
								icon = "<:active_personnel:716820390474940426> ";
							} else if (usr.armies[usr.armies.army_array[i]].type == "navy") {
								icon = "<:naval_units:716821195277729832> ";
							} else if (usr.armies[usr.armies.army_array[i]].type == "air force") {
								icon = "<:aeroplanes:716821195407884358> ";
							}
							armies_string.push(" - " + icon + "**" + usr.armies[usr.armies.army_array[i]].name + "** (" + usr.armies[usr.armies.army_array[i]].state + ", Province #**" + usr.armies[usr.armies.army_array[i]].province + "**). `" + bot_prefix + "army " + usr.armies[usr.armies.army_array[i]].name + "`.");
						}
					}
					
					if (usr.armies.army_array.length == 0) {
						armies_string.push("");
						armies_string.push("_You currently have no armies in active service._");
						armies_string.push("Try typing `" + bot_prefix + "create-army <name>` to start building a military! Make sure you have troops in your reserves though.");
					}
					
					var army_embeds = [];
					var local_army_string = [];
					var current_character_count = 0;
					
					if (armies_string.length > 0) {
						for (var i = 0; i < armies_string.length; i++) {
							local_army_string.push(armies_string[i]);
							current_character_count += armies_string[i].length;
							if (i != 0 || armies_string.length == 1) {
								if (current_character_count > 2800 || i == armies_string.length-1) {
									const embed_armies = new Discord.MessageEmbed()
										.setColor('#a98ac7')
										.setAuthor('Triumph & Tragedy:', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
										.setTitle('**Army List (' + usr.name + '):\n------------------**')
										.setThumbnail('https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
										.setDescription(local_army_string.join("\n") + "\n\n- Reserves: `" + bot_prefix + "reserves`")
										.setTimestamp()
										.setFooter('To access this menu again, type ' + bot_prefix + 'army-list.', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png');
										
									army_embeds.push(embed_armies);
									current_character_count = 0;
									local_army_string = [];
								}
							}
						}
					}
					
					scrollMessage(msg, army_embeds, 0);
				} else {
					arg1_msg.channel.send("You're currently stateless!");
				}
			}
			
			function splitArmy (arg0_user, arg1_msg, arg2_name, arg3_newname) {
				//Convert from parameters
				var user_id = arg0_user;
				var msg = arg1_msg;
				var army_name = arg2_name;
				var new_army_name = arg3_newname;
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					var army_exists = [false, ""];
					
					//As always, soft match first!
					for (var i = 0; i < usr.armies.army_array.length; i++) {
						if (usr.armies[usr.armies.army_array[i]].name.toLowerCase().indexOf(arg2_name.toLowerCase()) != -1) {
							army_exists = [true, usr.armies.army_array[i]];
						}
					}
					for (var i = 0; i < usr.armies.army_array.length; i++) {
						if (usr.armies[usr.armies.army_array[i]].name.toLowerCase() == arg2_name.toLowerCase()) {
							army_exists = [true, usr.armies.army_array[i]];
						}
					}
					
					if (army_exists[0]) {
						if (usr.armies[army_exists[1]].type != "navy") {
							if (usr.armies[army_exists[1]].type != "") {
								return newArmy(usr.id, "none", arg3_newname, usr.armies[army_exists[1]].province);
								if (msg != "none") {
									msg.channel.send("You have created a new field army named the **" + arg3_newname + "** alongside the previously existing **" + usr.armies[army_exists[1]].name + "**. To deploy units into this new army, type `" + bot_prefix + "transfer-units`.");
								}
							} else {
								if (msg != "none") {
									msg.channel.send("You can't split off armies that have no units in them!");
								}
							}
						} else {
							if (msg != "none") {
								msg.channel.send("You can't split off fleets like that!");
							}
						}
					} else {
						if (msg != "none") {
							msg.channel.send("The army you have specified does not exist!");
						}
					}
				} else {
					if (msg != "none") {
						msg.channel.send("You must have a country first before being able to create new armies in the field!");
					}
				}
			}
			
			function mobilise (arg0_user, arg1_msg) {
				var msg = arg1_msg;
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					
					if (usr.mobilised_manpower[1] == "") {
						if (usr.enable_mobilisation) {
							if (main.roundCount-usr.last_mobilised > config.mobilisation_cooldown) {
								var manpower_mobilised = Math.ceil((usr.workers-usr.used_workers)*config.base_mobilisation_size*usr.modifiers.mobilisation_size);
								var production_efficiency_debuff = config.base_mobilisation_impact[0]*usr.modifiers.mobilisation_impact*-1;
								var tax_efficiency_debuff = config.base_mobilisation_impact[1]*usr.modifiers.mobilisation_impact*-1;
								var rgo_throughput_debuff = config.base_mobilisation_impact[2]*usr.modifiers.mobilisation_impact*-1;
								
								if (manpower_mobilised > 0) {
									usr.last_mobilised = main.roundCount;
									
									setNationalSpirit(usr.id, "nation_in_arms", [
										["name", "A Nation In Arms!"],
										["img", "https://media.discordapp.net/attachments/744414944019087451/799507120755441664/mobilisation_impact.png"],
										["icon", "<:small_arms:771909826505605162>"],
										["description", "With the outbreak of war, we have ordered the conscription of all available male personnel into the army and the mobilisation of all reservists, leaving many essential tasks on the home front vacant, and depleting our national coffers. From rural pastures to bustling cities, **" + usr.name + "** calls on all its citizens to serve their country!\n\n• **" + (Math.round(production_efficiency_debuff*100*100)/100) + "%** Production Efficiency\n• **" + (Math.round(tax_efficiency_debuff*100*100)/100) + "%** Tax Efficiency\n• **" + (Math.round(rgo_throughput_debuff*100*100)/100) + "%** RGO Throughput"],
										["production_efficiency", production_efficiency_debuff],
										["tax_efficiency", tax_efficiency_debuff],
										["rgo_throughput", rgo_throughput_debuff]
									]);
									var mobilisation_speed = Math.ceil(usr.modifiers.mobilisation_speed*config.base_mobilisation_time);
									var mobilised_unit = usr.mobilise_unit;
									
									usr.mobilised_manpower = [manpower_mobilised, mobilised_unit, mobilisation_speed, 0, mobilisation_speed];
									usr.used_workers = usr.used_workers + manpower_mobilised;
									
									msg.channel.send("You have begun to mobilise **" + parseNumber(manpower_mobilised) + "** men as **" + mobilised_unit + "**! They will finish mobilising in **" + parseNumber(usr.mobilised_manpower[2]) + "** turns.");
									
									//Check if user is being justified on or if the user is at war
									var is_being_justified_on = false;
									for (var i = 0; i < main.user_array.length; i++) {
										if (main.users[main.user_array[i]].justifications.length > 0) {
											for (var x = 0; x < main.users[main.user_array[i]].justifications.length; x++) {
												if (main.users[main.user_array[i]].justifications[x][1] == usr.id) {
													is_being_justified_on = true;
												}
											}
										}
									}
									
									if (usr.at_war.length == 0 && !is_being_justified_on) {
										returnChannels.send(war_channel, "<@" + usr.id + "> has decided to mobilise during peacetime! This will cost them <:infamy:716817688453709905> " + config.peacetime_mobilisation_penalty + " infamy per turn until they decide to demobilise.");
									}
								} else {
									msg.channel.send("Due to a critical manpower shortage, you can't mobilise more people currently!");
								}
							} else {
								msg.channel.send("Your people can't mobilise and demobilise instantly! Wait for **" + parseNumber((config.mobilisation_cooldown-(main.roundCount-usr.last_mobilised))+1) + "** more turn(s).");
							}
						} else {
							msg.channel.send("Your people haven't even heard of such a concept yet! Research mobilisation first.");
						}
					} else {
						msg.channel.send("You're already mobilised!");
					}
				} else {
					msg.channel.send("You can't mobilise a country with zero people in it!");
				}
			}
			
			function demobilise (arg0_user, arg1_msg) {
				var msg = arg1_msg;
				
				if (main.users[arg0_user] != undefined) {
					var user_id = main.users[arg0_user];
					
					if (user_id.mobilised_manpower[3] > 0) {
						if (user_id.enable_mobilisation) {
							if (user_id.mobilised_manpower[1] != "" && user_id.mobilised_manpower[2] == 0) {
								user_id.last_mobilised = main.roundCount;
								
								var manpower_mobilised = user_id.mobilised_manpower[3];
								var mobilised_unit = user_id.mobilised_manpower[1];
								var remaining_manpower = JSON.parse(JSON.stringify(user_id.mobilised_manpower[3]));
								
								for (var i = 0; i < user_id.armies.army_array.length; i++) {
									var local_army = user_id.armies[user_id.armies.army_array[i]];
									if (remaining_manpower > 0) {
										if (local_army[mobilised_unit] >= remaining_manpower) {
											local_army[mobilised_unit] = local_army[mobilised_unit] - remaining_manpower;
											remaining_manpower = 0;
										} else {
											remaining_manpower = remaining_manpower - local_army[mobilised_unit];
											local_army[mobilised_unit] = 0;
										}
									}
									
									var has_units = false;
									for (var x = 0; x < config.units.length; x++) {
										if (local_army[config.units[x]] > 0) {
											has_units = true;
										}
									}
									
									if (has_units == false) {
										local_army.type = "";
									}
								}
								
								if (remaining_manpower > 0) {
									if (user_id.military[mobilised_unit] >= remaining_manpower) {
										user_id.military[mobilised_unit] = user_id.military[mobilised_unit] - remaining_manpower;
									} else {
										user_id.military[mobilised_unit] = 0;
									}
								}
								
								user_id.used_workers = user_id.used_workers - manpower_mobilised;
								removeNationalSpirit(user_id.id, "nation_in_arms");
								
								if (arg1_msg != "none") {
									msg.channel.send("You demobilised **" + parseNumber(manpower_mobilised) + "** " + mobilised_unit + ".");
								}
								
								returnChannels.send(war_channel, "**" + user_id.name + "** has decided to demobilise their armed reserves, and their forces are now standing down.");
								
								user_id.mobilised_manpower = [0, "", 0, 0, 0];
								console.log(user_id.mobilised_manpower);
							} else {
								console.log("[Triumph & Tragedy]: Current Mobilisation Cooldown for " + user_id.name + ": " + config.mobilisation_cooldown-(main.roundCount-main.users[arg0_user].last_mobilised) + " turns.");
								if (arg1_msg != "none") {
									msg.channel.send("Your people can't mobilise and demobilise instantly! Wait for **" + parseNumber((config.mobilisation_cooldown-(main.roundCount-main.users[arg0_user].last_mobilised))+1) + "** more turn(s).");
								}
							}
						} else {
							if (arg1_msg != "none") {
								msg.channel.send("Your people haven't even heard of such a concept yet! Research mobilisation first.");
							}
						}
					} else {
						if (arg1_msg != "none") {
							msg.channel.send("You can't demobilise a country with zero people in it!");
						}
					}
				} else {
					if (arg1_msg != "none") {
						msg.channel.send("You're already mobilised!");
					}
				}
			}
			
			//WIP - Does it work?
			function airRaid (arg0_user, arg1_army, arg2_user, arg3_province, arg4_msg) {
				var msg = arg4_msg;
				if (main.users[arg0_user] != undefined && main.users[arg2_user] != undefined) {
					var usr = main.users[arg0_user];
					var ot_user = main.users[arg2_user];
					
					//Check if army exists
					var army_exists = [false, ""];
					
					//Soft match first
					for (var i = usr.armies.army_array.length; i--;) {
						if (usr.armies[usr.armies.army_array[i]].name.toLowerCase().indexOf(arg1_army.toLowerCase()) != -1) {
							army_exists = [true, usr.armies.army_array[i]];
						}
					}
					//Hard match later
					for (var i = usr.armies.army_array.length; i--;) {
						if (usr.armies[usr.armies.army_array[i]].name.toLowerCase() == arg1_army.toLowerCase()) {
							army_exists = [true, usr.armies.army_array[i]];
						}
					}
					
					if (army_exists[0]) {
						//Check that the army type is indeed "air force"
						if (usr.armies[army_exists[1]].type == "air force") {
							//Get AP/DP
							var air_fleet_ap = 0;
							var air_fleet_dp = 0;
							
							var main_unit_ap = 0;
							var largest_wing = 0;
							
							var squadron = usr.armies[army_exists[1]];
							
							for (var i = 0; i < config.aeroplanes.length; i++) {
								if (squadron[config.aeroplanes[i]] > 0) {
									if (squadron[config.aeroplanes[i]] > largest_wing) {
										largest_wing = squadron[config.aeroplanes[i]];
										main_unit_ap = config.unit_stats[config.aeroplanes[i]].ap;
									}
									if (config.unit_stats[config.aeroplanes[i]].can_bomb_cities != false) {
										air_fleet_ap = air_fleet_ap + squadron[config.aeroplanes[i]]*config.unit_stats[config.aeroplanes[i]].ap;
										air_fleet_dp = air_fleet_dp + squadron[config.aeroplanes[i]]*config.unit_stats[config.aeroplanes[i]].dp;
									}
								}
							}
							
							if (air_fleet_ap == 0 || air_fleet_dp == 0) {
								msg.channel.send("Your air fleet has no aeroplanes capable of bombing urban targets in it!");
							} else {
								var already_at_war = false;
								
								if (usr.at_war.length > 0) {
									for (var i = 0; i < usr.at_war.length; i++) {
										if (usr.at_war[i] == main.users[arg2_user].name) {
											already_at_war = true;
										}
									}
								}
								
								//Check if province is city
								var attacked_city = "";
								for (var i = 0; i < main.users[arg2_user].cities.city_array.length; i++) {
									if (main.users[arg2_user].cities[main.users[arg2_user].cities.city_array[i]].province == arg3_province) {
										attacked_city = main.users[arg2_user].cities.city_array[i];
									}
								}
								
								if (attacked_city != "") {
									if (already_at_war) {
										var local_city = main.users[arg2_user].cities[attacked_city];
										console.log("Was " + attacked_city + " attacked this turn? " + main.users[arg2_user].cities[attacked_city].attacked_this_turn);
										if (local_city.attacked_this_turn == false) {
											//Check for air to air combat
											var attacker_string = [];
											var defender_string = [];
											var results_string = [];
											
											//Routine error trapping, just in case
											try {
												var potential_interception_provinces = getAllProvincesInRange(local_city.province, Math.ceil(config.interception_range*returnSafeNumber(ot_user.modifiers.air_interception_range, 1)));
												
												for (var i = 0; i < potential_interception_provinces.length; i++) {
													var defender_armies_in_province = getArmiesInProvince(potential_interception_provinces[i], ot_user.id);
													
													//Engage in combat if air fleets are in the given province
													if (defender_armies_in_province.length > 0) {
														for (var x = 0; x < defender_armies_in_province.length; x++) {
															if (defender_armies_in_province[x].type == "air force") {
																combat(ot_user.id, defender_armies_in_province[x].name, usr.id, squadron.name, local_city.province, "none");
															}
														}
													}
												}
											} catch {}
											
											var city_object = main.users[arg2_user].cities[attacked_city];
											var city_buildings = [];
											
											//Check if city has buildings
											var has_buildings = false;
											var total_buildings = 0;
											for (var i = 0; i < config.buildings.length; i++) {
												if (city_object.buildings[config.buildings[i]] > 0) {
													has_buildings = true;
													total_buildings = total_buildings + city_object.buildings[config.buildings[i]];
												}
											}
											
											if (has_buildings) {
												var destroyed_buildings = {};
												var total_casualties = 0;
												var total_attacker_casualties = 0;
												//Scramble buildings/Shuffle buildings
												for (var i = 0; i < config.buildings.length; i++) {
													if (city_object.buildings[config.buildings[i]] > 0) {
														for (var x = 0; x < city_object.buildings[config.buildings[i]]; x++) {
															city_buildings.push(config.buildings[i]);
														}
													}
												}
												var shuffled_buildings = city_buildings;
												var current_index = city_buildings.length, temporary_value, random_index;
												while (0 != current_index) {
													random_index = Math.floor(Math.random()*current_index);
													current_index -= 1;
													temporary_value = shuffled_buildings[current_index];
													shuffled_buildings[current_index] = shuffled_buildings[random_index];
													shuffled_buildings[random_index] = temporary_value;
												}
												
												console.log("Shuffled Buildings: " + shuffled_buildings);
												console.log("---");
												
												//Each ack-ack gun is worth 10x the main_unit_ap, revert to fixed AP damage if valid
												main_unit_ap = (config.anti_aircraft_fixed_damage) ? config.anti_aircraft_base_damage/10 : main_unit_ap;
												
												console.log("Main Unit AP: " + main_unit_ap);
												var defender_ap = city_object.buildings.ack_ack_guns*main_unit_ap*10*config.anti_aircraft_effectiveness*returnSafeNumber(ot_user.modifiers.ack_ack_effectiveness, 1);
												
												//Attacker rolls, each building has ((defender_ap/building_count)*100)+500 DP
												var defender_dp = ((defender_ap/total_buildings)*100)+500;
												var attacker_roll = randomNumber(0, air_fleet_ap); //Ouch
												console.log("Attacker Roll: (" + attacker_roll + "/" + air_fleet_ap + ")");
												
												//Deduct buildings, floored
												var deducted_buildings = Math.floor(attacker_roll/defender_dp);
												if (deducted_buildings > shuffled_buildings.length) {
													deducted_buildings = shuffled_buildings.length-1;
												}
												console.log("Deducted Buildings: " + deducted_buildings);
												console.log("Province: " + city_object.province);
												
												var all_province_keys = Object.keys(ot_user.pops);
												console.log("Pop keys: " + all_province_keys.join(", "));
												console.log("Pops object: " + ot_user.pops[city_object.province]);
												console.log("Percentage Killed: " + (1-(deducted_buildings/total_buildings)));
												
												//40% destruction cap, population killed = percentage of deducted buildings, soft cap at 120k
												if (Math.ceil(total_buildings*0.2) <= deducted_buildings) {
													for (var i = 0; i < Math.ceil(total_buildings*0.2); i++) {
														city_object.buildings[shuffled_buildings[i]]--;
														if (destroyed_buildings[shuffled_buildings[i]] != undefined) {
															destroyed_buildings[shuffled_buildings[i]]++;
														} else {
															destroyed_buildings[shuffled_buildings[i]] = 1;
														}
													}
													for (var i = 0; i < config.pop_array.length; i++) {
														total_casualties = total_casualties + (ot_user.pops[city_object.province][config.pop_array[i]]-Math.ceil(ot_user.pops[city_object.province][config.pop_array[i]]*(deducted_buildings/total_buildings)));
													}
													if (total_casualties > 120000) {
														total_casualties = randomNumber(110000, 120000);
														for (var i = 0; i < config.pop_array.length; i++) {
															ot_user.pops[city_object.province][config.pop_array[i]] = ot_user.pops[city_object.province][config.pop_array[i]] - Math.ceil(total_casualties/config.pop_array.length);
														}
													} else {
														for (var i = 0; i < config.pop_array.length; i++) {
															ot_user.pops[city_object.province][config.pop_array[i]] = Math.ceil(ot_user.pops[city_object.province][config.pop_array[i]]*(deducted_buildings/total_buildings));
														}
													}
												} else {
													//Subtract 40% of all buildings
													deducted_buildings = Math.ceil(total_buildings*0.2);
													for (var i = 0; i < deducted_buildings; i++) {
														city_object.buildings[shuffled_buildings[i]]--;
														if (destroyed_buildings[shuffled_buildings[i]] != undefined) {
															destroyed_buildings[shuffled_buildings[i]]++;
														} else {
															destroyed_buildings[shuffled_buildings[i]] = 1;
														}
														if (config.building_stats[shuffled_buildings[i]].supply_limit != undefined) {
															for (var x = 0; x < config.infrastructure_range*2; x++) {
																var province_id = ((parseInt(arg3_province)-config.infrastructure_range)+x).toString();
																if (getProvince(province_id, "owner") == arg0_user) {
																	if (getProvince(province_id).supply_limit != undefined) {
																		getProvince(province_id).supply_limit = getProvince(province_id).supply_limit - config.building_stats[shuffled_buildings[i]].supply_limit;
																	} else {
																		getProvince(province_id).supply_limit = config.building_stats[shuffled_buildings[i]].supply_limit;
																	}
																}
															}
														}
														if (config.building_stats[shuffled_buildings[i]].demolish_effect != undefined) {
															config.building_stats[shuffled_buildings[i]].demolish_effect();
														}
													}
													for (var i = 0; i < config.pop_array.length; i++) {
														total_casualties = total_casualties + (ot_user.pops[city_object.province][config.pop_array[i]]-Math.ceil(ot_user.pops[city_object.province][config.pop_array[i]]*(deducted_buildings/total_buildings)));
													}
													if (total_casualties > 120000) {
														total_casualties = randomNumber(110000, 120000);
														for (var i = 0; i < config.pop_array.length; i++) {
															ot_user.pops[city_object.province][config.pop_array[i]] = ot_user.pops[city_object.province][config.pop_array[i]] - Math.ceil(total_casualties/config.pop_array.length);
														}
													} else {
														for (var i = 0; i < config.pop_array.length; i++) {
															ot_user.pops[city_object.province][config.pop_array[i]] = Math.ceil(ot_user.pops[city_object.province][config.pop_array[i]]*(deducted_buildings/total_buildings));
														}
													}
												}
												
												var output_string = [];
												var attacker_loss_string = [];
												var aeroplanes_lost = 0;
												for (var i = 0; i < config.buildings.length; i++) {
													if (destroyed_buildings[config.buildings[i]] > 0) {
														output_string.push(destroyed_buildings[config.buildings[i]] + " " + config.building_stats[config.buildings[i]].name.toLowerCase());
													}
												}
												
												if (output_string.length == 0) {
													output_string.push("No buildings were destroyed.");
												}
												
												//Subtract attacker aeroplanes according to defender_ap
												if (defender_ap < 0) {
													defender_ap = 0;
												}
												
												for (var i = 0; i < config.aeroplanes.length; i++) {
													if (defender_ap > squadron[config.aeroplanes[i]]*config.unit_stats[config.aeroplanes[i]].dp) {
														aeroplanes_lost = aeroplanes_lost + squadron[config.aeroplanes[i]];
														if (squadron[config.aeroplanes[i]] > 0) {
															attacker_loss_string.push(parseNumber(squadron[config.aeroplanes[i]]) + " " + config.aeroplanes[i].replace(/_/g, " ").replace(/(^\w{1})|(\s{1}\w{1})/g, match => match.toUpperCase()));
														}
														usr.used_soldiers = usr.used_soldiers - squadron[config.aeroplanes[i]]*config.unit_stats[config.aeroplanes[i]].manpower_cost;
														removePops(arg0_user, squadron[config.aeroplanes[i]]*config.unit_stats[config.aeroplanes[i]].manpower_cost, "soldiers");
														total_attacker_casualties = total_attacker_casualties + Math.floor(squadron[config.aeroplanes[i]]*config.unit_stats[config.aeroplanes[i]].manpower_cost);
														defender_ap = defender_ap - squadron[config.aeroplanes[i]]*config.unit_stats[config.aeroplanes[i]].dp;
														squadron[config.aeroplanes[i]] = 0;
													} else {
														aeroplanes_lost = aeroplanes_lost - Math.floor(defender_ap/config.unit_stats[config.aeroplanes[i]].dp);
														if (Math.floor(defender_ap/config.unit_stats[config.aeroplanes[i]].dp) > 0) {
															attacker_loss_string.push(parseNumber(Math.floor(defender_ap/config.unit_stats[config.aeroplanes[i]].dp)) + " " + config.aeroplanes[i].replace(/_/g, " ").replace(/(^\w{1})|(\s{1}\w{1})/g, match => match.toUpperCase()));
														}
														usr.used_soldiers = usr.used_soldiers - Math.floor(defender_ap/config.unit_stats[config.aeroplanes[i]].dp)*config.unit_stats[config.aeroplanes[i]].manpower_cost;
														removePops(arg0_user, Math.floor(defender_ap/config.unit_stats[config.aeroplanes[i]].dp)*config.unit_stats[config.aeroplanes[i]].manpower_cost, "soldiers");
														total_attacker_casualties = total_attacker_casualties + Math.floor(defender_ap/config.unit_stats[config.aeroplanes[i]].dp)*config.unit_stats[config.aeroplanes[i]].manpower_cost;
														defender_ap = 0;
														squadron[config.aeroplanes[i]] = squadron[config.aeroplanes[i]] - Math.floor(defender_ap/config.unit_stats[config.aeroplanes[i]].dp);
													}
												}
												
												var all_wars = Object.keys(main.users.global.wars);
												var war_obj = "";
												var attacker_is_involved = [false, ""];
												var defender_side = "";
												for (var i = 0; i < all_wars.length; i++) {
													for (var x = 0; x < main.users.global.wars[all_wars[i]].attackers.length; x++) {
														if (main.users.global.wars[all_wars[i]].attackers[x] == arg0_user) {
															attacker_is_involved = [true, "attacker", all_wars[i]];
															defender_side = "defender";
														}
													}
													for (var x = 0; x < main.users.global.wars[all_wars[i]].defenders.length; x++) {
														if (main.users.global.wars[all_wars[i]].defenders[x] == arg0_user) {
															attacker_is_involved = [true, "defender", all_wars[i]];
															defender_side = "attacker";
														}
													}
												}
												
												war_obj = main.users.global.wars[attacker_is_involved[2]];
												
												if (war_obj != "") {
													war_obj[defender_side + "_total_casualties"] = war_obj[defender_side + "_total_casualties"] + Math.ceil(total_casualties);
													war_obj[arg2_user + "_casualties"] = war_obj[arg2_user + "_casualties"] + Math.ceil(total_casualties);
													war_obj[attacker_is_involved[1] + "_total_casualties"] = war_obj[attacker_is_involved[1] + "_total_casualties"] + Math.ceil(total_attacker_casualties);
													war_obj[arg0_user + "_casualties"] = war_obj[arg0_user + "_casualties"] + Math.ceil(total_attacker_casualties);
												}
												
												city_object.attacked_this_turn = true;
												
												var raid_gif = "";
												
												if (main.year < 1936) {
													raid_gif = "https://media.discordapp.net/attachments/789253574336839690/789257218385379369/ww1_raid.gif";
												} else if (main.year >= 1936 && main.year < 1950) {
													raid_gif = "https://media.discordapp.net/attachments/789253574336839690/789257203168182312/ww2_raid.gif";
												} else if (main.year >= 1950 && main.year < 1989) {
													raid_gif = "https://media.discordapp.net/attachments/789253574336839690/789257238933667860/cold_war_raid.gif";
												} else {
													raid_gif = "https://media.discordapp.net/attachments/789253574336839690/789257215722389564/desert_storm.gif";
												}
												
												//Attacker string
												attacker_string.push("**" + usr.name + "** (" + usr.armies[army_exists[1]].name + "):");
												attacker_string.push("");
												attacker_string.push("**Losses:**");
												if (attacker_loss_string.length > 0) {
													for (var i = 0; i < attacker_loss_string.length; i++) {
														attacker_string.push("- <:aeroplanes:716821195407884358> " + attacker_loss_string[i]);
													}
													attacker_string.push("");
												}
												attacker_string.push("<:death:798009877469462530> Casualties: **" + parseNumber(total_attacker_casualties) + "**");
												
												//Defender string
												defender_string.push("**" + ot_user.name + "** (" + city_object.name + "):");
												defender_string.push("");
												defender_string.push("**Losses:**");
												for (var i = 0; i < output_string.length; i++) {
													defender_string.push("- " + output_string[i]);
												}
												defender_string.push("");
												defender_string.push("<:death:798009877469462530> Casualties: **" + parseNumber(total_casualties) + "**");
												
												//Results string, give war exhaustion
												var attacker_war_exhaustion = 0;
												var defender_war_exhaustion = 0;
												if (total_attacker_casualties > 0) {
													attacker_war_exhaustion = ((total_attacker_casualties/usr.soldiers)*100).toFixed(2);
													usr.modifiers.war_exhaustion += parseInt(attacker_war_exhaustion);
												}
												if (total_casualties > 0) {
													defender_war_exhaustion = ((total_casualties/ot_user.population)*100).toFixed(2);
													ot_user.modifiers.war_exhaustion += parseInt(defender_war_exhaustion);
												}
												
												results_string.push("<:death:798009877469462530> Total Casualties: **" + parseNumber(total_casualties+total_attacker_casualties) + "**");
												results_string.push("");
												results_string.push("**" + usr.name + "** gained <:infamy:716817688453709905> **+" + attacker_war_exhaustion + "** war exhaustion.");
												results_string.push("**" + ot_user.name + "** gained <:infamy:716817688453709905> **+" + defender_war_exhaustion + "** war exhaustion.");
												
												const air_raid_embed = new Discord.MessageEmbed()
													.setColor('#a98ac7')
													.setAuthor('Triumph & Tragedy:', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
													.setTitle('**Raid over ' + city_object.name + ':\n------------------**')
													.addFields(
														{ name: "<:bombing_attacker:798005448854863893> __**Attacker:**__\n---\n", value: attacker_string.join("\n"), inline: true },
														{ name: "<:bombing_defender:798005448904015872> __**Defender:**__\n---\n", value: defender_string.join("\n"), inline: true },
														{ name: "<:results:798006990638940160> __**Results:**__\n---\n", value: results_string.join("\n")}
													)
													.setImage(raid_gif);
												
												console.log(air_raid_embed);
													
												returnChannels.send(war_channel, {embed: air_raid_embed});
											} else {
												msg.channel.send("The city you are trying to bomb has no buildings!");
											}
										} else {
											msg.channel.send("You have already attacked this city this turn!");
										}
									} else {
										msg.channel.send("You must be in a state of hostilities with the target user in order to commence a bombing mission on them!");
									}
								} else {
									msg.channel.send("Province `" + arg3_province + "` turned out to be an invalid province for bombing! Try typing `" + bot_prefix + 'city-list "' + main.users[arg2_user].name + '" for a full list of cities and province IDs.');
								}
							}
						} else {
							msg.channel.send("You need to have actual aeroplanes in the army to commence bombing runs!");
						}
					} else {
						msg.channel.send("The air fleet specified proved to be non-existent!");
					}
				} else {
					msg.channel.send("The user you have specified failed to exist!");
				}
			}
			
			function combat (arg0_user, arg1_army, arg2_user, arg3_army, arg4_province, arg5_msg) { //$combat [@def. user] [army name] [@att. user] [army name] [province]
				//Convert from parameters
				var usr = (main.users[arg0_user]) ? main.users[arg0_user] : undefined;
				var ot_user = (main.users[arg2_user]) ? main.users[arg2_user] : undefined;
				
				//Get army objects
				//returnChannel(war_channel).send("Test");
				var attacker_casualties = 0;
				var defender_casualties = 0;
				
				if (main.users[arg0_user] != undefined && main.users[arg2_user] != undefined) {
					var army1_exists = [false, 0];
					var army2_exists = [false, 0];
					var defender_obj = main.users[arg0_user];
					var attacker_obj = main.users[arg2_user];
					
					var armies1 = main.users[arg0_user].armies;
					var armies2 = main.users[arg2_user].armies;
					
					//First Player Army
					{
						//Check if army exists - soft match
						for (var i = 0; i < armies1.army_array.length; i++) {
							if (armies1[armies1.army_array[i]].name.toLowerCase().indexOf(arg1_army.toLowerCase()) != -1) {
								army1_exists = [true, armies1.army_array[i]];
							}
						}
						
						//Check if army exists - hard match
						for (var i = 0; i < armies1.army_array.length; i++) {
							if (armies1[armies1.army_array[i]].name.toLowerCase() == arg1_army.toLowerCase()) {
								army1_exists = [true, armies1.army_array[i]];
							}
						}
					}
					
					//Second Player Army
					{
						//Check if army exists - soft match
						for (var i = 0; i < armies2.army_array.length; i++) {
							if (armies2[armies2.army_array[i]].name.toLowerCase().indexOf(arg3_army.toLowerCase()) != -1) {
								army2_exists = [true, armies2.army_array[i]];
							}
						}
						
						//Check if army exists - hard match
						for (var i = 0; i < armies2.army_array.length; i++) {
							if (armies2[armies2.army_array[i]].name.toLowerCase() == arg3_army.toLowerCase()) {
								army2_exists = [true, armies2.army_array[i]];
							}
						}
					}
					
					console.log("[Triumph & Tragedy]: Do the partcipants armies exist? [" + army1_exists + "] , [" + army2_exists + "]");
					if (army1_exists[0] && army2_exists[0]) {
						
						//Determine types of armies (land, sea, air, air_land, air_sea)
						var defender_has_air_unit = false;
						var defender_has_naval_unit = false;
						var defender_has_land_unit = false;
						
						var defender_army_type = "";
						
						var attacker_has_air_unit = false;
						var attacker_has_naval_unit = false;
						var attacker_has_land_unit = false;
						
						var attacker_army_type = "";
						
						var battle_type = "";
						
						//Defender
						for (var x = 0; x < config.units.length; x++) {
							for (var i = 0; i < config.ground_units.length; i++) {
								if (armies1[army1_exists[1]][config.ground_units[i]] > 0) {
									defender_has_land_unit = true;
								}
							}
							for (var i = 0; i < config.ground_artillery.length; i++) {
								if (armies1[army1_exists[1]][config.ground_artillery[i]] > 0) {
									defender_has_land_unit = true;
								}
							}
							for (var i = 0; i < config.ground_vehicles.length; i++) {
								if (armies1[army1_exists[1]][config.ground_vehicles[i]] > 0) {
									defender_has_land_unit = true;
								}
							}
							for (var i = 0; i < config.colonists.length; i++) {
								if (armies1[army1_exists[1]][config.colonists[i]] > 0) {
									defender_has_land_unit = true;
								}
							}
							for (var i = 0; i < config.aeroplanes.length; i++) {
								if (armies1[army1_exists[1]][config.aeroplanes[i]] > 0) {
									defender_has_air_unit = true;
								}
							}
							for (var i = 0; i < config.naval_units.length; i++) {
								if (armies1[army1_exists[1]][config.naval_units[i]] > 0) {
									defender_has_naval_unit = true;
								}
							}
						}
						
						if (defender_has_land_unit) {
							defender_army_type = "land";
						}
						if (defender_has_naval_unit) {
							defender_army_type = "sea";
						}
						if (defender_has_air_unit) {
							defender_army_type = "air";
						}
						if (defender_has_air_unit && defender_has_land_unit) {
							defender_army_type = "air_land";
						}
						if (defender_has_air_unit && defender_has_naval_unit) {
							defender_army_type = "air_sea";
						}
						
						//Attacker
						for (var x = 0; x < config.units.length; x++) {
							for (var i = 0; i < config.ground_units.length; i++) {
								if (armies2[army2_exists[1]][config.ground_units[i]] > 0) {
									attacker_has_land_unit = true;
								}
							}
							for (var i = 0; i < config.ground_artillery.length; i++) {
								if (armies2[army2_exists[1]][config.ground_artillery[i]] > 0) {
									attacker_has_land_unit = true;
								}
							}
							for (var i = 0; i < config.ground_vehicles.length; i++) {
								if (armies2[army2_exists[1]][config.ground_vehicles[i]] > 0) {
									attacker_has_land_unit = true;
								}
							}
							for (var i = 0; i < config.colonists.length; i++) {
								if (armies2[army2_exists[1]][config.colonists[i]] > 0) {
									attacker_has_land_unit = true;
								}
							}
							for (var i = 0; i < config.aeroplanes.length; i++) {
								if (armies2[army2_exists[1]][config.aeroplanes[i]] > 0) {
									attacker_has_air_unit = true;
								}
							}
							for (var i = 0; i < config.naval_units.length; i++) {
								if (armies2[army2_exists[1]][config.naval_units[i]] > 0) {
									attacker_has_naval_unit = true;
								}
							}
						}
						
						if (attacker_has_land_unit) {
							attacker_army_type = "land";
						}
						if (attacker_has_naval_unit) {
							attacker_army_type = "sea";
						}
						if (attacker_has_air_unit) {
							attacker_army_type = "air";
						}
						if (attacker_has_air_unit && attacker_has_land_unit) {
							attacker_army_type = "air_land";
						}
						if (attacker_has_air_unit && attacker_has_naval_unit) {
							attacker_army_type = "air_sea";
						}
						
						//Determine battle type: land, naval, air
						{
							if ((attacker_army_type == "land" || attacker_army_type == "air_land") && (defender_army_type == "land" || defender_army_type == "air_land")) {
								battle_type = "land";
							}
							if (attacker_army_type == "air" && (defender_army_type == "land" || defender_army_type == "air_land")) {
								battle_type = "land";
							}
							if ((attacker_army_type == "land" || attacker_army_type == "air_land") && defender_army_type == "land") {
								battle_type = "land";
							}
							
							if ((attacker_army_type == "sea" || attacker_army_type == "air_sea") && (defender_army_type == "sea" || defender_army_type == "air_sea")) {
								battle_type = "sea";
							}
							if (attacker_army_type == "air" && (defender_army_type == "sea" || defender_army_type == "air_sea")) {
								battle_type = "sea";
							}
							if ((attacker_army_type == "sea" || attacker_army_type == "air_sea") && defender_army_type == "air") {
								battle_type = "sea";
							}
							
							if (attacker_army_type == "air" && defender_army_type == "air") {
								battle_type = "air";
							}
						}
						
						setTimeout(function(){
							if (armies1[army1_exists[1]] != undefined && armies2[army2_exists[1]] != undefined) {
								console.log("[Triumph & Tragedy]: A battle was initiated!");
								
								var army1_ap = 0; //Defender
								var army1_dp = 0; //Defender
								var army2_ap = 0; //Attacker
								var army2_dp = 0; //Attacker
								
								var attacker_dp = 0; //Attacker
								var defender_dp = 0; //Defender
								
								var defender_losses = {};
								var attacker_losses = {};
								
								var attacker_roll = 0;
								var defender_roll = 0;
								
								for (var i = 0; i < config.units.length; i++) {
									defender_losses[config.units[i]] = 0;
									attacker_losses[config.units[i]] = 0;
									defender_dp = defender_dp + parseInt(armies1[army1_exists[1]][config.units[i]]*config.unit_stats[config.units[i]].dp);
									attacker_dp = attacker_dp + parseInt(armies2[army2_exists[1]][config.units[i]]*config.unit_stats[config.units[i]].dp);
								}
								
								var province_name = "";
								var city_exists = [false, ""];
								
								if (battle_type == "land") {
									for (var i = 0; i < main.users[arg0_user].cities.city_array.length; i++) {
										if (main.users[arg0_user].cities[main.users[arg0_user].cities.city_array[i]].province == arg4_province) {
											province_name = main.users[arg0_user].cities[main.users[arg0_user].cities.city_array[i]].name;
											city_exists = [true, main.users[arg0_user].cities.city_array[i]];
										}
									}
									
									if (city_exists[0] == false) {
										var province_prefixes = config.localisation.battle_prefixes,
										province_name = randomElement(province_prefixes) + " " + arg4_province.toString();
									}
								} else if (battle_type == "sea") {
									var naval_names = config.localisation.bathymetric_names;
									
									province_name = randomElement(naval_names);
								} else if (battle_type == "air") {
									province_name = main.users[arg0_user].name;
								}
								
								function calculateApDp () { //Calculate Battle Report
									army1_ap = 0;
									army1_dp = 0;
									army2_ap = 0;
									army2_dp = 0;
									
									//Calculate AP/DP
									
									for (var i = 0; i < config.units.length; i++) {
										army1_ap = army1_ap + parseInt(armies1[army1_exists[1]][config.units[i]]*config.unit_stats[config.units[i]].ap);
										army1_dp = army1_dp + parseInt(armies1[army1_exists[1]][config.units[i]]*config.unit_stats[config.units[i]].dp);
										army2_ap = army2_ap + parseInt(armies2[army2_exists[1]][config.units[i]]*config.unit_stats[config.units[i]].ap);
										army2_dp = army2_dp + parseInt(armies2[army2_exists[1]][config.units[i]]*config.unit_stats[config.units[i]].dp);
									}
									
									for (var i = 0; i < config.unit_categories.length; i++) {
										for (var x = 0; x < config[config.unit_categories[i]].length; x++) {
											army1_ap = army1_ap + parseInt(Math.round(armies1[army1_exists[1]][config[config.unit_categories[i]][x]]*config.unit_stats[config[config.unit_categories[i]][x]].ap*main.users[arg0_user].modifiers[config.unit_categories[i] + "_ap"]));
											army1_dp = army1_dp + parseInt(Math.round(armies1[army1_exists[1]][config[config.unit_categories[i]][x]]*config.unit_stats[config[config.unit_categories[i]][x]].dp*main.users[arg0_user].modifiers[config.unit_categories[i] + "_dp"]));
											army2_ap = army2_ap + parseInt(Math.round(armies2[army2_exists[1]][config[config.unit_categories[i]][x]]*config.unit_stats[config[config.unit_categories[i]][x]].ap*main.users[arg2_user].modifiers[config.unit_categories[i] + "_ap"]));
											army2_dp = army2_dp + parseInt(Math.round(armies2[army2_exists[1]][config[config.unit_categories[i]][x]]*config.unit_stats[config[config.unit_categories[i]][x]].dp*main.users[arg2_user].modifiers[config.unit_categories[i] + "_dp"]));
										}
									}									
									if (battle_type == "sea") {
										for (var i = 0; i < config.aeroplanes.length; i++) {
											army1_ap = army1_ap + Math.ceil(armies1[army1_exists[1]][config.aeroplanes[i]]*main.users[arg0_user].modifiers.aeroplanes_ap*config.unit_stats[config.aeroplanes[i]].ap*0.5);
											army2_ap = army2_ap + Math.ceil(armies2[army2_exists[1]][config.aeroplanes[i]]*main.users[arg2_user].modifiers.aeroplanes_ap*config.unit_stats[config.aeroplanes[i]].ap*0.5);
										}
									}
									
									army1_ap = Math.round(army1_ap*armies1[army1_exists[1]].ap);
									army1_dp = Math.round(army1_dp*armies1[army1_exists[1]].dp);
									army2_ap = Math.round(army2_ap*armies2[army2_exists[1]].ap);
									army2_dp = Math.round(army2_dp*armies2[army2_exists[1]].dp);
								}
								
								function defenderAPRoll (ap_amount) {
									var current_roll = randomNumber(0, ap_amount);
									defender_roll = current_roll;
									
									for (var i = 0; i < config.units.length; i++) {
										if (armies2[army2_exists[1]][config.units[i]] > 0) {
											var manoeuvre = randomNumber(0, 20);
											if (current_roll > armies2[army2_exists[1]][config.units[i]]*config.unit_stats[config.units[i]].dp) {
												current_roll = current_roll - armies2[army2_exists[1]][config.units[i]]*config.unit_stats[config.units[i]].dp;
												
												if (manoeuvre > Math.round(config.unit_stats[config.units[i]].mp*armies2[army2_exists[1]].mp)) {
													var lost_population = Math.ceil(armies2[army2_exists[1]][config.units[i]]*0.5)*config.unit_stats[config.units[i]].manpower_cost;
													console.log("[Triumph & Tragedy]: Lost Population: " + lost_population);
													armies2[army2_exists[1]][config.units[i]] = Math.floor(armies2[army2_exists[1]][config.units[i]]*0.5);
													attacker_losses[config.units[i]] = attacker_losses[config.units[i]] + Math.ceil(armies2[army2_exists[1]][config.units[i]]*0.5);
													
													if (config.units[i] != attacker_obj.mobilised_manpower[1]) {
														removePops(arg2_user, lost_population, "soldiers");
														main.users[arg2_user].used_soldiers = main.users[arg2_user].used_soldiers - lost_population;
													} else {
														var excess_casualties = attacker_obj.mobilised_manpower[3] - lost_population;
														
														if (excess_casualties > 0) {
															removePops(arg2_user, lost_population, "workers");
															attacker_obj.used_workers = attacker_obj.used_workers - lost_population;
															attacker_obj.mobilised_manpower[0] = attacker_obj.mobilised_manpower[0] - lost_population;
															attacker_obj.mobilised_manpower[3] = attacker_obj.mobilised_manpower[3] - lost_population;
														} else {
															if (attacker_obj.mobilised_manpower[3] > 0) {
																removePops(arg2_user, attacker_obj.mobilised_manpower[0], "workers");
																attacker_obj.mobilised_manpower[0] = 0;
																attacker_obj.mobilised_manpower[3] = attacker_obj.mobilised_manpower[3] - lost_population;
															}
															removePops(arg2_user, Math.abs(excess_casualties), "soldiers");
															attacker_obj.used_soldiers = attacker_obj.used_soldiers - Math.abs(excess_casualties);
														}
													}
													attacker_casualties = attacker_casualties + lost_population;
												}
											} else {
												if (manoeuvre > Math.round(config.unit_stats[config.units[i]].mp*armies2[army2_exists[1]].mp)) {
													var lost_population = Math.ceil(current_roll/config.unit_stats[config.units[i]].dp)*config.unit_stats[config.units[i]].manpower_cost;
													console.log("[Triumph & Tragedy]: Lost Population: " + lost_population);
													armies2[army2_exists[1]][config.units[i]] = armies2[army2_exists[1]][config.units[i]] - Math.ceil(current_roll/config.unit_stats[config.units[i]].dp);
													attacker_losses[config.units[i]] = attacker_losses[config.units[i]] + Math.ceil(current_roll/config.unit_stats[config.units[i]].dp);
													
													if (config.units[i] != attacker_obj.mobilised_manpower[1]) {
														removePops(arg2_user, lost_population, "soldiers");
														main.users[arg2_user].used_soldiers = main.users[arg2_user].used_soldiers - lost_population;
													} else {
														var excess_casualties = attacker_obj.mobilised_manpower[3] - lost_population;
														
														if (excess_casualties > 0) {
															removePops(arg2_user, lost_population, "workers");
															attacker_obj.used_workers = attacker_obj.used_workers - lost_population;
															attacker_obj.mobilised_manpower[0] = attacker_obj.mobilised_manpower[0] - lost_population;
															attacker_obj.mobilised_manpower[3] = attacker_obj.mobilised_manpower[3] - lost_population;
														} else {
															if (attacker_obj.mobilised_manpower[3] > 0) {
																removePops(arg2_user, attacker_obj.mobilised_manpower[0], "workers");
																attacker_obj.mobilised_manpower[0] = 0;
																attacker_obj.mobilised_manpower[3] = attacker_obj.mobilised_manpower[3] - lost_population;
															}
															removePops(arg2_user, Math.abs(excess_casualties), "soldiers");
															attacker_obj.used_soldiers = attacker_obj.used_soldiers - Math.abs(excess_casualties);
														}
													}
													attacker_casualties = attacker_casualties + lost_population;
												}
												current_roll = 0;
											}
										}
									}
								}
								
								function attackerAPRoll (ap_amount) {
									var current_roll = randomNumber(0, ap_amount);
									attacker_roll = current_roll;
									
									for (var i = 0; i < config.units.length; i++) {
										if (armies1[army1_exists[1]][config.units[i]] > 0) {
											var manoeuvre = randomNumber(0, 20);
											if (current_roll > armies1[army1_exists[1]][config.units[i]]*config.unit_stats[config.units[i]].dp) {
												if (manoeuvre > Math.round(config.unit_stats[config.units[i]].mp*armies1[army1_exists[1]].mp)) {
													var lost_population = Math.ceil(armies1[army1_exists[1]][config.units[i]]*0.5)*config.unit_stats[config.units[i]].manpower_cost;
													console.log("[Triumph & Tragedy]: Lost Population: " + lost_population);
													armies1[army1_exists[1]][config.units[i]] = Math.floor(armies1[army1_exists[1]][config.units[i]]*0.5);
													defender_losses[config.units[i]] = defender_losses[config.units[i]] + Math.ceil(armies1[army1_exists[1]][config.units[i]]*0.5);
													
													if (config.units[i] != defender_obj.mobilised_manpower[1]) {
														removePops(arg2_user, lost_population, "soldiers");
														main.users[arg2_user].used_soldiers = main.users[arg2_user].used_soldiers - lost_population;
													} else {
														var excess_casualties = defender_obj.mobilised_manpower[3] - lost_population;
														
														if (excess_casualties > 0) {
															removePops(arg2_user, lost_population, "workers");
															defender_obj.used_workers = defender_obj.used_workers - lost_population;
															defender_obj.mobilised_manpower[0] = defender_obj.mobilised_manpower[0] - lost_population;
															defender_obj.mobilised_manpower[3] = defender_obj.mobilised_manpower[3] - lost_population;
														} else {
															if (defender_obj.mobilised_manpower[3] > 0) {
																removePops(arg2_user, defender_obj.mobilised_manpower[0], "workers");
																defender_obj.mobilised_manpower[0] = 0;
																defender_obj.mobilised_manpower[3] = 0;
															}
															removePops(arg2_user, Math.abs(excess_casualties), "soldiers");
															defender_obj.used_soldiers = defender_obj.used_soldiers - Math.abs(excess_casualties);
														}
													}
													defender_casualties = defender_casualties + lost_population;
												}
												current_roll = current_roll - armies1[army1_exists[1]][config.units[i]]*config.unit_stats[config.units[i]].dp;
											} else {
												if (manoeuvre > Math.round(config.unit_stats[config.units[i]].mp*armies1[army1_exists[1]].mp)) {
													var lost_population = Math.ceil(current_roll/config.unit_stats[config.units[i]].dp)*config.unit_stats[config.units[i]].manpower_cost;
													armies1[army1_exists[1]][config.units[i]] = armies1[army1_exists[1]][config.units[i]] - Math.ceil(current_roll/config.unit_stats[config.units[i]].dp);
													console.log("[Triumph & Tragedy]: Lost Population: " + lost_population);
													defender_losses[config.units[i]] = defender_losses[config.units[i]] + Math.ceil(current_roll/config.unit_stats[config.units[i]].dp);
													
													if (config.units[i] != defender_obj.mobilised_manpower[1]) {
														removePops(arg2_user, lost_population, "soldiers");
														main.users[arg2_user].used_soldiers = main.users[arg2_user].used_soldiers - lost_population;
													} else {
														var excess_casualties = defender_obj.mobilised_manpower[3] - lost_population;
														
														if (excess_casualties > 0) {
															removePops(arg2_user, lost_population, "workers");
															defender_obj.used_workers = defender_obj.used_workers - lost_population;
															defender_obj.mobilised_manpower[0] = defender_obj.mobilised_manpower[0] - lost_population;
															defender_obj.mobilised_manpower[3] = defender_obj.mobilised_manpower[3] - lost_population;
														} else {
															if (defender_obj.mobilised_manpower[3] > 0) {
																removePops(arg2_user, defender_obj.mobilised_manpower[0], "workers");
																defender_obj.mobilised_manpower[0] = 0;
																defender_obj.mobilised_manpower[3] = 0;
															}
															removePops(arg2_user, Math.abs(excess_casualties), "soldiers");
															defender_obj.used_soldiers = defender_obj.used_soldiers - Math.abs(excess_casualties);
														}
													}
													defender_casualties = defender_casualties + lost_population;
												}
												current_roll = 0;
											}
										}
									}
								}
								
								function attackerTurn () {
									var attacker_log = [];
									for (var i = 0; i < config.units.length; i++) {
										var initiative = randomNumber(0, 10);
										
										if (armies2[army2_exists[1]][config.units[i]] > 0) {
											console.log("[Triumph & Tragedy]: " + config.units[i] + " initiative: " + initiative);
											if (initiative <= Math.round(config.unit_stats[config.units[i]].ip*armies2[army2_exists[1]].ip)) {
												var units_ap = armies2[army2_exists[1]][config.units[i]]*config.unit_stats[config.units[i]].ap;
												attackerAPRoll(units_ap);
											}
										}
									}
								}
								
								function defenderTurn () {
									var defender_log = [];
									for (var i = 0; i < config.units.length; i++) {
										var initiative = randomNumber(0, 10);
										
										if (armies1[army1_exists[1]][config.units[i]] > 0) {
											console.log("[Triumph & Tragedy]: " + config.units[i] + " initiative: " + initiative);
											if (initiative <= Math.round(config.unit_stats[config.units[i]].ip*armies1[army1_exists[1]].ip)) {
												var units_ap = armies1[army1_exists[1]][config.units[i]]*config.unit_stats[config.units[i]].ap;
												defenderAPRoll(units_ap);
											}
										}
									}
								}
								
								var battleCount = 0;
								var battle_finished = false;
								var battleCount = 0;
								
								try {
									if (defender_dp > 0 && attacker_dp > 0) {
										var battle_number = 0;
										
										for (var i = 0; i < main.user_array.length; i++) {
											var user_obj = main.users[main.user_array[i]];
											for (var x = 0; x < user_obj.pops.pop_array.length; x++) {
												if (user_obj.pops.pop_array[x] == arg4_province.toString()) {
													if (user_obj.pops[user_obj.pops.pop_array[x]].battle_num == undefined) {
														user_obj.pops[user_obj.pops.pop_array[x]].battle_num = 0;
													}
													user_obj.pops[user_obj.pops.pop_array[x]].battle_num = user_obj.pops[user_obj.pops.pop_array[x]].battle_num + 1;
													battle_number = user_obj.pops[user_obj.pops.pop_array[x]].battle_num;
												}
											}
										}
										
										calculateApDp();
										
										var base_combat_order = ["ap", "dp"];
										
										base_combat_order = usr.modifiers.combat_order;
										base_combat_order = (ot_user.researched_technologies.includes(config.combat_order_switch_tech)) ? ["ap", "dp"] : base_combat_order;
										
										if (base_combat_order[0] == "ap") {
											attackerTurn();
											defenderTurn();
										} else {
											defenderTurn();
											attackerTurn();
										}
										
										var attacker_string = [];
										var defender_string = [];
										var results_string = [];
										var defender_retreat = false;
										var attacker_retreat = false;
											
										//arg0_user: defender
										//arg2_user: attacker
										
										var defending_war_exhaustion = 0;
										var attacking_war_exhaustion = 0;
										
										//Add casualties
										var all_wars = Object.keys(main.users.global.wars);
										
										for (var i = 0; i < all_wars.length; i++) {
											var is_involved = [false, false];
											var war_obj = main.users.global.wars[all_wars[i]];
											
											var usr_0_side = ""; //Defender
											var usr_2_side = ""; //Attacker
											
											for (var x = 0; x < war_obj.attackers.length; x++) {
												if (war_obj.attackers[x] == arg0_user) { //was defender in battle, attacker in war
													is_involved[0] = true;
													usr_0_side = "attacker";
													defending_war_exhaustion = Math.round((defender_casualties/(main.users[arg0_user].used_soldiers+main.users[arg0_user].mobilised_manpower[3]))*100*100)/100;
												}
												if (war_obj.attackers[x] == arg2_user) { //was attacker in battle, attacker in war
													is_involved[1] = true;
													usr_2_side = "attacker";
													attacking_war_exhaustion = Math.round((attacker_casualties/(main.users[arg2_user].used_soldiers+main.users[arg2_user].mobilised_manpower[3]))*100*100)/100;
												}
											}
											for (var x = 0; x < war_obj.defenders.length; x++) {
												if (war_obj.defenders[x] == arg0_user) { //was defender in battle, defender in war
													is_involved[0] = true;
													usr_0_side = "defender";
													defending_war_exhaustion = Math.round((defender_casualties/(main.users[arg0_user].used_soldiers+main.users[arg0_user].mobilised_manpower[3]))*100*100)/100;
												}
												if (war_obj.defenders[x] == arg2_user) { //was attacker in battle, defender in war
													is_involved[1] = true;
													usr_2_side = "defender";
													attacking_war_exhaustion = Math.round((attacker_casualties/(main.users[arg2_user].used_soldiers+main.users[arg2_user].mobilised_manpower[3]))*100*100)/100;
												}
											}
											
											if (is_involved[0] == true && is_involved[1] == true) {
												war_obj[usr_0_side + "_total_casualties"] = war_obj[usr_0_side + "_total_casualties"] + defender_casualties;
												war_obj[usr_2_side + "_total_casualties"] = war_obj[usr_2_side + "_total_casualties"] + attacker_casualties;
												war_obj[arg0_user + "_casualties"] = war_obj[arg0_user + "_casualties"] + defender_casualties;
												war_obj[arg2_user + "_casualties"] = war_obj[arg2_user + "_casualties"] + attacker_casualties;
											}
										}
										
										if (isNaN(defending_war_exhaustion) || defending_war_exhaustion < 0) {
											defending_war_exhaustion = 0;
										}
										if (isNaN(attacking_war_exhaustion) || attacking_war_exhaustion < 0) {
											attacking_war_exhaustion = 0;
										}
										if (attacking_war_exhaustion > 25) {
											attacking_war_exhaustion = 25;
										}
										if (defending_war_exhaustion > 25) {
											defending_war_exhaustion = 25;
										}
											
										if ((army1_dp < attacker_dp*0.5 || army1_dp == 0) && defender_casualties > attacker_casualties) {
											defender_retreat = true;
											//Start retreating
											if (battle_type == "land") {
												armies1[army1_exists[1]].province = randomElement(provinces[armies2[army2_exists[1]].province].adjacencies);
												
												//Check to make sure the user actually has enough manpower to retake the province
												var army_size_in_province = getTroopCountInProvince(arg4_province.toString(), arg2_user);
												var meets_occupation_requirements = (army_size_in_province >= getProvince(arg4_province.toString()).population*0.005) ? true : false;
												
												if (meets_occupation_requirements) {
													//Make sure that city_exists[1] doesn't just equal an empty set of inverted commas
													city_exists[1] = (city_exists[1] == "") ? false : city_exists[1];
													
													var already_occupied = false;
													var element_id = "";
													for (var i = 0; i < main.users.global.occupations.length; i++) {
														if (main.users.global.occupations[i][0] == arg4_province.toString() && main.users.global.occupations[i][2] == arg2_user) {
															already_occupied = true;
															main.users.global.occupations.splice(i, 1);
														}
													}
													
													if (!already_occupied) {
														main.users.global.occupations.push([arg4_province.toString(), city_exists[1], arg0_user, arg2_user]);
													}
													
													transferProvince(arg0_user, city_exists[1], arg2_user, arg5_msg);
													writeSVGS();
													
													setTimeout(function(){
														cacheSVG();
														setTimeout(function(){
															for (var i = 0; i < map_channel.length; i++) {
																displaySVG(returnChannel(map_channel[i]));
															}
														}, 2000);
													},5000);
												}
											} else if (battle_type == "sea") {
												armies1[army1_exists[1]].blockade_recovery_turns = 4;
												armies1[army1_exists[1]].state = "in harbour";
												armies1[army1_exists[1]].order = "in harbour";
												var all_blockades = Object.keys(main.users.global.blockades);
												
												for (var i = 0; i < all_blockades.length; i++) {
													for (var x = 0; x < main.users.global.blockades[all_blockades[i]].length; x++) {
														if (main.users.global.blockades[all_blockades[i]][x] == army1_exists[1]) {
															main.users.global.blockades[all_blockades[i]].splice(x, 1);
															main.users.global.blockade_arrays[all_blockades[i]].splice(x, 1);
														}
													}
												}
											}
										} else if ((army2_dp < defender_dp*0.5 || army2_dp == 0) && attacker_casualties > defender_casualties) {
											attacker_retreat = true;
											//Start retreating
											if (battle_type == "land") {
												armies2[army2_exists[1]].province = randomElement(provinces[armies2[army2_exists[1]].province].adjacencies);
											}
										}
										
										//Attacker string
										attacker_string.push("**" + attacker_obj.name + "** (" + armies2[army2_exists[1]].name + "):");
										attacker_string.push("");
										attacker_string.push("**Strength:**");
										attacker_string.push("`" + parseNumber(army2_ap) + " AP ¦ " + parseNumber(army2_dp) + " DP`");
										attacker_string.push("");
										for (var i = 0; i < config.units.length; i++) {
											if (armies2[army2_exists[1]][config.units[i]] > 0) {
												var loss_string = "";
												if (attacker_losses[config.units[i]] > 0) {
													loss_string = "(-" + parseNumber(attacker_losses[config.units[i]]) + ")";
												}
												
												var icon = "";
												for (var x = 0; x < config.unit_categories.length; x++) {
													for (var y = 0; y < config[config.unit_categories[x]].length; y++) {
														if (config[config.unit_categories[x]][y] == config.units[i]) {
															icon = config.unit_category_icons[x];
														}
													}
												}
												
												attacker_string.push(icon + " " + parseNumber(armies2[army2_exists[1]][config.units[i]]) + " " + config.units[i].split("_").join(" ").replace(/(^\w{1})|(\s{1}\w{1})/g, match => match.toUpperCase()) + " " + loss_string);
											}
										}
										
										attacker_string.push("");
										attacker_string.push("<:death:798009877469462530> Casualties: **" + parseNumber(attacker_casualties) + "**");
										
										//Defender string
										defender_string.push("**" + defender_obj.name + "** (" + armies1[army1_exists[1]].name + "):");
										defender_string.push("");
										defender_string.push("**Strength:**");
										defender_string.push("`" + parseNumber(army1_ap) + " AP ¦ " + parseNumber(army1_ap) + " DP`");
										defender_string.push("");
										for (var i = 0; i < config.units.length; i++) {
											if (armies1[army1_exists[1]][config.units[i]] > 0) {
												var loss_string = "";
												if (defender_losses[config.units[i]] > 0) {
													loss_string = "(-" + parseNumber(defender_losses[config.units[i]]) + ")";
												}
												
												var icon = "";
												for (var x = 0; x < config.unit_categories.length; x++) {
													for (var y = 0; y < config[config.unit_categories[x]].length; y++) {
														if (config[config.unit_categories[x]][y] == config.units[i]) {
															icon = config.unit_category_icons[x];
														}
													}
												}
												
												defender_string.push(icon + " " + parseNumber(armies1[army1_exists[1]][config.units[i]]) + " " + config.units[i].split("_").join(" ").replace(/(^\w{1})|(\s{1}\w{1})/g, match => match.toUpperCase()) + " " + loss_string);
											}
										}
										
										defender_string.push("");
										defender_string.push("<:death:798009877469462530> Casualties: **" + parseNumber(defender_casualties) + "**");
										
										//Results string
										results_string.push("**Dice Rolls:** " + attacker_obj.name + " - <:dice:798366909414375434> **" + parseNumber(attacker_roll) + "** ¦ " + defender_obj.name + " - <:dice:798366909414375434> **" + parseNumber(defender_roll) + "**");
										results_string.push("<:death:798009877469462530> Total Casualties: **" + parseNumber(defender_casualties+attacker_casualties) + "**");
										results_string.push("");
										
										if (defender_retreat) {
											results_string.push("<:retreat:798368936671576124> Due to heavy losses, the defending side was forced to retreat from the battlefield.");
											results_string.push("<:prestige:762428452636721202> **" + attacker_obj.culture + " Victory**");
										} else if (attacker_retreat) {
											results_string.push("<:retreat:798368936671576124> Due to heavy losses, the attacking side was forced to retreat from the battlefield.");
											results_string.push("<:prestige:762428452636721202> **" + defender_obj.culture + " Victory**");
										} else {
											results_string.push("<:small_arms:771909826505605162> Neither side was forced to retreat from the battle, and the fighting rages on!");
											results_string.push("<:prestige:762428452636721202> **Stalemate**");
										}
										
										results_string.push("");
										
										defender_obj.modifiers.war_exhaustion = defender_obj.modifiers.war_exhaustion + defending_war_exhaustion;
										attacker_obj.modifiers.war_exhaustion = attacker_obj.modifiers.war_exhaustion + attacking_war_exhaustion;
										
										results_string.push("<:infamy:716817688453709905> The defending side gained **" + defending_war_exhaustion.toFixed(2) + "** war exhaustion, whilst the attacking side gained **" + attacking_war_exhaustion.toFixed(2) + "** war exhaustion.");
										
										var battle_name = "Battle of " + province_name;
										if (battle_number > 1) {
											battle_name = ordinalSuffix(battle_number) + " Battle of " + province_name;
										}
										
										const battle_embed = new Discord.MessageEmbed()
											.setColor('#a98ac7')
											.setAuthor('Triumph & Tragedy:', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
											.setTitle('**' + battle_name + ':\n------------------**')
											.addFields(
												{ name: "<:attacker:798003900027240448> __**Attacker:**__\n---\n", value: attacker_string.join("\n"), inline: true },
												{ name: "<:defender:798003900081766420> __**Defender:**__\n---\n", value: defender_string.join("\n"), inline: true },
												{ name: "<:results:798006990638940160> __**Results:**__\n---\n", value: results_string.join("\n")}
											);
											
										returnChannels.send(war_channel, {embed: battle_embed});
										
										if (army1_ap == 0 || army1_dp == 0) {
											deleteArmy(arg0_user, "none", armies1[army1_exists[1]].name);
										}
										if (army2_ap == 0 || army2_dp == 0) {
											deleteArmy(arg2_user, "none", armies2[army2_exists[1]].name);
										}
										
										destroyBlockades();
									}
								} catch (e) {
									console.log(e);
								}
							}
						},5000);
					} else {
						if (arg5_msg != "none") {
							arg5_msg.channel.send("One of the players you have specified did not have an army of that name!");
						}
					}
				} else {
					if (arg5_msg != "none") {
						arg5_msg.channel.send("One of the users you have specified turned out to be stateless!");
					}
				}
			}
		}
		
		//Building & Crafting functions
		{
			function returnBuilding (arg0_name) {
				var name = arg0_name.toLowerCase();
				var has_name = [false, ""];
				
				//Soft match first
				for (var i = 0; i < config.buildings.length; i++) {
					if (config.buildings[i].toLowerCase().indexOf(name) != -1) {
						has_name = [true, config.buildings[i]];
					}
				}
				//Alias matches second
				for (var i = 0; i < config.buildings.length; i++) {
					if (config.building_stats[config.buildings[i]].aliases != undefined) {
						//Soft match first
						for (var x = 0; x < config.building_stats[config.buildings[i]].aliases.length; x++) {
							if (config.building_stats[config.buildings[i]].aliases[x].toLowerCase().indexOf(name) != -1) {
								has_name = [true, config.buildings[i]];
							}
						}
						//Hard match second
						for (var x = 0; x < config.building_stats[config.buildings[i]].aliases.length; x++) {
							if (config.building_stats[config.buildings[i]].aliases[x].toLowerCase() == name) {
								has_name = [true, config.buildings[i]];
							}
						}
					}
				}
				//Hard match last, including building and singular
				if (config.building_stats[name] != undefined) {
					has_name = [true, name];
				}
				for (var i = 0; i < config.buildings.length; i++) {
					if (config.building_stats[config.buildings[i]].name.toLowerCase() == name) {
						has_name = [true, config.buildings[i]];
					}
				}
				for (var i = 0; i < config.buildings.length; i++) {
					if (config.building_stats[config.buildings[i]].singular.toLowerCase() == name) {
						has_name = [true, config.buildings[i]];
					}
				}
				
				if (has_name[0] == false) {
					return "invalid";
				} else {
					return has_name[1];
				}
			}
			
			function returnCrafting (arg0_name) {
				var name = arg0_name.toLowerCase();
				var has_local_name = [false, ""];
				
				console.log("Has local name: " + has_local_name);
				
				//Soft match first
				for (var i = 0; i < config.units.length; i++) {
					if (config.units[i].toLowerCase().indexOf(name) != -1) {
						has_local_name = [true, config.units[i]];
					}
				}
				//Hard match second
				if (config.unit_stats[name] != undefined) {
					has_local_name = [true, name];
				}
				
				if (has_local_name[0] == false) {
					return "invalid";
				} else {
					return has_local_name[1];
				}
				console.log("DEBUG LOG: Unit name was returned as: " + has_local_name);
			}
			
			function buildRequest (arg0_user, arg1_message, arg2_name, arg3_costs, arg4_build_request, arg5_amount, arg6_city) {
				//Convert from parameters
				var usr = arg0_user;
				var msg = arg1_message;
				var building_name = arg2_name;
				var building_costs = arg3_costs;
				var building_request = arg4_build_request;
				var building_amount = arg5_amount;
				
				var inventory = usr.inventory;
				var print_results = [];
				var city_name = "";
				
				if (arg4_build_request == arg2_name) {
					var fatal_error = [false, ""];
					var local_singular = config.building_stats[arg2_name].singular.toLowerCase();
					var checks_passed = 0;
					
					//Get total resource cost
					var total_resource_cost = {};
					for (var i = 0; i < arg3_costs.length; i++) {
						var building_cost_modifier = usr.modifiers.building_cost;
						var pop_argument = false;
						
						for (var x = 0; x < config.pop_array.length; x++) {
							if (arg3_costs[i][1] == config.pop_array[x]) {
								pop_argument = true;
							}
						}
						if (pop_argument) {
							building_cost_modifier = 1;
						}
						
						for (var x = 0; x < arg5_amount; x++) {
							if (total_resource_cost[arg3_costs[i][1]] != undefined) {
								total_resource_cost[arg3_costs[i][1]] = total_resource_cost[arg3_costs[i][1]] + Math.ceil(arg3_costs[i][0]*building_cost_modifier);
							} else {
								total_resource_cost[arg3_costs[i][1]] = Math.ceil(arg3_costs[i][0]*building_cost_modifier);
							}
						}
					}
					
					//Implement checks system
					var all_resources = Object.keys(total_resource_cost);
					for (var i = 0; i < all_resources.length; i++) {
						var pop_argument = false;
						
						for (var x = 0; x < config.pop_array.length; x++) {
							if (all_resources[i] == config.pop_array[x]) {
								pop_argument = true;
							}
						}
						
						if (pop_argument) {
							var remaining_pops = usr[all_resources[i]] - usr["used_" + all_resources[i]];
							if (remaining_pops >= total_resource_cost[all_resources[i]]) {
								checks_passed++;
							} else {
								console.log("Pop check for " + all_resources[i] + " failed.");
							}
						} else {
							if (all_resources[i] == "money") {
								if (usr.money >= Math.ceil(total_resource_cost[all_resources[i]])) {
									checks_passed++;
								} else {
									console.log("Money check failed.");
								}
							} else {
								if (usr.inventory[all_resources[i]] >= Math.ceil(total_resource_cost[all_resources[i]])) {
									checks_passed++;
								} else {
									console.log(all_resources[i] + " check failed.");
								}
							}
						}
					}
					console.log("CHECKS PASSED: " + checks_passed);
					
					//Get base construction turns
					if (config.building_stats[arg2_name].construction_turns != undefined) {
						base_construction_turns = config.building_stats[arg2_name].construction_turns;
					} else {
						base_construction_turns = config.construction_turns;
					}
						
					//Soft match
					for (var i = 0; i < usr.cities.city_array.length; i++) {
						if (usr.cities[usr.cities.city_array[i]].name.toLowerCase().indexOf(arg6_city.toLowerCase()) != -1) {
							city_name = usr.cities.city_array[i];
						}
					}
					
					//Hard match
					for (var i = 0; i < usr.cities.city_array.length; i++) {
						if (usr.cities[usr.cities.city_array[i]].name.toLowerCase() == arg6_city.toLowerCase()) {
							city_name = usr.cities.city_array[i];
						}
					}
					
					//Check if enough building slots in the city are available
					if (checks_passed >= arg3_costs.length) {
						var valid_building = false;
						var local_building_category = "";
						
						//Check if building is valid
						for (var i = 0; i < usr.available_buildings.length; i++) {
							if (usr.available_buildings[i] == arg2_name) {
								valid_building = true;
							}
						}
						
						if (valid_building) {
							if (city_name == "") {
								fatal_error = [true, "The city you have specified proved more elusive than El Dorado!"];
							} else {
								//Get local building category
								for (var i = 0; i < config.building_categories.length; i++) {
									for (var x = 0; x < config[config.building_categories[i]].length; x++) {
										if (config[config.building_categories[i]][x] == arg2_name.toLowerCase()) {
											local_building_category = config.building_categories[i];
										}
									}
								}
								
								var buildings_under_construction = 0;
								var meets_separate_building_slots = false;
								var meets_maximum = false;
								
								for (var i = 0; i < usr.under_construction.length; i++) {
									if (usr.under_construction[i][2] == usr.cities[city_name].name) {
										if (usr.under_construction[i][1] == arg2_name.toLowerCase()) {
											buildings_under_construction = buildings_under_construction + usr.under_construction[i][0];
										}
									}
								}
								
								if (config.building_stats[arg2_name.toLowerCase()].separate_building_slots) {
									console.log("Constructions of this type ongoing: " + (usr.cities[city_name].buildings[arg2_name]+arg5_amount+buildings_under_construction));
									if ((parseInt(usr.cities[city_name].buildings[arg2_name])+parseInt(arg5_amount)+parseInt(buildings_under_construction)) <= (usr.modifiers[arg2_name.toLowerCase()])) {
										meets_separate_building_slots = true;
									}
								}
								
								var total_in_category_under_construction = 0;
								var total_buildings_in_category = 0;
								
								if (meets_maximum == false && meets_separate_building_slots == false) {
									for (var i = 0; i < usr.under_construction.length; i++) {
										var is_in_category = false;
										for (var x = 0; x < config[local_building_category].length; x++) {
											if (usr.under_construction[i][1] == config[local_building_category][x]) {
												is_in_category = true;
											}
										}
										
										if (is_in_category) {
											if (usr.under_construction[i][2] == city_name) {
												total_in_category_under_construction = total_in_category_under_construction + usr.under_construction[i][0];
											}
										}
									}
									for (var i = 0; i < config[local_building_category].length; i++) {
										if (usr.cities[city_name].buildings[config[local_building_category][i]] > 0) {
											total_buildings_in_category = total_buildings_in_category + usr.cities[city_name].buildings[config[local_building_category][i]];
										}
									}
								}
								
								if (config.building_stats[arg2_name.toLowerCase()].maximum != undefined) {
									if ((usr.cities[city_name].buildings[arg2_name]+arg5_amount+buildings_under_construction) <= config.building_stats[arg2_name.toLowerCase()].maximum) {
										meets_maximum = true;
									}
								} else {
									meets_maximum = true;
								}
								
								var building_category = "";
								for (var i = 0; i < config.building_categories.length; i++) {
									for (var x = 0; x < config[config.building_categories[i]].length; x++) {
										if (config[config.building_categories[i]][x] == arg2_name.toLowerCase()) {
											building_category = config.building_categories[i];
										}
									}
								}
								
								if (config[config.building_categories[i] + "_disable_slots"]) {
									meets_maximum = true;
								}
								
								if (config.building_stats[arg2_name.toLowerCase()].unlimited_slots != undefined) {
									if (config.building_stats[arg2_name.toLowerCase()].unlimited_slots) {
										meets_separate_building_slots = true;
										meets_maximum = true;
									}
								}
								
								console.log("Meets separate building slots: " + meets_separate_building_slots);
								console.log("Meets maximum: " + meets_maximum);
								
								if ((((total_in_category_under_construction+total_buildings_in_category+arg5_amount) <= (usr.cities[city_name][local_building_category + "_building_slots"]+usr.modifiers.extra_building_slots)) || meets_separate_building_slots) && meets_maximum) {
									var single_object = arg2_name;
									
									for (var a = 0; a < arg5_amount; a++) {
										for (var i = 0; i < arg3_costs.length; i++) {
											var pop_argument = false;
											
											for (var x = 0; x < config.pop_array.length; x++) {
												if (arg3_costs[i][1] == config.pop_array[x]) {
													pop_argument = true;
												}
											}
											
											if (pop_argument) {
												var remaining_pops = usr[arg3_costs[i][1]] - usr["used_" + arg3_costs[i][1]];
												if (remaining_pops >= arg3_costs[i][0]) {
													usr["used_" + arg3_costs[i][1]] = usr["used_" + arg3_costs[i][1]] + arg3_costs[i][0];
												}
											} else {
												if (arg3_costs[i][1] == "money") {
													usr.money = usr.money - Math.ceil(arg3_costs[i][0]*usr.modifiers.building_cost);
												} else {
													inventory[arg3_costs[i][1]] = inventory[arg3_costs[i][1]] - Math.ceil(arg3_costs[i][0]*usr.modifiers.building_cost);
												}
											}
										}
									}
									
									if (base_construction_turns != 0) {
										usr.under_construction.push([parseInt(arg5_amount), arg2_name, city_name, Math.ceil(base_construction_turns*usr.modifiers.construction_speed)]);
									} else {
										usr.cities[city_name].buildings[arg2_name]++;
									}
									usr.cities[city_name].building_count++;
									
									//Add building to count for easier access
									usr.buildings[arg2_name]++;
								} else {
									fatal_error = [true, "Your build request exceeded the maximum capacity for **" + local_building_category + "** in this city! Research additional technology first in order to raise your building cap regarding this building type."];
								}
							}
						} else {
							fatal_error = [true, "The building you have specified could not be found! Please make sure that you've spelled it correctly."];
						}
					} else {
						var resource_shortage_array = [];
						var manpower_shortage_array = [];
						for (var i = 0; i < all_resources.length; i++) {
							var shortage_amount = 0;
							var is_pop_type = false;
							
							//Get icon
							var icon = "";
							for (var x = 0; x < config.materials.length; x++) {
								if (config.materials[x] == all_resources[i]) {
									icon = config.resource_icons[x];
								}
							}
							
							//Check if type is pop
							for (var x = 0; x < config.pop_array; x++) {
								if (config.pop_array[x] == all_resources[i]) {
									is_pop_type = true;
								}
							}
							
							if (is_pop_type == false) {
								if (all_resources[i] != "money") {
									if (usr.inventory[all_resources[i]] < total_resource_cost[all_resources[i]]) {
										//Push shortages to per_turn_demand
										if (usr.ai) {
											if (usr.ai.per_turn_demand) {
												if (config.resource_buy_list.includes(all_resources[i])) {
													if (usr.ai.per_turn_demand[all_resources[i]]) {
														usr.ai.per_turn_demand[all_resources[i]] += Math.ceil(total_resource_cost[all_resources[i]]-usr.inventory[all_resources[i]]);
													} else {
														usr.ai.per_turn_demand[all_resources[i]] = Math.ceil(total_resource_cost[all_resources[i]]-usr.inventory[all_resources[i]]);
													}
												}
											}
										}
										
										resource_shortage_array.push(icon + " " + parseNumber(Math.ceil(total_resource_cost[all_resources[i]]-usr.inventory[all_resources[i]])) + " " + all_resources[i].split("_").join(" "));
									}
								} else {
									if (usr.money < total_resource_cost[all_resources[i]]) {
										resource_shortage_array.push("<:money:716817688718213192> " + parseNumber(total_resource_cost[all_resources[i]]));
									}
								}
							}
						}
						
						for (var i = 0; i < all_resources.length; i++) {
							var is_pop_type = false;
							//Check if type is pop
							for (var x = 0; x < config.pop_array.length; x++) {
								if (config.pop_array[x] == all_resources[i]) {
									is_pop_type = true;
								}
							}
							
							if (is_pop_type) {
								var remaining_local_pops = usr[all_resources[i]] - usr["used_" + all_resources[i]];
								if (remaining_local_pops < total_resource_cost[all_resources[i]]) {
									manpower_shortage_array.push("**" + parseNumber(Math.ceil(total_resource_cost[all_resources[i]]-remaining_local_pops)) + "** " + all_resources[i]);
								}
							}
						}
						
						console.log("Manpower Shortage Array: " + manpower_shortage_array);
						console.log("Resource Shortage Array: " + resource_shortage_array);
						console.log("Total Resource Cost:");
						console.log(total_resource_cost);
						console.log("Costs:");
						console.log(arg3_costs);
						
						if (manpower_shortage_array.length != 0) {
							fatal_error = [true, "You don't have enough manpower remaining to construct these buildings! You need an additional " + manpower_shortage_array.join(", ") + " in order to fulfil your build request."];
						}
						if (resource_shortage_array.length != 0) {
							if (usr.ai) usr.ai.failed_build_commands.push([building_amount, building_request, city_name]);
							fatal_error = [true, "**You don't have the resources to build this!**\n\nYou need an additional " + resource_shortage_array.join(", ") + " in order to fulfil your current building request."];
						}
					}
					
					//Error/success printing
					if (fatal_error[0] == false) {
						var building_term = "";
						if (arg5_amount == 1) {
							building_term = local_singular;
						} else {
							building_term = arg2_name;
						}
						console.log("City Name: " + city_name);
						print_results.push("You have successfully begun to construct " + arg5_amount + " **" + building_term + "** in " + usr.cities[city_name].name + "! They will be completed in **" + Math.ceil(base_construction_turns*usr.modifiers.construction_speed) + "** turn(s).");
						msg.channel.send(print_results.join("\n"));
					} else {
						msg.channel.send(fatal_error[1]);
					}
					
					console.log("Fatal Error: " + fatal_error);
				}
			}
			
			function build (arg0_user, arg1_msg, arg2_building, arg3_amount, arg4_city) {
				if (main.users[arg0_user] == undefined) {
					arg1_msg.channel.send("You don't have a country yet!");
				} else {
					var usr = main.users[arg0_user];
					var inventory = main.users[arg0_user].inventory;
					var result_string = [];
					var building_exists = false;
					for (var i = 0; i < config.buildings.length; i++) {
						if (arg2_building.toLowerCase() == config.buildings[i].toLowerCase()) {
							building_exists = true;
						}
					}
					
					if (building_exists) {
						//buildRequest(usr, arg1_msg, "farms", [[10, "lumber"], [5, "iron"], [1500, "money"], [500, "manpower"]], arg2_building, arg3_amount, arg4_city);
						if (arg3_amount == 0) {
							result_string.push("Why did you even issue this command?");
						} else if (arg3_amount < 0) {
							result_string.push("You can't build negative buildings!");
						}
						
						if (arg3_amount > 0) {
							if (arg3_amount <= 1000) {
								for (var i = 0; i < config.buildings.length; i++) {
									buildRequest(usr, arg1_msg, config.buildings[i], config.building_stats[config.buildings[i]].costs, arg2_building.toLowerCase(), Math.abs(parseInt(arg3_amount)), arg4_city);
								}
							} else {
								result_string.push("You cannot build more than 1.000 of a single building at once!");
							}
						}
					} else {
						result_string.push("The building you are attempting to build could not be found!");
					}
					
					if (result_string.length > 0) arg1_msg.channel.send(result_string.join("\n"));
				}
			}
			
			function craftRequest (arg0_user, arg1_message, arg2_name, arg3_costs, arg4_build_request, arg5_amount) {
				//Costs: [[5, "iron"],[1, "stone"]]
				var usr = arg0_user;
				var msg = arg1_message;
				var military = usr.military;
				var inventory = usr.inventory;
				var craft_request = arg4_build_request;
				var fatal_error = [false, ""];
				
				var ceiled_amount = Math.ceil(arg5_amount);
				var old_soldiers = usr.soldiers;
				var obsolete_recipe = true;
				//Convenience soldier count
				usr.soldiers = usr.soldiers*usr.manpower_percentage*usr.modifiers.national_manpower;
				
				if (craft_request == arg2_name) {
					for (var i = 0; i < usr.available_units.length; i++) {
						if (usr.available_units[i] == arg2_name) {
							obsolete_recipe = false;
						}
					}
					
					if (!obsolete_recipe) {
						if (!isNaN(ceiled_amount)) {
							var total_costs = {};
							for (var i = 0; i < ceiled_amount; i++) {
								for (var x = 0; x < config.unit_stats[craft_request].costs.length; x++) {
									var is_pop = false;
									
									for (var y = 0; y < config.pop_array.length; y++) {
										if (config.pop_array[y] == config.unit_stats[craft_request].costs[x][1]) {
											is_pop = true;
										}
									}
									
									//Pop handler
									if (is_pop) {
										total_costs[config.unit_stats[craft_request].costs[x][1]] = config.unit_stats[craft_request].manpower_cost*config.unit_stats[craft_request].quantity*ceiled_amount;
									} else {
										if (config.unit_stats[craft_request].costs[x][1].indexOf("_cp") != -1) { //CP handler
											if (total_costs[config.unit_stats[craft_request].costs[x][1]] != undefined) {
												total_costs[config.unit_stats[craft_request].costs[x][1]] = total_costs[config.unit_stats[craft_request].costs[x][1]] + Math.ceil(config.unit_stats[craft_request].costs[x][0]*usr.modifiers.training_cost);
											} else {
												total_costs[config.unit_stats[craft_request].costs[x][1]] = Math.ceil(config.unit_stats[craft_request].costs[x][0]*usr.modifiers.training_cost);
											}
										} else { //Resources & Money handler
											if (total_costs[config.unit_stats[craft_request].costs[x][1]] != undefined) {
												total_costs[config.unit_stats[craft_request].costs[x][1]] = total_costs[config.unit_stats[craft_request].costs[x][1]] + Math.ceil(config.unit_stats[craft_request].costs[x][0]*usr.modifiers.unit_cost);
											} else {
												total_costs[config.unit_stats[craft_request].costs[x][1]] = Math.ceil(config.unit_stats[craft_request].costs[x][0]*usr.modifiers.unit_cost);
											}
										}
									}
								}
							}
							
							
							var checks_passed = 0;
							var all_checks = Object.keys(total_costs);
							for (var i = 0; i < all_checks.length; i++) {
								if (usr.inventory[all_checks[i]] != undefined) {
									if (usr.inventory[all_checks[i]] >= total_costs[all_checks[i]]) {
										checks_passed++;
									}
								} else {
									var is_pop_cost = false;
									for (var x = 0; x < config.pop_array.length; x++) {
										if (config.pop_array[x] == all_checks[i]) {
											is_pop_cost = true;
										}
									}
									
									if (is_pop_cost) {
										var remaining_manpower = usr[all_checks[i]] - usr["used_" + all_checks[i]];
										if (remaining_manpower >= total_costs[all_checks[i]]) {
											checks_passed++;
										}
									} else {
										if (usr[all_checks[i]] >= total_costs[all_checks[i]]) {
											checks_passed++;
										}
									}
								}
							}
							
							if (checks_passed >= all_checks.length) {
								usr.military[craft_request] = usr.military[craft_request] + (ceiled_amount*config.unit_stats[craft_request].quantity);
								msg.channel.send("You have successfully trained **" + parseNumber(ceiled_amount) + "** regiments of " + craft_request + "!");
								
								//Subtract goods
								for (var i = 0; i < all_checks.length; i++) {
									var is_pop = false;
									for (var x = 0; x < config.pop_array.length; x++) {
										if (config.pop_array[x] == all_checks[i]) {
											is_pop = true;
										}
									}
									
									if (is_pop) {
										usr["used_" + all_checks[i]] = usr["used_" + all_checks[i]] + total_costs[all_checks[i]];
									} else {
										if (usr.inventory[all_checks[i]] != undefined) {
											usr.inventory[all_checks[i]] = usr.inventory[all_checks[i]] - total_costs[all_checks[i]];
										} else {
											usr[all_checks[i]] = usr[all_checks[i]] - total_costs[all_checks[i]];
										}
									}
								}
							} else {
								var is_pop_shortage = false;
								var is_cp_shortage = false;
								
								var shortage_object = {};
								var shortage_array = [];
								
								for (var i = 0; i < all_checks.length; i++) {
									if (usr.inventory[all_checks[i]] != undefined) {
										if (usr.inventory[all_checks[i]] < total_costs[all_checks[i]]) {
											shortage_object[all_checks[i]] = total_costs[all_checks[i]]-usr.inventory[all_checks[i]];
										}
									} else {
										var is_pop_object = false;
										for (var x = 0; x < config.pop_array.length; x++) {
											if (config.pop_array[x] == all_checks[i]) {
												is_pop_object = true;
											}
										}
										
										if (is_pop_object) {
											var available_manpower = usr[all_checks[i]]-usr["used_" + all_checks[i]];
											if (available_manpower < total_costs[all_checks[i]]) {
												shortage_object[all_checks[i]] = total_costs[all_checks[i]]-available_manpower;
												is_pop_shortage = true;
											}
										} else {
											if (all_checks[i].indexOf("_cp") != -1) {
												if (usr[all_checks[i]] < total_costs[all_checks[i]]) {
													shortage_object[all_checks[i]] = total_costs[all_checks[i]]-usr[all_checks[i]];
													is_cp_shortage = true;
												}
											} else {
												if (usr[all_checks[i]] < total_costs[all_checks[i]]) {
													shortage_object[all_checks[i]] = total_costs[all_checks[i]]-usr[all_checks[i]];
												}
											}
										}
									}
								}
								
								var all_shortages = Object.keys(shortage_object);
								if (!is_pop_shortage && !is_cp_shortage) {
									for (var i = 0; i < all_shortages.length; i++) {
										if (usr.inventory[all_shortages[i]] != undefined || all_shortages[i] == "money") {
											var icon = "";
											for (var x = 0; x < config.materials.length; x++) {
												if (config.materials[x] == all_shortages[i]) {
													icon = config.resource_icons[x];
												}
											}
											
											if (all_shortages[i] == "money") {
												icon = "<:money:716817688718213192>";
											}
											
											if (config.materials.includes(all_shortages[i])) {
												if (usr.ai) {
													if (usr.ai.per_turn_demand) {
														if (usr.ai.per_turn_demand[all_shortages[i]]) {
															usr.ai.per_turn_demand[all_shortages[i]] += shortage_object[all_shortages[i]];
														} else {
															usr.ai.per_turn_demand[all_shortages[i]] = shortage_object[all_shortages[i]];
														}
													}
												}
											}
											
											shortage_array.push(icon + " " + parseNumber(shortage_object[all_shortages[i]]) + " " + all_shortages[i].split("_").join(" "));
										}
									}
										
									fatal_error = [true, "You didn't have enough resources remaining to train this many regiments for this turn! You need an additional " + shortage_array.join(", ") + " to fuflil this crafting request."];
								} else {
									if (is_cp_shortage) {
										for (var i = 0; i < all_shortages.length; i++) {
											if (all_shortages[i].indexOf("_cp") != -1) {
												var cp_name = "";
												if (all_shortages[i] == "ground_units_cp") {
													cp_name = "Army CP";
												} else if (all_shortages[i] == "ground_artillery_cp") {
													cp_name = "Artillery CP";
												} else if (all_shortages[i] == "ground_vehicles_cp") {
													cp_name = "Armour CP";
												} else if (all_shortages[i] == "naval_units_cp") {
													cp_name = "Naval CP";
												} else if (all_shortages[i] == "aeroplanes_cp") {
													cp_name = "Air CP";
												}
												
												shortage_array.push("**" + parseNumber(shortage_object[all_shortages[i]]) + "** " + cp_name);
											}
										}
										
										if (!fatal_error[0]) {
											fatal_error = [true, "Your nation didn't have enough training facilities remaining to create this many forces for this turn! You need an additional " + shortage_array.join(", ") + " to fuflil this crafting request."];
										}
									}
									if (is_pop_shortage) {
										for (var i = 0; i < all_shortages.length; i++) {
											var is_pop = false;
											for (var x = 0; x < config.pop_array.length; x++) {
												if (all_shortages[i] == config.pop_array[x]) {
													is_pop = true;
												}
											}
											
											if (is_pop) {
												shortage_array.push("**" + parseNumber(shortage_object[all_shortages[i]]) + "** " + all_shortages[i].split("_").join(" "));
											}
										}
										
										if (!fatal_error[0]) {
											fatal_error = [true, "You didn't have enough manpower to train this many regiments! You need an additional " + shortage_array.join(", ") + " to fulfil this crafting request."];
										}
									}
								}
							}
						} else {
							fatal_error = [true, "You must specify a valid number of units to craft!"];
						}
					} else {
						fatal_error = [true, "The unit you have specified, **" + craft_request + "**, is either obsolete or has not yet been unlocked due to technological limitations!"];
					}
				}
				
				if (fatal_error[0]) {
					msg.channel.send(fatal_error[1]);
				}
				
				//Reset soldier count
				usr.soldiers = old_soldiers;
			}
			
			function craft (arg0_user, arg1_msg, arg2_crafting, arg3_amount) {
				if (main.users[arg0_user] == undefined) {
					arg1_msg.channel.send("You don't have a country yet!");
				} else {
					var usr = main.users[arg0_user];
					var military = main.users[arg0_user].military;
					var result_string = [];
					var unit_exists = false;
					
					for (var i = 0; i < config.units.length; i++) {
						if (arg2_crafting == config.units[i]) {
							unit_exists = true;
						}
					}
					if (unit_exists) {
						//craftRequest(usr, arg1_msg, "farms", [[10, "lumber"], [5, "iron"], [1500, "money"], [500, "manpower"]], arg2_building, arg3_amount);
						
						//Loop through config unit array
						for (var i = 0; i < config.units.length; i++) {
							craftRequest(usr, arg1_msg, config.units[i], config.unit_stats[config.units[i]].costs, arg2_crafting, Math.abs(parseInt(arg3_amount)), config.unit_stats[config.units[i]].quantity);
						}
					} else {
						result_string.push("No such recipe exists!");
					}
					
					if (result_string.length > 0) arg1_msg.channel.send(result_string.join("\n"));
				}
			}
			
		}
		
		//City commands
		{
			function moveCapital (arg0_user, arg1_city, arg2_msg) {
				var cities_string = [];
				
				if (main.users[arg0_user] != undefined) {
					var user_id = main.users[arg0_user];
					var cities = main.users[arg0_user].cities;
					
					var is_being_justified_on = false;
					for (var i = 0; i < main.user_array.length; i++) {
						if (main.users[main.user_array[i]].justifications.length > 0) {
							for (var x = 0; x < main.users[main.user_array[i]].justifications.length; x++) {
								if (main.users[main.user_array[i]].justifications[x][1] == user_id.id) {
									is_being_justified_on = true;
								}
							}
						}
					}

					console.log("[Triumph & Tragedy]: User is trying to move capital to: " + arg1_city + "!");
					
					var city_exists = false;
					var city_name = "";
					
					//Soft Match
					for (var i = 0; i < cities.city_array.length; i++) {
						if (cities[cities.city_array[i]].name.toLowerCase().indexOf(arg1_city.toLowerCase()) != -1) {
							city_exists = true;
							city_name = cities.city_array[i];
						}
					}
					
					//Hard match
					for (var i = 0; i < cities.city_array.length; i++) {
						if (cities[cities.city_array[i]].name.toLowerCase() == arg1_city.toLowerCase()) {
							city_exists = true;
							city_name = cities.city_array[i];
						}
					}
					
					if (city_exists) {
						if (cities[city_name].type == "capital") {
							arg2_msg.channel.send("The city you have specified is already your capital city!");
						} else {
							if (user_id.political_capital >= config.move_capital_cost) {
								if (!is_being_justified_on) {
									if (user_id.at_war.length == 0) {
										var is_accepted_culture = false;
										
										for (var i = 0; i < user_id.accepted_cultures.length; i++) {
											if (user_id.accepted_cultures[i] == user_id.pops[cities[city_name].province].culture) {
												is_accepted_culture = true;
											}
										}
										
										if (is_accepted_culture) {
											//Get rid of old capital
											for (var i = 0; i < cities.city_array.length; i++) {
												if (cities[cities.city_array[i]].type == "capital") {
													cities[cities.city_array[i]].type = "city";
												}
											}
											//Set new capital
											cities[city_name].type = "capital";
											main.users[arg0_user].capital_id = parseInt(cities[city_name].province);
											user_id.political_capital = user_id.political_capital - config.move_capital_cost;
											
											arg2_msg.channel.send("You have changed your capital city to **" + cities[city_name].name + "** for **" + config.move_capital_cost + "** <:political_capital:716817688525275257> Political Capital.");
										} else {
											arg2_msg.channel.send("The city you are moving your capital to must at least be of your accepted culture before you are able to make it your capital city!");
										}
									} else {
										arg2_msg.channel.send("You cannot move your capital city whilst at war! Focus on the war effort first.");
									}
								} else {
									arg2_msg.channel.send("You can't move your capital city whilst being justified on!");
								}
							} else {
								arg2_msg.channel.send("You don't have enough <:political_capital:716817688525275257> Political Capital to move your capital city! You need **" + (config.move_capital_cost-user_id.political_capital) + "** more.");
							}
						}
					} else {
						cities_string.push("This city does not exist!");
					}
				} else {
					msg.channel.send("You must have a nation in order to even have a capital city in the first place!");
				}
			}
			
			function newCity (arg0_user, arg1_name, arg2_type, arg3_message, arg4_province) {
				//Initialisation variables
				var msg = arg3_message;
				
				if (main.users[arg0_user] != undefined) {
					var user = main.users[arg0_user];
					var usr = main.users[arg0_user];
					var cities = user.cities;
					var city_name = arg1_name;
					var type = arg2_type;

					var city_exists = false;
					
					for (var i = 0; i < main.user_array.length; i++) {
						for (var x = 0; x < main.users[main.user_array[i]].cities.city_array.length; x++) {
							if (main.users[main.user_array[i]].cities.city_array[x].toLowerCase() == city_name.toLowerCase()) {
								city_exists = true;
							}
							if (main.users[main.user_array[i]].cities[main.users[main.user_array[i]].cities.city_array[x]] != undefined) {
								if (main.users[main.user_array[i]].cities[main.users[main.user_array[i]].cities.city_array[x]].name.toLowerCase() == city_name.toLowerCase()) {
									city_exists = true;
								}
							}
						}
					}

					if (city_exists) {
						if (msg != "none") {
							msg.channel.send("A city by this name already exists!");
						}
					} else {
						var available_housing_units = [];
						var resource_checks = 0;
						
						for (var i = 0; i < config.city_resources.length; i++) {
							var is_actual_material = false;
							for (var x = 0; x < config.materials.length; x++) {
								if (config.materials[x] == config.city_resources[i][1]) {
									is_actual_material = true;
								}
							}
							
							if (is_actual_material) {
								if (usr.inventory[config.city_resources[i][1]] >= config.city_resources[i][0]) {
									resource_checks++;
								}
							} else {
								if (usr[config.city_resources[i][1]] >= config.city_resources[i][0]) {
									resource_checks++;
								}
							}
						}
						
						for (var i = 0; i < usr.available_buildings.length; i++) {
							if (config.building_stats[usr.available_buildings[i]].houses != undefined) {
								available_housing_units.push(usr.available_buildings[i]);
							}
						}
						
						if (resource_checks >= config.city_resources.length) {
							var valid_province = false;
							if (arg4_province.match(/[a-zA-Z]/)) {
								if (msg != "none") {
									msg.channel.send("The province ID you have specified is invalid!");
								}
							} else {
								for (var i = 0; i < user.cities.province_array.length; i++) {
									if (arg4_province == user.cities.province_array[i]) {
										valid_province = true;
									}
								}
								for (var i = 0; i < user.pops.pop_array.length; i++) {
									if (arg4_province == user.pops.pop_array[i]) {
										valid_province = true;
									}
								}
								for (var i = 0; i < user.cities.city_array.length; i++) {
									if (user.cities[user.cities.city_array[i]].province == arg4_province) {
										valid_province = false;
									}
								}
								if (valid_province) {
									if (user.city_count < user.city_cap) {
										writeSave();
										if (type == "capital") {
											cities[city_name] = {};

											cities[city_name].name = city_name;
											cities[city_name].population = randomNumber(250000,1000000);
											cities[city_name].resource = randomElement(config.raw_resources);
											cities[city_name].type = "capital";
											if (msg != "none") {
												msg.channel.send("Capital city founded as **" + city_name + "** in Province **" + arg4_province + "**! Over **" + parseNumber(cities[city_name].population) + "** people are now legally residents of the capital city of **" + user.name + "**. Type `" + bot_prefix + 'city "' + city_name + '"` to view your new capital.');
											}

											cities.city_array.push(city_name);
										} else {
											cities[city_name] = {};

											cities[city_name].name = city_name;
											cities[city_name].type = "city";
											cities[city_name].population = randomNumber(250000,800000);
											if (msg != "none") {
												msg.channel.send("A new city was founded as **" + city_name + "**! Over **" + parseNumber(cities[city_name].population) + "** are now legally residents of the city of **" + city_name + "** in Province **" + arg4_province + "**. Type `" + bot_prefix + 'city "' + city_name + '"` to view your new city.');
											}

											cities.city_array.push(city_name);
										}
										
										//Cities
										cities[city_name].resource = randomElement(config.raw_resources);
										cities[city_name].buildings = {};
										
										//Add building slots based on building categories
										for (var i = 0; i < config.building_categories.length; i++) {
											console.log("Building slot modifiers for " + config.building_categories[i] + ": " + user.modifiers[config.building_categories[i] + "_building_slots"]);
											cities[city_name][config.building_categories[i] + "_building_slots"] = user.modifiers[config.building_categories[i] + "_building_slots"];
										}
										
										cities[city_name].building_cap = 0;
										cities[city_name].building_count = 0;
										cities[city_name].housing = 0;
										cities[city_name].province = arg4_province;
										
										//Air raid modifiers
										cities[city_name].attacked_this_turn = false;
										cities[city_name].anti_aircraft = 0;
										
										user.population = user.population + cities[city_name].population;
										
										//Set building variables
										for (var i = 0; i < config.buildings.length; i++) {
											cities[city_name].buildings[config.buildings[i]] = 0;
										}
										
										//Population
										var remaining_population = cities[city_name].population;
										user.pops.pop_array.push(arg4_province);
										user.pops[arg4_province] = {};
										
										for (var i = 0; i < config.pop_array.length; i++) {
											if (config.pops[config.pop_array[i]].specialised_pop) {
												console.log("[Triumph & Tragedy]: Generating " + config.pop_array[i] + " for " + city_name + "...");
												
												var randomPercentage = randomNumber((config.pops[config.pop_array[i]].chance*100)/2, (config.pops[config.pop_array[i]].chance*100)*2);
												console.log(randomPercentage + "% - " + Math.ceil(remaining_population*(randomPercentage/100)) + " Pops");
												
												user.pops[arg4_province][config.pop_array[i]] = Math.ceil(remaining_population*(randomPercentage/100));
												remaining_population = remaining_population - Math.ceil(remaining_population*(randomPercentage/100));
											}
										}
										
										cities[city_name].development = 0;
										user.pops[arg4_province]["workers"] = remaining_population;
										user.pops[arg4_province]["population"] = cities[city_name].population;
										
										//Culture and political concern
										if (user.pops[arg4_province].culture == undefined) {
											user.pops[arg4_province]["culture"] = user.culture;
										}
										user.pops[arg4_province]["political_concern"] = {};
										
										console.log("[Triumph & Tragedy]: The remaining population (" + remaining_population + "), were generated as workers.");
										
										console.log("[Triumph & Tragedy]: RGO Modifier: " + config.rgo_modifier);
										console.log("[Triumph & Tragedy]: City Resource generated as: " + cities[city_name].resource);
										user.modifiers[cities[city_name].resource] = user.modifiers[cities[city_name].resource] + config.rgo_modifier;
										
										for (var i = 0; i < config.city_resources.length; i++) {
											var is_actual_material = false;
											
											for (var x = 0; x < config.materials.length; x++) {
												if (config.materials[x] == config.city_resources[i][1]) {
													is_actual_material = true;
												}
											}
											
											if (is_actual_material) {
												usr.inventory[config.city_resources[i][1]] = usr.inventory[config.city_resources[i][1]] - config.city_resources[i][0];
											} else {
												usr[config.city_resources[i][1]] = usr[config.city_resources[i][1]] - config.city_resources[i][0];
											}
										}
										for (var i = 0; i < config.building_categories.length; i++) {
											cities[city_name][config.building_categories[i] + "_development"] = 0;
										}
										
										if (cities[city_name].type == "capital") {
											ignore_news = true;
											nextTurn(arg0_user);
											ignore_news = false;
										}
									} else {
										var next_limit = config.city_unlock_caps[usr.city_cap];
										if (msg != "none") {
											msg.channel.send("You do not have any land available on which to found a city! You need an additional **" + parseNumber(next_limit-usr.provinces) + "** provinces before you can unlock your next city.");
										}
									}
								} else {
									if (msg != "none") {
										msg.channel.send("You have specified a province you do not own!");
									}
								}
							}
						} else {
							var shortage_array = [];
							for (var i = 0; i < config.city_resources.length; i++) {
								var is_actual_material = false;
								var has_shortage = false;
								var shortage_amount = 0;
								var icon = "";
								
								for (var x = 0; x < config.materials.length; x++) {
									if (config.materials[x] == config.city_resources[i][1]) {
										is_actual_material = true;
									}
								}
								
								if (is_actual_material) {
									if (usr.inventory[config.city_resources[i][1]] < config.city_resources[i][0]) {
										has_shortage = true;
										shortage_amount = (config.city_resources[i][0]-usr.inventory[config.city_resources[i][1]]);
									}
								} else {
									if (usr[config.city_resources[i][1]] < config.city_resources[i][0]) {
										has_shortage = true;
										shortage_amount = (config.city_resources[i][0]-usr[config.city_resources[i][1]]);
									}
								}
								
								if (has_shortage) {
									if (config.city_resources[i][1] == "money") {
										icon = "<:money:716817688718213192>";
									} else {
										for (var x = 0; x < config.materials.length; x++) {
											if (config.materials[x] == config.city_resources[i][1]) {
												icon = config.resource_icons[x];
											}
										}
									}
									
									shortage_array.push("- " + icon + " " + parseNumber(shortage_amount) + " " + config.city_resources[i][1].split("_").join(" "));
								}
							}
							
							msg.channel.send("You don't have enough resources to found a city! Gather the following resources first:\n\n" + shortage_array.join("\n"));
						}
					}
				} else {
					msg.channel.send("You must have a country in order to found a city!");
				}
			}
			
			function renameCity (arg0_user, arg1_msg, arg2_old_name, arg3_new_name) {
				var msg = arg1_msg;
				var new_name = arg3_new_name;
				
				if (new_name.length <= 100) {
					if (new_name.length > 0) {
						if (main.users[arg0_user] != undefined) {
							var usr = main.users[arg0_user];
							var city_exists = [false, ""];
							var name_used = false;
							
							for (var i = 0; i < main.user_array.length; i++) {
								if (main.users[main.user_array[i]].cities.city_array.length > 0) {
									for (var x = 0; x < main.users[main.user_array[i]].cities.city_array.length; x++) {
										if (main.users[main.user_array[i]].cities[main.users[main.user_array[i]].cities.city_array[x]].name.toLowerCase() == new_name.toLowerCase()) {
											name_used = true;
										}
									}
								}
							}
							
							//Soft match first
							for (var i = 0; i < usr.cities.city_array.length; i++) {
								if (usr.cities[usr.cities.city_array[i]].name.toLowerCase().indexOf(arg2_old_name.toLowerCase()) != -1) {
									city_exists = [true, usr.cities.city_array[i]];
								}
							}
							
							//Hard match second
							for (var i = 0; i < usr.cities.city_array.length; i++) {
								if (usr.cities[usr.cities.city_array[i]].name.toLowerCase() == arg2_old_name.toLowerCase()) {
									city_exists = [true, usr.cities.city_array[i]];
								}
							}
							
							if (name_used == false) {
								if (city_exists[0]) {
									var old_name = usr.cities[city_exists[1]].name;
									usr.cities[city_exists[1]].name = new_name;
									msg.channel.send("You have renamed **" + old_name + "** to **" + new_name + "**!");
								} else {
									msg.channel.send("The city that you have specified doesn't exist!");
								}
							} else {
								msg.channel.send("The name you have specified is already in use by one of your cities, or another user's!");
							}
						} else {
							msg.channel.send("You don't even have a nation to begin with!");
						}
					} else {
						msg.channel.send("I don't even know how you managed to do that, but you can't rename your city to nothing.");
					}
				} else {
					msg.channel.send("Your city name exceeded the maximum character limit of 100 characters!");
				}
			}
			
			function printCities (arg0_user, arg1_msg) {
				var msg = arg1_msg;
				
				var cities_string = [];
				var cities = main.users[arg0_user].cities;

				cities_string.push("<:globe:716811246556545035> Country: **" + main.users[arg0_user].name + "**");
				cities_string.push("------------------ \n**Cities:**\n");
				//Print Capital City
				for (var i = 0; i < cities.city_array.length; i++) {
					if (cities[cities.city_array[i]].type == "capital") {
						cities_string.push("**" + cities[cities.city_array[i]].name + "** - Capital City `" + bot_prefix + 'city "' + cities[cities.city_array[i]].name + '"` ¦ `' + bot_prefix + "city-rename`");
						cities_string.push(" - Province: " + cities[cities.city_array[i]].province);
						cities_string.push(" - Population: " + parseNumber(cities[cities.city_array[i]].population));
						cities_string.push(" - RGO: " + cities[cities.city_array[i]].resource);
						cities_string.push(" - Building Cap: (" + cities[cities.city_array[i]].building_count + "/" + cities[cities.city_array[i]].building_cap + ")");
					}
				}

				//Print Capital City
				for (var i = 0; i < cities.city_array.length; i++) {
					if (cities[cities.city_array[i]].type == "city") {
						cities_string.push("**" + cities[cities.city_array[i]].name + "**: `" + bot_prefix + 'city "' + cities[cities.city_array[i]].name + '"` ¦ `' + bot_prefix + "city-rename` ¦ `" + bot_prefix + "move-capital`");
						cities_string.push(" - Province: " + cities[cities.city_array[i]].province);
						cities_string.push(" - Population: " + parseNumber(cities[cities.city_array[i]].population));
						cities_string.push(" - RGO: " + cities[cities.city_array[i]].resource);
						cities_string.push(" - Building Cap: (" + cities[cities.city_array[i]].building_count + "/" + cities[cities.city_array[i]].building_cap + ")");
					}
				}
				
				var city_string_embeds = [];
				var local_city_string = [];
				
				if (cities_string.length > 0) {
					for (var i = 0; i < cities_string.length; i++) {
						local_city_string.push(cities_string[i]);
						if (i != 0 || cities_string.length == 1) {
							if (i % 61 == 0 || i == cities_string.length-1) {
								const embed_city_list = new Discord.MessageEmbed()
									.setColor('#a98ac7')
									.setAuthor('Triumph & Tragedy:', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
									.setTitle('**City List:\n------------------**')
									.setThumbnail('https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
									.setDescription(local_city_string.join("\n"))
									.setTimestamp()
									.setFooter('To access this menu again, type ' + bot_prefix + 'city-list.', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png');
										
								city_string_embeds.push(embed_city_list);
								local_city_string = [];
							}
						}
					}
				}
					
				scrollMessage(msg, city_string_embeds, 0);
			}
			
			function printCity (arg0_user, arg1_city, arg2_msg) {
				//Convert from parameters
				var user_id = arg0_user;
				var usr = (main.users[arg0_user]) ? main.users[arg0_user] : undefined;
				var city_name = arg1_city.toLowerCase();
				var msg = arg2_msg;
				
				if (main.users[arg0_user] != undefined) {
					var cities_string = [];
					var buildings_string = [];

					var city_obj = getCity(city_name, user_id);
					console.log(city_name);
					
					if (user_id != "") {
						cities = main.users[user_id].cities;
					}
					
					if (city_obj) {
						var usr = main.users[city_obj[0]];
						var building_string;
						var avg_cities = Math.ceil(usr.total_cities/usr.country_age);
						var pc_price = Math.floor(config.urbanisation_cost*Math.pow(config.urbanisation_cost_percentile_growth, city_obj[2].development)*avg_cities);
						
						if (pc_price == 0) {
							pc_price = config.urbanisation_cost;
						}
						
						cities_string.push("<:globe:716811246556545035> Country: **" + main.users[city_obj[0]].name + "**");
						cities_string.push("Type `" + bot_prefix + "city-list` to view a full list of all your cities.");
						cities_string.push("");
						if (city_obj[2].type == "capital") {
							cities_string.push("City Options: `" + bot_prefix + "rename-city`");
							cities_string.push("Manage Buildings: `" + bot_prefix + "build` ¦ `" + bot_prefix + "demolish`"); 
						} else {
							cities_string.push("City Options: `" + bot_prefix + "move-capital` ¦ `" + bot_prefix + "rename-city`");
							cities_string.push("Manage Buildings: `" + bot_prefix + "build` ¦ `" + bot_prefix + "demolish`");
						}
						
						if (usr.country_age > 0) cities_string.push("`" + bot_prefix + "promote-urbanisation` - Gain an extra building slot in this city for **" + parseNumber(pc_price) + "** <:political_capital:716817688525275257> Political Capital.");
						
						cities_string.push("------------------ \n**" + city_obj[2].name + ":**\n");
						cities_string.push("**Province: ** <:provinces:716809229603700737> " + parseNumber(city_obj[2].province));
						cities_string.push("**Population: ** <:population:716817688810356826> " + parseNumber(city_obj[2].population));
						
						var rgo_icon = "";
						for (var i = 0; i < config.materials.length; i++) if (config.materials[i] == city_obj[2].resource) rgo_icon = config.resource_icons[i] + " ";
						
						cities_string.push("**RGO: **" + rgo_icon + city_obj[2].resource);
						cities_string.push(`- **${usr.modifiers.rgo_throughput-1 >= 0 ? "+" : ""}${Math.ceil((usr.modifiers.rgo_throughput-1)*100)}%** modifier to ${rgo_icon} ${city_obj[2].resource} production in this province.`);
						cities_string.push("**Development: ** <:development:716811992421367869> " + city_obj[2].development);
						cities_string.push("**Buildings: **");
						cities_string.push("---");
						cities_string.push("");
						
						var construction_obj = {
						};
						
						for (var i = 0; i < usr.under_construction.length; i++) {
							if (usr.under_construction[i][2] == city_obj[1]) {
								if (construction_obj[usr.under_construction[i][1]] != undefined) {
									construction_obj[usr.under_construction[i][1]] = construction_obj[usr.under_construction[i][1]] + usr.under_construction[i][0];
								} else {
									construction_obj[usr.under_construction[i][1]] = usr.under_construction[i][0];
								}
							}
						}
						console.log("ACTUAL CITY NAME: " + city_obj[1]);
						console.log(construction_obj);
						
						for (var i = 0; i < config.building_categories.length; i++) {
							var has_building_in_category = false;
							var total_buildings_in_category = 0;
							
							for (var x = 0; x < config[config.building_categories[i]].length; x++) {
								var building_name = config[config.building_categories[i]][x];
								if (city_obj[2].buildings[building_name] > 0) {
									has_building_in_category = true;
									total_buildings_in_category = total_buildings_in_category + city_obj[2].buildings[building_name];
								}
								for (var y = 0; y < usr.under_construction.length; y++) {
									if (usr.under_construction[y][1] == building_name && usr.under_construction[y][2] == city_obj[1]) {
										has_building_in_category = true;
									}
								}
							}
							
							if (config[config.building_categories[i] + "_always_display"]) {
								has_building_in_category = true;
							}
							
							console.log("Has building in category: " + config.building_categories[i]);
							if (has_building_in_category) {
								var people_housed = 0;
								var special_string = "";
								
								//Special header
								if (config.building_categories[i] == "housing") {
									for (var x = 0; x < config.buildings.length; x++) {
										if (config.building_stats[config.buildings[x]].houses != undefined) {
											people_housed = people_housed + (config.building_stats[config.buildings[x]].houses*city_obj[2].buildings[config.buildings[x]]);
										}
									}
									special_string = "\n• **Current Limit:** " + parseNumber(people_housed) + ". Cities cannot grow once they surpass their housing limit. Build more **housing** to increase this limit.";
								}
								
								if (config[config.building_categories[i] + "_disable_slots"] != true) {
									console.log("Slots disabled for " + config.building_categories[i] + ": false");
									buildings_string.push("**" + config.building_categories[i].split("_").join(" ").replace(/(^\w{1})|(\s{1}\w{1})/g, match => match.toUpperCase()) + ":** (" + total_buildings_in_category + "/" + (city_obj[2][config.building_categories[i] + "_building_slots"]+usr.modifiers.extra_building_slots) + ") " + special_string);
								} else {
									console.log("Slots disabled for " + config.building_categories[i] + ": true");
									buildings_string.push("**" + config.building_categories[i].split("_").join(" ").replace(/(^\w{1})|(\s{1}\w{1})/g, match => match.toUpperCase()) + ":** " + special_string);
								}
							}
							
							var category_keys = Object.keys(config.building_categories[i]);
							for (var x = 0; x < config[config.building_categories[i]].length; x++) {
								if (construction_obj[config[config.building_categories[i]][x]] > 0) {
									var local_amount = construction_obj[config[config.building_categories[i]][x]];
									console.log(local_amount + " " + config[config.building_categories[i]][x] + " was found to be under construction in this city.");
								}
								if (city_obj[2].buildings[config[config.building_categories[i]][x]] > 0 || construction_obj[config[config.building_categories[i]][x]] != undefined) {
									var building_name = config[config.building_categories[i]][x];
									var construction_string = "";
									
									if (construction_obj[building_name] != undefined) {
										construction_string = " `+" + parseNumber(construction_obj[building_name]) + " under construction`";
									}
									
									var slots_string = "";
									
									if (config[config.building_categories[i] + "_disable_slots"]) {
										var current_maximum = 0;
										
										if (config.building_stats[building_name].maximum != undefined) {
											if (usr.modifiers[building_name] < config.building_stats[building_name].maximum) {
												current_maximum = usr.modifiers[building_name];
											} else {
												current_maximum = config.building_stats[building_name].maximum;
											}
										} else {
											current_maximum = usr.modifiers[building_name];
										}
										
										slots_string = " (" + city_obj[2].buildings[building_name] + "/" + current_maximum + ")";
										
										if (config.building_stats[building_name].unlimited_slots) {
											slots_string = "";
										}
									}
									
									buildings_string.push(" - " + building_name + ": " + city_obj[2].buildings[building_name] + slots_string + construction_string);
								}
							}
						}
						
						console.log("Construction object: " + Object.keys(construction_obj));
						if (buildings_string.length == 0) {
							buildings_string.push(" - _No buildings in this city were found._");
						}
						for (var i = 0; i < buildings_string.length; i++) {
							cities_string.push(buildings_string[i]);
						}
						building_string = "\n**Building Cap: **(" + city_obj[2].building_count + "/" + city_obj[2].building_cap + ")";
					} else {
						cities_string.push("This city does not exist!");
					}
					
					if (city_obj) {
						var city_embeds = [];
						var local_city_string = [];
						
						if (cities_string.length > 0) {
							if (city_obj[2]) {
								for (var i = 0; i < cities_string.length; i++) {
									local_city_string.push(cities_string[i]);
									if (i != 0 || cities_string.length == 1) {
										if (i % 25 == 0 || i == cities_string.length-1) {
											const embed_city = new Discord.MessageEmbed()
												.setColor('#a98ac7')
												.setAuthor('Triumph & Tragedy:', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
												.setTitle('**City Overview for ' + city_obj[2].name + ': (Page ' + Math.ceil(i/25) + ' of ' + Math.ceil(cities_string.length/25) + ')\n------------------**')
												.setThumbnail('https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
												.setDescription(local_city_string.join("\n") + building_string)
												.setTimestamp()
												.setFooter('To access this menu again, type ' + bot_prefix + 'buy list.', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png');
												
											city_embeds.push(embed_city);
											local_city_string = [];
										}
									}
								}
							}
						}
						
						scrollMessage(msg, city_embeds, 0);
					} else {
						msg.channel.send("The city you have specified could not be found!");
					}
				} else {
					msg.channel.send("The city you have specified did not belong to this user!");
				}
			}
			
			function promoteUrbanisation (arg0_user, arg1_city, arg2_amount, arg3_building_category, arg4_message) {
				//Convert from parameters
				var user_id = arg0_user;
				var city_name = arg1_city.toLowerCase();
				var amount = parseInt(arg2_amount);
				var building_category = arg3_building_category;
				var msg = arg4_message;
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					var cities = usr.cities;
					var city_exists = [false, ""];
					
					var city_exists = false;
					var city_name = "";
					
					//Soft Match
					for (var i = 0; i < cities.city_array.length; i++) {
						if (cities[cities.city_array[i]].name.toLowerCase().indexOf(arg1_city.toLowerCase()) != -1) {
							city_exists = [true, cities.city_array[i]];
						}
					}
					
					//Hard match
					for (var i = 0; i < cities.city_array.length; i++) {
						if (cities[cities.city_array[i]].name.toLowerCase() == arg1_city.toLowerCase()) {
							city_exists = [true, cities.city_array[i]];
						}
					}
					
					if (city_exists[0]) {
						var total_pc_price = 0;
						var avg_cities = Math.ceil(usr.total_cities/usr.country_age);
						
						for (var i = 0; i < arg2_amount; i++) {
							var local_pc_price = Math.floor(config.urbanisation_cost*Math.pow(config.urbanisation_cost_percentile_growth, (cities[city_exists[1]].development+i))*avg_cities);
							total_pc_price = total_pc_price + local_pc_price;
						}
						
						if (total_pc_price == 0) {
							total_pc_price = config.urbanisation_cost;
						}
						
						console.log("[Triumph & Tragedy]: Total requested PC price for urbanisation edicts: " + total_pc_price);
						
						if (usr.political_capital >= total_pc_price) {
							var building_category_exists = [false, ""];
							//Soft match
							for (var i = 0; i < config.building_categories.length; i++) {
								if (config.building_categories[i].toLowerCase().indexOf(arg3_building_category.toLowerCase()) != -1) {
									building_category_exists = [true, config.building_categories[i]];
								}
							}
							
							//Hard match
							for (var i = 0; i < config.building_categories.length; i++) {
								if (config.building_categories[i].toLowerCase() == arg3_building_category.toLowerCase()) {
									building_category_exists = [true, config.building_categories[i]];
								}
							}
							
							if (building_category_exists[0]) {
								if (config[building_category_exists[1] + "_disable_slots"]) {
									building_category_exists = ["invalid", building_category_exists[1]];
								}
							}
							
							if (building_category_exists[0]) {
								if (usr.country_age != 0) {
									for (var i = 0; i < arg2_amount; i++) {
										var avg_cities = Math.ceil(usr.total_cities/usr.country_age);
										var pc_price = Math.floor(config.urbanisation_cost*Math.pow(config.urbanisation_cost_percentile_growth, cities[city_exists[1]].development)*avg_cities);
										usr.political_capital = usr.political_capital - pc_price;
										cities[city_exists[1]].development++;
										cities[city_exists[1]][building_category_exists[1] + "_development"]++;
									}
									
									if (arg2_amount > 1) {
										msg.channel.send("You have issued **" + parseNumber(arg2_amount) + "** urbanisation edicts for the city of **" + cities[city_exists[1]].name + "** for **" + parseNumber(Math.ceil(total_pc_price)) + "** <:political_capital:716817688525275257> Political Capital! People have begun flocking to your city to start working and constructing new buildings, thereby expanding the overall building cap in the city.");
									} else {
										if (arg2_amount == 1) {
											msg.channel.send("You have issued an urbanisation edict for the city of **" + cities[city_exists[1]].name + "** for **" + parseNumber(Math.ceil(total_pc_price)) + "** <:political_capital:716817688525275257> Political Capital! People have begun flocking to your city to start working and constructing new buildings, thereby expanding the overall building cap in the city for **" + building_category_exists[1] + "**.");
										} else if (arg2_amount == 0) {
											msg.channel.send("You can't issue zero urbanisation edicts!");
										} else {
											msg.channel.send("You can't issue negative urbanisation edicts! Who are you anyway, Pol Pot?");
										}
									}
									
									console.log(usr.cities);
									console.log(getCity(city_name));
								} else {
									msg.channel.send("You must wait until next turn for your new government to start issuing edicts!");
								}
							} else if (building_category_exists[0] == "invalid") {
								msg.channel.send("The building category you have specified, **" + arg3_building_category + "** already has unlimited building slots, or operates by a different system entirely!");
							} else {
								msg.channel.send("The building category you have specified, **" + arg3_building_category + "** proved to be entirely nonexistent.");
							}
						} else {
							if (total_pc_price.toString().indexOf("e") != -1) {
								msg.channel.send("You don't have enough Political Capital to issue this many urbanisation edicts! You need **infinite** <:political_capital:716817688525275257> Political Capital before being able to develop your city further to the extent that you have requested.");
							} else {
								msg.channel.send("You don't have enough Political Capital to issue this many urbanisation edicts! You need another **" + parseNumber(Math.ceil(total_pc_price-usr.political_capital)) + "** <:political_capital:716817688525275257> Political Capital before being able to develop your city further to the extent that you have requested.");
							}
						}
					} else {
						msg.channel.send("The city you have specified proved more elusive than El Dorado!");
					}
				} else {
					msg.channel.send("You must have a country before you can print out edicts to encourage urbanisation!");
				}
			}
			
			function transferProvince (arg0_user, arg1_id, arg2_user, arg3_message) { //$transfer-province [@original user] [@user] <id> 
				var msg = arg3_message;
				
				if (main.users[arg0_user] != undefined && main.users[arg2_user] != undefined) {
					if (arg0_user != arg2_user) {
						var usr = main.users[arg0_user];
						var ot_user = main.users[arg2_user];
						
						var cities1 = main.users[arg0_user].cities;
						var cities2 = main.users[arg2_user].cities;
						
						var city_exists = [false, undefined];
						var was_capital = false;
						
						console.log("[Triumph & Tragedy]: City Key: " + cities1.city_array);
						for (var i = 0; i < cities1.city_array.length; i++) {
							var city_element = cities1.city_array[i];
							console.log("[Triumph & Tragedy]: City Array of " + arg0_user + ": " + cities1.city_array);
							console.log("[Triumph & Tragedy]: Current city array element: " + city_element);
							console.log("[Triumph & Tragedy]: Cities1 Object: " + cities1);
							
							if (cities1[city_element] != undefined) {
								console.log("[Triumph & Tragedy]: City Object: " + cities1[city_element]);
								console.log(cities1[cities1.city_array[i]].province);
								if (cities1[cities1.city_array[i]].province.toString() == arg1_id.toString()) {
									city_exists = [true, cities1.city_array[i]];
								}
							}
						}
						
						console.log("[Triumph & Tragedy]: Province ID specified: " + arg1_id);
						
						if (city_exists[0]) {
							console.log("[Triumph & Tragedy]: City Debug Name: " + city_exists[1]);
							var city_name = cities1[city_exists[1]].name;
							var city_population = cities1[city_exists[1]].population;
							var city_resource = cities1[city_exists[1]].resource;
							
							main.users[arg0_user].modifiers[city_resource] = main.users[arg0_user].modifiers[city_resource] - config.rgo_modifier;
							main.users[arg2_user].modifiers[city_resource] = main.users[arg2_user].modifiers[city_resource] + config.rgo_modifier;
							
							main.users[arg0_user].population = main.users[arg0_user].population - city_population;
							main.users[arg2_user].population = main.users[arg2_user].population + city_population;
							
							main.users[arg2_user].provinces++;
							main.users[arg0_user].provinces--;
							
							main.users[arg2_user].pops[arg1_id] = main.users[arg0_user].pops[arg1_id];
							
							if (cities1[city_exists[1]].type == "capital") {
								cities1[city_exists[1]].type = "city";
								was_capital = true;
							}
							
							cities2[city_exists[1]] = cities1[city_exists[1]];
							
							for (var i = 0; i < main.users[arg0_user].cities.province_array.length; i++) {
								if (main.users[arg0_user].cities.province_array[i] == cities1[city_exists[1]].province) {
									main.users[arg0_user].cities.province_array.splice(i, 1);
								}
							}
							
							main.users[arg2_user].cities.province_array.push(cities1[city_exists[1]].province);
							main.users[arg2_user].cities.city_array.push(city_exists[1]);
							main.users[arg2_user].pops.pop_array.push(cities1[city_exists[1]].province);
							
							delete main.users[arg0_user].pops[cities1[city_exists[1]].province];
							delete cities1[city_exists[1]];
							
							for (var i = 0; i < cities1.city_array.length; i++) {
								if (cities1.city_array[i] == city_exists[1]) {
									cities1.city_array.splice(i, 1);
								}
							}
							console.log("[Triumph & Tragedy]: Original owner city_array: " + cities1.city_array);
							
							main.users[arg0_user].pops.pop_array = Object.keys(main.users[arg0_user].pops);
							main.users[arg0_user].pops.pop_array.pop();
							console.log(main.users[arg0_user].pops.pop_array);
							
							if (was_capital) {
								if (main.users[arg0_user].cities.city_array.length > 0) {
									var capital_moved = false;
									for (var i = 0; i < main.users[arg0_user].cities.city_array.length; i++) {
										if (main.users[arg0_user].cities[main.users[arg0_user].cities.city_array[i]] != undefined) {
											if (main.users[arg0_user].cities[main.users[arg0_user].cities.city_array[i]].type == "city") {
												if (capital_moved == false) {
													//Move capital to somewhere else if possible
													capital_moved = true;
													main.users[arg0_user].cities[main.users[arg0_user].cities.city_array[i]].type = "capital";
												}
											}
										}
									}
								}
							}
							
							if (arg3_message != "none" && arg3_message != undefined) {
								msg.channel.send("The city of **" + city_name + "** fell into the hands of **" + main.users[arg2_user].name + "**!");
							}
						} else {
							main.users[arg2_user].provinces++;
							main.users[arg0_user].provinces--;
							
							for (var i = 0; i < main.users[arg0_user].pops.pop_array.length; i++) {
								if (main.users[arg0_user].pops.pop_array[i] == arg1_id) {
									main.users[arg0_user].pops.pop_array.splice(i, 1);
								}
							}
							for (var i = 0; i < main.users[arg0_user].cities.province_array.length; i++) {
								if (main.users[arg0_user].cities.province_array[i] == arg1_id) {
									main.users[arg0_user].cities.province_array.splice(i, 1);
								}
							}
							
							main.users[arg2_user].pops.pop_array.push(arg1_id);
							main.users[arg2_user].pops[arg1_id] = main.users[arg0_user].pops[arg1_id];
							delete main.users[arg0_user].pops[arg1_id];
							
							if (arg3_message != "none" && arg3_message != undefined) {
								msg.channel.send("Province **" + arg1_id + "** fell into the hands of **" + main.users[arg2_user].name + "**!");
							}
						}
						
						//Check if province is occupied
						var province_occupied = false;
						for (var i = 0; i < main.users.global.occupations.length; i++) {
							if (main.users.global.occupations[i][0] == arg1_id) {
								province_occupied = true;
							}
						}
						
						if (province_occupied) {
							var occ_colour = main.users[arg2_user].colour.map((x) => x);
							for (var i = 0; i < occ_colour.length; i++) {
								occ_colour[i] = occ_colour[i] + 20;
							}
							original_svg = processSVG([occ_colour, arg1_id], original_svg);
						} else {
							var new_colour = main.users[arg2_user].colour;
							original_svg = processSVG([new_colour, arg1_id], original_svg);
						}
					} else {
						if (arg3_message != "none" && arg3_message != undefined) {
							msg.channel.send("You can't capture your own city!");
						}
					}
				} else {
					if (arg3_message != "none" && arg3_message != undefined) {
						msg.channel.send("One of the users you have specified is stateless!");
					}
				}
			}
		}
		
		//Colonisation commands
		{
			function cancelColonisation (arg0_user, arg1_id, arg2_message) {
				var msg = arg2_message;
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					if (isNaN(parseInt(arg1_id)) == false) {
						if (usr.expeditions[parseInt(arg1_id)] != undefined) {
							msg.channel.send("You have removed Colonial Charter **#" + arg1_id + "** from your current colonisation efforts. Type `" + bot_prefix + "colonisation` for a more updated list of your current colonial ventures.");
							usr.expeditions.splice(parseInt(arg1_id), 1);
						} else {
							msg.channel.send("That slot was not a valid numeric ID! Type `" + bot_prefix + "colonisation` to check which colonial charters may be cancelled.");
						}
					} else {
						msg.channel.send("You must specify a valid numeric ID! Type `" + bot_prefix + "colonisation` to check which colonial charters can be cancelled.");
					}
				} else {
					msg.channel.send("You need to have a nation before you can even colonise in the first place!");
				}
			}
		}
		
		//Customisation commands
		{
			function lockVassalCustomisation (arg0_overlord, arg1_mode, arg2_msg) { //Runs each time logicCheck() is called with "none" parameters
				//Convert from parameters
				var overlord_id = main.users[arg0_overlord];
				var lock_mode = arg1_mode;
				var msg = arg2_msg;
				
				//Check to see if overlord is defined
				if (main.users[arg0_overlord] != undefined) {
					var usr = main.users[arg0_overlord];
					
					if (lock_mode == "lock") {
						usr.vassal_customisation_locked = true;
						if (msg != "none") {
							msg.channel.send("**You have successfully locked national customisation for all your vassals.**");
						}
					} else if (lock_mode == "unlock") {
						usr.vassal_customisation_locked = false;
						if (msg != "none") {
							msg.channel.send("**You have successfully unlocked national customisation for all your vassals.**");
						}
					}
					
					if (usr.vassal_customisation_locked) {
						//Disable customisation for all vassals
						for (var i = 0; i < usr.vassals.length; i++) {
							var local_vassal = main.users[usr.vassals[i]];
							local_vassal.customisation_locked = true;
						}
					} else {
						//Enable customisation for all vassals
						for (var i = 0; i < usr.vassals.length; i++) {
							var local_vassal = main.users[usr.vassals[i]];
							local_vassal.customisation_locked = false;
						}
					}
				} else {
					if (msg != "none") {
						msg.channel.send("You must have a country before being able to lock/unlock the customisation of your vassals!");
					}
				}
			}
			
			function renameVassal (arg0_overlord, arg1_vassal, arg2_new_name, arg3_msg) {
				//Convert from parameters
				var overlord_id = arg0_overlord;
				var vassal_id = arg1_vassal;
				var new_vassal_name = parseString(arg2_new_name);
				var msg = arg3_msg;
				
				if (main.users[arg0_overlord] != undefined) {
					var usr = main.users[overlord_id];
					if (usr.vassals.length > 0) {
						if (checkVassals(usr.id, vassal_id)) {
							var ot_user = main.users[vassal_id];
							
							msg.channel.send("You have successfully changed the name of your vassal **" + ot_user.name + "** to **" + new_vassal_name + "**.");
							ot_user.name = new_vassal_name;
						} else {
							msg.channel.send("You aren't Greece. You can't just change people's names like that; specify an actual vassal in your possession!");
						}
					} else {
						msg.channel.send("You don't even have any vassals to rename!");
					}
				} else {
					msg.channel.send("You must have a country first before you can go around renaming vassals!");
				}
			}
			
			function renameVassalCity (arg0_overlord, arg1_city_name, arg2_new_name, arg3_msg) {
				//Convert from parameters
				var overlord_id = arg0_overlord;
				var old_city_name = arg1_city_name;
				var new_city_name = arg2_new_name;
				var msg = arg3_msg;
				
				//Check to make sure that overlord is defined and a valid owner of the vassal city
				if (main.users[arg0_overlord] != undefined) {
					var usr = main.users[overlord_id];
					if (usr.vassals.length > 0) {
						var city_obj = getCity(old_city_name);
						
						//Check to see if the city actually exists
						if (city_obj) {
							if (checkVassals(usr.id, city_obj[0])) {
								//Check to see if the name chosen is actually compatible or not
								if (!cityNameUsed(parseString(new_city_name))) {
									var actual_city_obj = main.users[city_obj[0]].cities[city_obj[1]];
									msg.channel.send("You have successfully renamed **" + actual_city_obj.name + "**, **" + main.users[city_obj[0]].name + "** to **" + parseString(new_city_name) + "**!");
									actual_city_obj.name = parseString(new_city_name);
								} else {
									msg.channel.send("The city name you have chosen, **" + parseString(new_city_name) + "**, is already in use!");
								}
							} else {
								msg.channel.send("The city you have specified, **" + city_obj[2].name + "**, belongs to **" + main.users[city_obj[0]].name + "**, not one of your vassals!");
							}
						} else {
							msg.channel.send("The city you have specified, **" + old_city_name + "** proved about as elusive as El Dorado!");
						}
					} else {
						msg.channel.send("You don't have any vassals in your possession!");
					}
				} else {
					msg.channel.send("You must have a nation first before you can forcibly impose your new city names on others!");
				}
			}
			
			function renameVassalCulture (arg0_overlord, arg1_vassal, arg2_new_name, arg3_msg) {
				//Convert from parameters
				var overlord_id = arg0_overlord;
				var usr = (main.users[arg0_overlord]) ? main.users[arg0_overlord] : undefined;
				var vassal_id = arg1_vassal;
				var new_vassal_culture_name = arg2_new_name;
				var msg = arg3_msg;
				
				//Check to make sure that the overlord is defined
				if (main.users[arg0_overlord] != undefined) {
					if (usr.vassals.length > 0) {
						if (checkVassals(usr.id, vassal_id)) {
							renameCulture(vassal_id, parseString(new_vassal_culture_name), msg, true);
						} else {
							msg.channel.send("You cannot rename the culture of someone that is not your vassal!");
						}
					} else {
						msg.channel.send("You don't even have any vassals with which to toy around!");
					}
				} else {
					msg.channel.send("You must have a nation first before dictating the cultures of others!");
				}
			}
			
			function setColour (arg0_user, arg1_r, arg2_g, arg3_b, arg4_msg, arg5_vassal) {
				//Convert from parameters
				var user_id = arg0_user;
				var r = parseInt(arg1_r);
				var g = parseInt(arg2_g);
				var b = parseInt(arg3_b);
				var msg = arg4_msg;
				var vassal_string = (arg5_vassal) ? "vassal's" : "";
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					
					if (usr.colour_locked == false) {
						if (r >= 20 && g >= 20 && b >= 20) {
							if ((r > 175 && r < 185) || (g > 175 && g < 185) || (b > 175 && b < 185)) {
								if (msg != "none") {
									msg.channel.send("Only RGB values between 20-175 and 185-255 are accepted!");
								}
							} else {
								var colour_taken = false;
								
								for (var i = 0; i < main.user_array.length; i++) {
									if (main.users[main.user_array[i]].colour == [Math.round(r), Math.round(g), Math.round(b)]) {
										colour_taken = true;
									}
								}
								
								if (colour_taken == false) {
									if (!(vassal_string == "" && usr.customisation_locked)) {
										usr.colour = [parseInt(Math.round(r)), parseInt(Math.round(g)), parseInt(Math.round(b))];
										if (msg != "none") {
											msg.channel.send("You have set your " + vassal_string + " RGB colour to **" + usr.colour.join(", ") + "**.");
										}
										var all_provinces = [];
										for (var i = 0; i < usr.pops.pop_array.length; i++) {
											var already_included = false;
											for (var x = 0; x < all_provinces.length; x++) {
												if (all_provinces[x] == usr.pops.pop_array[i]) {
													already_included = true;
												}
											}
											
											if (already_included == false) {
												all_provinces.push(usr.pops.pop_array[i]);
											}
										}
										for (var i = 0; i < usr.cities.province_array.length; i++) {
											var already_included = false;
											for (var x = 0; x < all_provinces.length; x++) {
												if (all_provinces[x] == usr.cities.province_array[i]) {
													already_included = true;
												}
											}
											
											if (already_included == false) {
												all_provinces.push(usr.cities.province_array[i]);
											}
										}
										
										for (var i = 0; i < all_provinces.length; i++) {
											original_svg = processSVG([[usr.colour[0], usr.colour[1], usr.colour[2]], all_provinces[i]], original_svg);
										}
										for (var i = 0; i < main.users.global.occupations.length; i++) {
											if (main.users.global.occupations[i][3] == usr.id) {
												original_svg = processSVG([[usr.colour[0]+20, usr.colour[1]+20, usr.colour[2]+20], main.users.global.occupations[i][0]], original_svg);
											}
										}
										
										writeSVGS();
										setTimeout(function(){
											cacheSVG();
											setTimeout(function(){
												for (var i = 0; i < map_channel.length; i++) {
													displaySVG(returnChannel(map_channel[i]));
												}
											}, 2000);
										},5000);
									} else {
										if (msg != "none") {
											msg.channel.send("Your overlord, **" + getOverlord(user_id) + "**, has disabled vassal customisation, including the changing of your colour!");
										}
									}
								} else {
									if (msg != "none") {
										msg.channel.send("The colour you have specified was already taken by another user! Please specify another colour instead.");
									}
								}
							}
						} else {
							if (msg != "none") {
								msg.channel.send("Only RGB values between 20-175 and 185-255 are accepted!");
							}
						}
					} else {
						if (msg != "none") {
							msg.channel.send("Your colour has been locked into place by moderator action. You are unable to change your colour.");
						}
					}
				} else {
					if (msg != "none") {
						msg.channel.send("You must first have a country in order to change your colour!");
					}
				}
			}
			
			function setVassalColour (arg0_overlord, arg1_vassal, arg2_r, arg3_g, arg4_b, arg5_msg) {
				//Convert from parameters
				var overlord_id = arg0_overlord;
				var vassal_id = arg1_vassal;
				var r = parseInt(arg2_r);
				var g = parseInt(arg3_g);
				var b = parseInt(arg4_b);
				var msg = arg5_msg;
				
				//Check to make sure that the overlord is defined
				if (main.users[arg0_overlord] != undefined) {
					var usr = main.users[arg0_overlord];
					if (usr.vassals.length > 0) {
						if (checkVassals(usr.id, vassal_id)) {
							setColour(vassal_id, r, g, b, msg, true);
						} else {
							msg.channel.send("You can't commandeer the strings of someone that isn't your puppet or doesn't even exist!");
						}
					} else {
						msg.channel.send("You currently don't have any vassals that you can boss around! Go get some.");
					}
				} else {
					msg.channel.send("You need to have a nation first before you can hold vassals ..");
				}
			}
			
			function setVassalFlag (arg0_overlord, arg1_vassal, arg2_flag_url, arg3_msg) {
				//Convert from parameters
				var overlord_id = arg0_overlord;
				var vassal_id = arg1_vassal;
				var flag_url = arg2_flag_url;
				var msg = arg3_msg;
				
				//Make sure overlord is defined
				if (main.users[arg0_overlord] != undefined) {
					var usr = main.users[arg0_overlord];
					if (usr.vassals.length > 0) {
						if (checkVassals(usr.id, vassal_id)) {
							var ot_user = main.users[vassal_id];
							if (flag_url.indexOf("file:") == -1) {
								if (flag_url.indexOf(".png") != -1 || flag_url.indexOf(".jpg") != -1 || flag_url.indexOf(".jpeg") != -1) {
									main.users[vassal_id].flag = flag_url;
									msg.channel.send("**You have sucessfully changed the flag of your vassal!** Type `" + bot_prefix + 'stats "' + ot_user.name + '"` to view it.');
								} else {
									msg.channel.send("Your vassal's flag must be in .png, .jpg, or .jpeg form! Only URLs are accepted.");
								}
							} else {
								msg.channel.send("Please use a valid URL instead of using a local file path!");
							}
						} else {
							msg.channel.send("You can't change the standard of a vassal you don't even have!");
						}
					} else {
						msg.channel.send("Where's your vassals, lad?");
					}
				} else {
					msg.channel.send("Where's your country, lad?");
				}
			}
			
			function setVassalMotto (arg0_overlord, arg1_vassal, arg2_new_motto, arg3_msg) {
				//Convert from parameters
				var overlord_id = arg0_overlord;
				var vassal_id = arg1_vassal;
				var new_motto = arg2_new_motto;
				var msg = arg3_msg;
				
				//Make sure overlord is defined
				if (main.users[arg0_overlord] != undefined) {
					var usr = main.users[arg0_overlord];
					if (usr.vassals.length > 0) {
						if (checkVassals(usr.id, vassal_id)) {
							var ot_user = main.users[vassal_id];
							
							if (new_motto.length <= 250) {
								if (new_motto.length > 0) {
									ot_user.motto = new_motto;
									msg.channel.send("You have successfully changed the motto of **" + ot_user.name + "** to **" + ot_user.motto + "**.");
								} else {
									msg.channel.send("You can't have nothing as your motto!");
								}
							} else {
								msg.channel.send("Each motto can only contain up to a maximum of 250 characters!");
							}
						} else {
							msg.channel.send("Please specify a valid vassal in your possession!");
						}
					} else {
						msg.channel.send("Where are your vassals, lad?");
					}
				} else {
					msg.channel.send("Where's your country lad?");
				}
			}
		}
		
		//Diplomacy commands
		{
			
			function allowCeding (arg0_user, arg1_user, arg2_message) {
				//Convert from parameters
				var user_id = arg0_user;
				var usr = main.users[arg0_user];
				var ot_user_id = arg1_user;
				var ot_user = main.users[arg1_user];
				var msg = arg2_message;
				
				//Check to see that usr is defined
				if (usr) {
					if (ot_user) {
						if (!usr.allow_cede.includes(ot_user_id)) {
							usr.allow_cede.push(ot_user_id);
							msg.channel.send("You have decided to allow **" + ot_user.name + "** to cede provinces to you.");
						} else {
							msg.channel.send("You already allow **" + ot_user.name + "** to cede provinces to you!");
						}
					} else {
						msg.channel.send("You can't allow the ceding of lands from Narnia.");
					}
				} else {
					msg.channel.send("You can't allow the ceding of lands from another nation if you don't even have any to begin with!");
				}
			}
			
			function ally (arg0_user, arg1_user, arg2_message) {
				var msg = arg2_message;
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					
					if (main.users[arg1_user] != undefined) {
						if (usr.political_capital >= config.form_alliance_cost) {
							//Check if ally is yourself, already an ally, or a rival
							var is_rival = false;
							for (var i = 0; i < usr.rivals.length; i++) {
								if (arg1_user == usr.rivals[i]) {
									is_rival = true;
								}
							}
							
							if (is_rival == false) {
								if (arg0_user == arg1_user) {
									msg.channel.send("You can't ally yourself!");
								} else {
									var is_pending = false;
									var already_is_ally = false;
									for (var i = 0; i < main.users[arg1_user].allies.length; i++) {
										if (main.users[arg1_user].allies[i][0] == arg0_user) {
											if (main.users[arg1_user].allies[i][1] == "accepted") {
												already_is_ally = true;
											} else if (main.users[arg1_user].allies[i][1] == "pending") {
												is_pending = true;
											}
										}
									}
									
									if (is_pending) {
										msg.channel.send("You already have an ally request pending!");
									} else {
										if (already_is_ally) {
											msg.channel.send("This country is already your ally!");
										} else {
											var relations_high_enough = false;
											
											for (var i = 0; i < usr.relations.length; i++) {
												if (usr.relations[i][1] == arg1_user) {
													if (usr.relations[i][0] >= 75) {
														relations_high_enough = true;
													}
												}
											}
											
											if (relations_high_enough) {
												if (usr.used_diplomatic_slots < usr.modifiers.starting_diplomatic_slots) {
													usr.used_diplomatic_slots++;
													usr.political_capital = usr.political_capital - config.form_alliance_cost;
													main.users.global.current_scope = arg0_user;
													main.users[arg1_user].allies.push([arg0_user, "pending"]);
													localisation.push(usr.name);
													printEvent(arg1_user, "alliance_proposal");
													msg.channel.send("<:checkmark:725550245051760671> We have sent **" + main.users[arg1_user].name + "** an alliance proposal.");
												} else {
													msg.channel.send("You do not have enough diplomatic slots to request an alliance!");
												}
											} else {
												msg.channel.send("You must at least have **+75** relations with " + main.users[arg1_user].name + " in order to propose an alliance!");
											}
										}
									}
								}
							} else {
								msg.channel.send("You can't ally a rival!");
							}
						} else {
							msg.channel.send("You don't have enough political capital to propose an alliance! You must have at least <:political_capital:716817688525275257> **" + config.form_alliance_cost + "** Political Capital in order to form an alliance.");
						}
					} else {
						msg.channel.send("The person you are trying to conduct diplomatic relationships with does not exist!");
					}
				} else {
					msg.channel.send("You must have a nation in order to conduct diplomatic relations!");
				}
			}
			
			function annex (arg0_user, arg1_user, arg2_message) {
				var msg = arg2_message;
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					if (main.users[arg1_user] != undefined) {
						var ot_user = main.users[arg1_user];
						var vassal_found = false;
						
						for (var i = 0; i < usr.vassals.length; i++) {
							if (usr.vassals[i] == ot_user.id) {
								vassal_found = true;
							}
						}
						
						if (vassal_found) {
							if (usr.political_capital >= config.annex_cost) {
								usr.political_capital = usr.political_capital - config.annex_cost;
								main.users.global.current_scope = arg0_user;
								localisation.push(usr.name);
								printEvent(arg1_user, "the_coming_integration");
								usr.infamy = usr.infamy + 3;
								msg.channel.send("<:checkmark:725550245051760671> We have sent **" + ot_user.name + "** an ultimatum for <:political_capital:716817688525275257> **" + parseNumber(config.annex_cost) + "** Political Capital demanding their immediate incorporation into our empire, lest they be consumed by fire.");
								returnChannels.send(war_channel, "**" + usr.name + "** has requested the integration of their vassal into their country, **" + ot_user.name + "**. This action has costed them <:infamy:716817688453709905> 3 infamy.");
							} else {
								msg.channel.send("You don't have enough Political Capital to annex **" + ot_user.name + "** yet! You need an additional <:political_capital:716817688525275257> **" + parseNumber(Math.ceil(config.annex_cost-usr.political_capital)) + "** Political Capital before being able to send an annexation request to this user.");
							}
						} else {
							msg.channel.send("The user you have specified is not a vassal of yours that you can freely annex!");
						}
					} else {
						msg.channel.send("The user you are trying to annex doesn't even have a country!");
					}
				} else {
					msg.channel.send("You must have a country in order to start annexing people!");
				}
			}
			
			function breakAlly (arg0_user, arg1_user, arg2_message) {
				var msg = arg2_message;
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					
					if (main.users[arg1_user] != undefined) {
						//Check if nation is an ally
						var is_ally = false;
						for (var i = 0; i < usr.allies.length; i++) {
							if (usr.allies[i][0] == arg1_user) {
								is_ally = true;
							}
						}
						if (is_ally) {
							//Remove allied status
							for (var i = 0; i < usr.allies.length; i++) {
								if (usr.allies[i][0] == arg1_user) {
									usr.allies.splice(i, 1);
								}
							}
							for (var i = 0; i < main.users[arg1_user].length; i++) {
								if (main.users[arg1_user].allies[i][0] == arg0_user) {
									main.users[arg1_user].allies.splice(i, 1);
								}
							}
							localisation.push(usr.name);
							usr.used_diplomatic_slots--;
							main.users[arg1_user].used_diplomatic_slots--;
							printEvent(arg1_user, "alliance_broken");
							msg.channel.send("<:checkmark:725550245051760671> We have broken off our alliance with **" + main.users[arg1_user].name + "**.");
						} else {
							msg.channel.send("You already have no alliance with this person!");
						}
					} else {
						msg.channel.send("The person you are attempting to conduct diplomatic relations with does not have a country yet!");
					}
				} else {
					msg.channel.send("You must have a country in order to conduct diplomatic relations!");
				}
			}
			
			function callAlly (arg0_user, arg1_user, arg2_war, arg3_message) {
				var msg = arg3_message;
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					
					if (main.users[arg1_user] != undefined) {
						var ot_user = main.users[arg1_user];
						
						var has_alliance = false;
						
						for (var i = 0; i < usr.allies.length; i++) {
							if (usr.allies[i][0] == arg1_user) {
								has_alliance = true;
							}
						}
						
						if (has_alliance) {
							var war_exists = [false, ""];
							var all_wars = Object.keys(main.users.global.wars);
							
							for (var i = 0; i < all_wars.length; i++) { //soft match first
								if (main.users.global.wars[all_wars[i]].name.toLowerCase().indexOf(arg2_war.toLowerCase()) != -1) {
									war_exists = [true, all_wars[i]];
								}
							}
							for (var i = 0; i < all_wars.length; i++) { //hard match second
								if (main.users.global.wars[all_wars[i]].name.toLowerCase() == arg2_war.toLowerCase()) {
									war_exists = [true, all_wars[i]];
								}
							}
							
							if (war_exists[0]) {
								var current_side = "";
								var current_selector = "";
								var opposing_side = "";
								var immediate_ally = false;
								var already_in_war = false;
								
								for (var i = 0; i < main.users.global.wars[war_exists[1]].attackers.length; i++) {
									if (main.users.global.wars[war_exists[1]].attackers[i] == arg0_user) {
										current_side = "attackers";
										opposing_side = "defenders";
										current_selector = "original_attacker";
									}
									if (main.users.global.wars[war_exists[1]].attackers[i] == arg1_user) {
										already_in_war = true;
									}
								}
								for (var i = 0; i < main.users.global.wars[war_exists[1]].defenders.length; i++) {
									if (main.users.global.wars[war_exists[1]].defenders[i] == arg0_user) {
										current_side = "defenders";
										opposing_side = "attackers";
										current_selector = "original_target";
									}
									if (main.users.global.wars[war_exists[1]].attackers[i] == arg1_user) {
										already_in_war = true;
									}
								}
								
								if (current_selector != "") {
									var war_leader_obj = main.users[main.users.global.wars[war_exists[1]][current_selector]];
									console.log("Actual object: " + main.users.global.wars[war_exists[1]]);
									console.log("War leader object given: " + main.users.global.wars[war_exists[1]][current_selector]);
									
									if (war_leader_obj.allies.length > 0) {
										for (var i = 0; i < war_leader_obj.allies.length; i++) {
											if (war_leader_obj.allies[i][0] == ot_user.id && war_leader_obj.allies[i][1] == "accepted") {
												immediate_ally = true;
											}
										}
									}
									
									if (immediate_ally) {
										if (already_in_war == false) {
											//printEvent
											localisation.push(main.users.global.wars[war_exists[1]].name);
											localisation.push(usr.name);
											console.log("Current localisation array: " + localisation);
											main.users.global.current_scope = [war_exists[1], current_side, opposing_side, arg0_user];
											printEvent(arg1_user, "call_to_arms");
											msg.channel.send("<:checkmark:725550245051760671> You have decided to call in **" + usr.name + "** into the **" + main.users.global.wars[war_exists[1]].name + "**.");
										} else {
											msg.channel.send("**" + ot_user.name + "** is already in the **" + main.users.global.wars[war_exists[1]].name + "**!");
										}
									} else {
										msg.channel.send("You may only call in immediate allies of the war leader on your side!");
									}
								} else {
									msg.channel.send("You must be in the war itself to be able to call in allies!");
								}
							} else {
								msg.channel.send("The war you have specified does not exist! Have a USS Maine or Gulf of Tonkin incident first.");
							}
						} else {
							msg.channel.send("You do not have an active alliance with that country!");
						}
					} else {
						msg.channel.send("The user you are trying to call into your war does not have an existant nation!");
					}
				} else {
					msg.channel.send("You must found a nation first before calling in any allies into any potential wars!");
				}
			}
			
			function cancelJustification (arg0_user, arg1_user, arg2_cb, arg3_message) {
				//Convert from parameters
				var usr = main.users[arg0_user];
				var ot_user = main.users[arg1_user];
				var cb = arg2_cb;
				var msg = arg3_message;
				
				//Look for justification
				var justification_found = [false, -1];
				//returnChannels.send(war_channel, "<@" + arg0_user + "> is justifying against <@" + arg1_user + ">! (CB: **" + config.casus_belli[usr.casus_belli[i][0]].name + "**).\nWar justification will complete in **" + actual_justification_time + "** turns.\n\nThey have gained <:infamy:716817688453709905> " + parseNumber(config.casus_belli[arg2_cb].infamy) + " infamy as a result.");
				if (cb != "") {
					for (var i = 0; i < usr.justifications.length; i++) {
						if (usr.justifications[i][0] == cb && usr.justifications[i][1] == ot_user.id) {
							justification_found = [true, i];
						}
					}
				} else {
					for (var i = 0; i < usr.justifications.length; i++) {
						if (usr.justifications[i][1] == ot_user.id) {
							justification_found = [true, i];
						}
					}
				}
				
				if (justification_found[0]) {
					usr.justifications.splice(justification_found[1], 1);
					returnChannels.send(war_channel, "**<@" + usr.id + "> has cancelled their justification against <@" + ot_user.id + ">**.");
				} else {
					msg.channel.send("The justification you have specified could not be found!");
				}
			}
			
			function cancelMilitaryAccess (arg0_user, arg1_user, arg2_message) {
				var msg = arg2_message;
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					
					if (main.users[arg1_user] != undefined) {
						if (arg0_user != arg1_user) {
							var has_mil_access = false;
							var element_to_remove = 0;
							
							for (var i = 0; i < main.users[arg1_user].military_access.length; i++) {
								if (main.users[arg1_user].military_access[i] == arg0_user) {
									has_mil_access = true;
									element_to_remove = i;
								}
							}
							
							if (has_mil_access) {
								localisation.push(usr.name);
								printEvent(arg1_user, "access_cancelled");
								main.users[arg1_user].used_diplomatic_slots--;
								main.users[arg1_user].military_access.splice(element_to_remove, 1);
							} else {
								msg.channel.send("The person you have specified does not have military access through your territory!");
							}
						} else {
							msg.channel.send("You cannot cancel military access to yourself!");
						}
					} else {
						msg.channel.send("The person you are trying to cancel military access with is nonexistent!");
					}
				} else {
					msg.channel.send("You are undefined! Yes, you!");
				}
			}
			
			function cedeProvince (arg0_user, arg1_id, arg2_user, arg3_message) {
				//Convert from parameters
				var user_id = arg0_user;
				var province_id = arg1_id;
				var ot_user_id = arg2_user;
				var ot_user = main.users[arg2_user];
				var msg = arg3_message;
				
				//Declare local instance variables
				var can_cede = true;
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					if (usr.capital_id.toString() != arg1_id) {
						if (isNaN(parseInt(arg1_id)) == false) {
							var valid_province = false;
							var urban_province = false;
							
							for (var i = 0; i < usr.cities.city_array.length; i++) {
								if (usr.cities[usr.cities.city_array[i]].province == arg1_id) {
									urban_province = true;
								}
							}
							for (var i = 0; i < usr.cities.province_array.length; i++) {
								if (usr.cities.province_array[i] == arg1_id) {
									valid_province = true;
								}
							}
							for (var i = 0; i < usr.pops.pop_array.length; i++) {
								if (usr.pops.pop_array[i] == arg1_id) {
									valid_province = true;
								}
							}
							
							if (valid_province) {
								if (main.users[arg2_user] != undefined) {
									if (usr.total_ceded_this_turn <= config.cede_limit) {
										if (usr.at_war.length == 0) {
											if (ot_user.last_active_turn >= main.roundCount-config.inactive_turns) if (!ot_user.allow_cede.includes(user_id)) can_cede = false;
											
											if (can_cede) {
												transferProvince(arg0_user, arg1_id, arg2_user, "none");
												usr.total_ceded_this_turn++;
												msg.channel.send("You have transferred Province **" + arg1_id + "** to <@" + arg2_user + ">.");
											} else {
												msg.channel.send("You may only cede provinces to active users that actually want to receive your land! Ask them to `" + bot_prefix + "allow-cede` first before trying to cede more land.");
											}
										} else {
											msg.channel.send("You must be at peace in order to cede provinces!");
										}
									} else {
										msg.channel.send("You may only cede up to **" + parseNumber(config.cede_limit) + "** provinces each round! Wait until next turn to potentially cede more provinces.");
									}
								} else {
									msg.channel.send("The user you are attempting to transfer your province to could not be found! Make sure that you've inputted their name correctly.");
								}
							} else {
								msg.channel.send("You must specify a province in your possession! **" + arg1_id + "** was not a valid province.");
							}
						} else {
							msg.channel.send("You must specify a valid numerical province ID! Type `" + bot_prefix + "display-map` for a map of valid provinces.");
						}
					} else {
						msg.channel.send("You can't cede your capital city!");
					}
				} else {
					msg.channel.send("You must have a nation in order to cede provinces!");
				}
			}
			
			function declareWar (arg0_user, arg1_user, arg2_cb, arg3_message) {
				var msg = arg3_message;
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					
					if (main.users[arg1_user] != undefined) {
						var ot_user = main.users[arg1_user];
						var cb_exists = [false, ""];
						
						//Check if CB exists
						//Wargoal Array: [[casus_belli, nation]]
						
						//Check for soft match
						for (var i = 0; i < usr.wargoals.length; i++) {
							if (usr.wargoals[i][1] == arg1_user) {
								if (usr.wargoals[i][0].toLowerCase().indexOf(arg2_cb.toLowerCase()) != -1) {
									cb_exists = [true, usr.wargoals[i][0]];
								}
							}
						}
						
						//Check for hard match
						for (var i = 0; i < usr.wargoals.length; i++) {
							if (usr.wargoals[i][1] == arg1_user) {
								if (usr.wargoals[i][0].toLowerCase() == arg2_cb.toLowerCase()) {
									cb_exists = [true, usr.wargoals[i][0]];
								}
							}
						}
						
						if (cb_exists[0]) {
							var is_guaranteed = false;
							var is_ally = false;
							var has_nap = false;
							var already_at_war = false;
							var has_troops_in_country = false;
							
							for (var i = 0; i < usr.guarantees.length; i++) {
								if (usr.guarantees[i] == arg1_user) {
									is_guaranteed = true;
								}
							}
							//[main.users.global.current_scope, "accepted"]
							for (var i = 0; i < usr.allies.length; i++) {
								if (usr.allies[i][0] == arg1_user && usr.allies[i][1] == "accepted") {
									is_ally = true;
								}
							}
							
							for (var i = 0; i < usr.non_aggression_pacts.length; i++) {
								if (usr.non_aggression_pacts[i][0] == arg1_user) {
									has_nap = true;
								}
							}
							
							for (var i = 0; i < usr.at_war.length; i++) {
								if (usr.at_war[i] == ot_user.name) {
									already_at_war = true;
								}
							}
							
							for (var i = 0; i < usr.armies.army_array.length; i++) {
								for (var x = 0; x < main.users[arg1_user].pops.pop_array.length; x++) {
									if (main.users[arg1_user].pops.pop_array[x] == usr.armies[usr.armies.army_array[i]].province.toString()) {
										has_troops_in_country = true;
									}
								}
							}
							
							if (is_guaranteed == false) {
								if (is_ally == false) {
									if (has_nap == false) {
										if (already_at_war == false) {
											if (arg0_user != arg1_user) {
												//append to war object
												war_id = randomNumber(0, 100000000).toString();
												main.users.global.wars[war_id] = {};
												
												var suffix = "";
												if (config.casus_belli[cb_exists[1]].war_names != undefined) {
													suffix = randomElement(config.casus_belli[cb_exists[1]].war_names);
												}
												if (config.casus_belli[cb_exists[1]].war_prefix != undefined) {
													main.users.global.wars[war_id].name = config.casus_belli[cb_exists[1]].war_prefix + " " + suffix;
												} else {
													main.users.global.wars[war_id].name = usr.culture + "-" + ot_user.culture + " War " + suffix;
												}
												main.users.global.wars[war_id].attackers = [arg0_user];
												main.users.global.wars[war_id].defenders = [arg1_user];
												main.users.global.wars[war_id].original_attacker = arg0_user; //war leader
												main.users.global.wars[war_id].original_target = arg1_user; //war leader
												
												usr.at_war.push(ot_user.name); //Push to at war array
												ot_user.at_war.push(usr.name);
												
												main.users.global.wars[war_id].attacker_wargoals = config.casus_belli[cb_exists[1]].peace_demands;
												
												var has_status_quo = false;
												for (var i = 0; i < config.casus_belli[cb_exists[1]].peace_demands.length; i++) {
													if (config.casus_belli[cb_exists[1]].peace_demands[i] == "status_quo") {
														has_status_quo = true;
													}
												}
												
												main.users.global.wars[war_id].defender_wargoals = [];
												
												if (has_status_quo == false) {
													main.users.global.wars[war_id].defender_wargoals.push("status_quo");
												}
												
												for (var i = 0; i < config.casus_belli[cb_exists[1]].peace_demands.length; i++) {
													main.users.global.wars[war_id].defender_wargoals.push(config.casus_belli[cb_exists[1]].peace_demands[i]);
												}
												
												main.users.global.wars[war_id].peace_offers = {}; //User peace proposals are stored here whilst being edited
												
												main.users.global.wars[war_id].attacker_warscore = 0; //100 is max warscore
												main.users.global.wars[war_id].defender_warscore = 0;
												
												main.users.global.wars[war_id].attacker_total_casualties = 0;
												main.users.global.wars[war_id].defender_total_casualties = 0;
												
												returnChannels.send(war_channel, "<@" + arg0_user + "> has declared **war** on <@" + arg1_user + ">! (CB: **" + config.casus_belli[cb_exists[1]].name + "**).");
												
												//Append vassals to at war array, of both the defender and attacker - WIP
												var ending_string = "";
												if (usr.vassals.length != 0) {
													ending_string = "All of your vassals have automatically been called into the war.";
												}								
												for (var i = 0; i < usr.vassals.length; i++) { //Attacker vassals
													main.users.global.wars[war_id].attackers.push(usr.vassals[i]);
													ot_user.at_war.push(main.users[usr.vassals[i]].name);
												}
												for (var i = 0; i < ot_user.vassals.length; i++) { //Defender vassals
													main.users.global.wars[war_id].defenders.push(ot_user.vassals[i]);
													usr.at_war.push(main.users[ot_user.vassals[i]].name);
												}
												//Append new attackers/defenders to at war array for vassals
												for (var i = 0; i < usr.vassals.length; i++) {
													for (var x = 0; x < main.users.global.wars[war_id].defenders.length; x++) {
														main.users[usr.vassals[i]].at_war.push(main.users[main.users.global.wars[war_id].defenders[x]].name);
													}
												}
												for (var i = 0; i < ot_user.vassals.length; i++) {
													for (var x = 0; x < main.users.global.wars[war_id].attackers.length; x++) {
														main.users[ot_user.vassals[i]].at_war.push(main.users[main.users.global.wars[war_id].attackers[x]].name);
													}
												}
												
												usr.at_war = unique(usr.at_war);
												ot_user.at_war = unique(ot_user.at_war);
												
												main.users.global.wars[war_id].defenders = unique(main.users.global.wars[war_id].defenders);
												main.users.global.wars[war_id].attackers = unique(main.users.global.wars[war_id].attackers);
												
												//Check if defender has any guarantees
												for (var i = 0; i < main.user_array.length; i++) {
													for (var x = 0; x < main.users[main.user_array[i]].guarantees.length; x++) {
														if (main.users[main.user_array[i]].guarantees[x] == arg1_user) {
															localisation.push(main.users.global.wars[war_id].name);
															localisation.push(ot_user.name);
															main.users.global.current_scope = [war_id, "defenders", "attackers", arg1_user];
															printEvent(main.user_array[i], "the_promise_we_made");
														}
													}
												}
												
												msg.channel.send("You are now at war with **" + ot_user.name + "**. In order to call in your allies, type `" + bot_prefix + "call-ally <name>`. In order to view a list of ongoing wars, type `" + bot_prefix + "war-list`. " + ending_string);
											} else {
												msg.channel.send("You can't go to war with yourself!");
											}
										} else {
											msg.channel.send("You cannot declare war on a nation you are already at war with!");
										}
									} else {
										msg.channel.send("You currently have a non-aggression pact with this person!");
									}
								} else {
									msg.channel.send("You can't go to war with your ally!");
								}
							} else {
								msg.channel.send("You can't go to war with a nation you're currently guaranteeing! Retract the guarantee first.");
							}
						} else {
							msg.channel.send("The CB you have specified was invalid!");
						}
					} else {
						msg.channel.send("The person you are trying to declare war on does not possess a country!");
					}
				} else {
					msg.channel.send("You must possess a nation in order to enter into diplomatic relations!");
				}
			}
			
			function decreaseRelations (arg0_user, arg1_user, arg2_message) {
				var msg = arg2_message;
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					
					if (main.users[arg1_user] != undefined) {
						//Check for political capital
						if (usr.political_capital >= config.decrease_relations_cost) {
							//[[value, player_id, [improving/decreasing/none, turns]]
							var index_array = 0;
							for (var i = 0; i < usr.relations.length; i++) {
								if (usr.relations[i][1] == arg1_user) {
									index_array = i;
								}
							}
							if (usr.relations[index_array][2][0] == "none") {
								if (arg0_user != arg1_user) {
									if (usr.relations[index_array][0] <= -100) {
										msg.channel.send("You already have minimum relations with this country!");
									} else {
										usr.political_capital = usr.political_capital - config.decrease_relations_cost;
										usr.relations[index_array][2][0] = "decreasing";
										usr.relations[index_array][2][1] = 5;
									}
									msg.channel.send("<:checkmark:725550245051760671> You have begun to deteriorate your relations with **" + main.users[arg1_user].name + "**.");
								} else {
									msg.channel.send("You can't decrease relations with yourself!");
								}
							} else {
								msg.channel.send("You are already " + usr.relations[index_array][2][0] + " your relations with this country!");
							}
						} else {
							msg.channel.send("You need <:political_capital:716817688525275257> **" + parseNumber(config.decrease_relations_cost-usr.political_capital) + "** more Political Capital to improve relations with " + main.users[arg1_user].name + "!");
						}
					} else {
						msg.channel.send("The person you are trying to communicate with is not a valid country!");
					}
				} else {
					msg.channel.send("You must first establish a country in order to conduct diplomatic relations!");
				}
			}
			
			function denyCeding (arg0_user, arg1_user, arg2_message) {
				//Convert from parameters
				var user_id = arg0_user;
				var usr = main.users[arg0_user];
				var ot_user_id = arg1_user;
				var ot_user = main.users[arg1_user];
				var msg = arg2_message;
				
				//Check to see that usr is defined
				if (usr) {
					if (ot_user) {
						if (usr.allow_cede.includes(ot_user_id)) {
							for (var i = 0; i < usr.allow_cede.length; i++) if (usr.allow_cede[i] == ot_user_id) usr.allow_cede.splice(i, 1);
							msg.channel.send("You have decided to disallow **" + ot_user.name + "** from ceding provinces to you.");
						} else {
							msg.channel.send("You already refuse to allow **" + ot_user.name + "** to cede provinces to you!");
						}
					} else {
						msg.channel.send("You can't deny the ceding of lands from Narnia.");
					}
				} else {
					msg.channel.send("You can't deny the ceding of lands from another nation if you don't even have any to begin with!");
				}
			}
			
			function endRivalry (arg0_user, arg1_user, arg2_message) {
				var msg = arg2_message;
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					
					if (main.users[arg1_user] != undefined) {
						//Check if country is rival
						var is_rival = false;
						
						for (var i = 0; i < usr.rivals.length; i++) {
							if (usr.rivals[i] == arg1_user) {
								is_rival = true;
							}
						}
						
						if (is_rival) {
							//Fire remove rivalry event
							localisation.push(usr.name);
							main.users.global.current_scope = arg0_user;
							printEvent(arg1_user, "the_coming_thaw");
							msg.channel.send("<:checkmark:725550245051760671> We have begun a process of mutual reconciliation with **" + main.users[arg1_user].name + "**.");
						} else {
							msg.channel.send("Your country currently does not consider **" + main.users[arg1_user].name + "** to be a valid rival!"); 
						}
					} else {
						msg.channel.send("The person you are trying to unrival does not have a country!");
					}
				} else {
					msg.channel.send("You must have a country in order to conduct diplomatic relations!");
				}
			}
			
			function liberate (arg0_user, arg1_user, arg2_message) {
				var msg = arg2_message;
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					
					if (main.users[arg1_user] != undefined) {
						if (arg0_user != arg1_user) {
							var vassalised = false;
							
							for (var i = 0; i < usr.vassals.length; i++) {
								if (usr.vassals[i] == arg1_user) {
									vassalised = true;
								}
							}
							
							if (vassalised) {
								for (var i = 0; i < usr.vassals.length; i++) {
									if (usr.vassals[i] == arg1_user) {
										usr.vassals.splice(i, 1);
									}
								}
								usr.used_diplomatic_slots--;
								main.users[arg1_user].vassal_years = 0;
								localisation.push(usr.name);
								printEvent(arg1_user, "we_are_free");
								msg.channel.send("<:checkmark:725550245051760671> We have let our vassal, **" + main.users[arg1_user].name + "** go free.");
							} else {
								msg.channel.send("The user you have specified is not underneath your overlordship!");
							}
						} else {
							msg.channel.send("You cannot unvassalise yourself!");
						}
					} else {
						msg.channel.send("The user you have specified doesn't even exist as a nation!");
					}
				} else {
					msg.channel.send("You must have a country in order to conduct diplomatic relations!");
				}
			}
			
			function improveRelations (arg0_user, arg1_user, arg2_message) {
				var msg = arg2_message;
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					
					if (main.users[arg1_user] != undefined) {
						//Check for political capital
						if (usr.political_capital >= config.improve_relations_cost) {
							if (arg0_user != arg1_user) {
								//[[value, player_id, [improving/decreasing/none, turns]]
								var index_array = 0;
								for (var i = 0; i < usr.relations.length; i++) {
									if (usr.relations[i][1] == arg1_user) {
										index_array = i;
									}
								}
								if (usr.relations[index_array][2][0] == "none") {
									if (usr.relations[index_array][0] >= 100) {
										msg.channel.send("You already have maximum relations with this country!");
									} else {
										usr.political_capital = usr.political_capital - config.improve_relations_cost;
										usr.relations[index_array][2][0] = "improving";
										usr.relations[index_array][2][1] = 5;
										
										msg.channel.send("You have begun to improve relations with **" + main.users[arg1_user].name + "** for <:political_capital:716817688525275257> **" + parseNumber(config.improve_relations_cost) + "** Political Capital.");
									}
								} else {
									msg.channel.send("You are already " + usr.relations[index_array][2][0] + " your relations with this country!");
								}
							} else {
								msg.channel.send("You can't improve relations with yourself!");
							}
						} else {
							msg.channel.send("You need <:political_capital:716817688525275257> **" + parseNumber(config.improve_relations_cost-usr.political_capital) + "** more Political Capital to improve relations with " + main.users[arg1_user].name + "!");
						}
					} else {
						msg.channel.send("The person you are trying to communicate with is not a valid country!");
					}
				} else {
					msg.channel.send("You must first establish a country in order to conduct diplomatic relations!");
				}
			}
			
			function militaryAccess (arg0_user, arg1_user, arg2_message) {
				var msg = arg2_message;
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					
					if (main.users[arg1_user] != undefined) {
						if (usr.political_capital >= config.request_military_access_cost) {
							if (usr.used_diplomatic_slots < usr.modifiers.starting_diplomatic_slots) {
								if (arg0_user != arg1_user) {
									var already_has_mil_access = false;
									
									for (var i = 0; i < usr.military_access.length; i++) {
										if (usr.military_access[i] == arg1_user) {
											already_has_mil_access = true;
										}
									}
									
									if (already_has_mil_access == false) {
										usr.political_capital = usr.political_capital - config.request_military_access_cost;
										localisation.push(usr.name);
										main.users.global.current_scope = arg0_user;
										printEvent(arg1_user, "other_armies_our_soil");
										msg.channel.send("<:checkmark:725550245051760671> You have sent **" + main.users[arg1_user].name + "** a request for military access.");
									} else {
										msg.channel.send("You already have military access from **" + main.users[arg1_user].name + "**!");
									}
								} else {
									msg.channel.send("You cannot request military access from yourself!");
								}
							} else {
								msg.channel.send("You don't have enough diplomatic slots to ask for military access!");
							}
						} else {
							msg.channel.send("Not enough political capital! You need **" + parseNumber(config.request_military_access_cost-usr.political_capital) + "** more to request military access from **" + main.users[arg1_user].name + "**.");
						}
					} else {
						msg.channel.send("The user you are trying to request military access from doesn't even exist!");
					}
				} else {
					msg.channel.send("You must have a nation in order to ask for military access!");
				}
			}
			
			function nonAggressionPact (arg0_user, arg1_user, arg2_message) {
				var msg = arg2_message;
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					
					if (main.users[arg1_user] != undefined) {
						if (arg0_user != arg1_user) {
							var already_has_non_agg_pact = false;
							
							for (var i = 0; i < usr.non_aggression_pacts.length; i++) {
								if (usr.non_aggression_pacts[i][0] == arg1_user) {
									already_has_non_agg_pact = true;
								}
							}
							
							if (already_has_non_agg_pact == false) {
								if (usr.used_diplomatic_slots < usr.modifiers.starting_diplomatic_slots) {
									if (usr.political_capital >= config.sign_non_aggression_pact_cost) {
										usr.political_capital = usr.political_capital - config.sign_non_aggression_pact_cost;
										localisation.push(usr.name);
										main.users.global.current_scope = arg0_user;
										printEvent(arg1_user, "a_guaranteed_peace");
										msg.channel.send("<:checkmark:725550245051760671> You have successfully sent a request for a non-aggresison pact to **" + main.users[arg1_user].name + "**.");
									} else {
										msg.channel.send("You don't have enough Political Capital to carry out this request! You need **" + parseNumber(config.sign_non_aggression_pact_cost-usr.political_capital) + "** more Political Capital to send out a request for a non-aggression pact.");
									}
								} else {
									msg.channel.send("You don't have enough diplomatic slots available for another non-aggression pact!");
								}
							} else {
								msg.channel.send("You already have a non-aggression pact with **" + main.users[arg1_user].name + "**!");
							}
						} else {
							msg.channel.send("You can't conclude a non-aggression pact with yourself!");
						}
					} else {
						msg.channel.send("The country you are trying to conclude a non-aggression pact with does not exist!");
					}
				} else {
					msg.channel.send("You must have a nation in order to conclude non-aggression pacts with other countries!");
				}
			}
			
			function justifyWar (arg0_user, arg1_user, arg2_cb, arg3_message) {
				var msg = arg3_message;
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					
					if (main.users[arg1_user] != undefined) {
						if (arg0_user != arg1_user) {
							if (usr.political_capital >= config.justify_wargoal_cost) {
								//Check if CB exists
								var cb_exists = false;
								var is_rival = false;
								var has_non_aggression_pact = false;
								
								for (var i = 0; i < usr.rivals.length; i++) {
									if (usr.rivals[i] == arg1_user) {
										is_rival = true;
									}
								}
								
								for (var i = 0; i < usr.non_aggression_pacts.length; i++) {
									if (usr.non_aggression_pacts[i][0] == arg1_user) {
										has_non_aggression_pact = true;
									}
								}
								
								if (config.casus_belli[arg2_cb] != undefined) {
									cb_exists = true;
								}
								
								if (cb_exists) {
									//Check if CB is valid [[CB, nation, turns]]
									//Wargoals: install_government, cut_down_to_size, liberation, puppet, retake_cores, annexation
									//Casus Belli Array: [[casus_belli, nation]]
									var valid_cb = false;
									
									for (var i = 0; i < usr.casus_belli.length; i++) {
										if (usr.casus_belli[i][0] == arg2_cb && usr.casus_belli[i][1] == arg1_user) {
											valid_cb = true;
										}
									}
									
									if (valid_cb) {
										//Begin justification process, [[CB, nation, turns]]
										if (has_non_aggression_pact) {
											msg.channel.send("You currently have a non-aggression pact with the person you're attempting to justify on!");
										} else {
											for (var i = 0; i < usr.casus_belli.length; i++) {
												if (usr.casus_belli[i] != undefined) {
													var actual_justification_time = 0;
													var actual_infamy = 0;
													if (usr.casus_belli[i][0] == arg2_cb && usr.casus_belli[i][1] == arg1_user) {
														if (is_rival) {
															usr.justifications.push([arg2_cb, arg1_user, Math.round(config.justify_wargoal_time/2)]);
															actual_justification_time = Math.round(config.justify_wargoal_time/2);
														} else {
															usr.justifications.push([arg2_cb, arg1_user, config.justify_wargoal_time]);
															actual_justification_time = config.justify_wargoal_time;
														}
														if (config.casus_belli[arg2_cb].infamy != undefined) {
															usr.infamy = usr.infamy + config.casus_belli[arg2_cb].infamy;
															actual_infamy = config.casus_belli[arg2_cb].infamy;
														}
														msg.channel.send("You have begun justifying a war of **" + config.casus_belli[usr.casus_belli[i][0]].name + "** against <@" + arg1_user + ">!\n\nYou may cancel this justification at any time before its completion by typing `" + bot_prefix + "cancel-justification`.");
														
														returnChannels.send(war_channel, "<@" + arg0_user + "> is justifying against <@" + arg1_user + ">! (CB: **" + config.casus_belli[usr.casus_belli[i][0]].name + "**).\nWar justification will complete in **" + actual_justification_time + "** turns.\n\nThey have gained <:infamy:716817688453709905> " + parseNumber(config.casus_belli[arg2_cb].infamy) + " infamy as a result.");
														usr.casus_belli.splice(i, 1);
													}
												}
											}
										}
									} else {
										msg.channel.send("The CB you have selected was either invalid or has already expired!");
									}
								} else {
									msg.channel.send("'**" + arg2_cb + "**' is not a valid CB! Please make sure you have spelled it correctly and that it is in all lowercase.");
								}
							} else {
								msg.channel.send("You don't have enough Political Capital to justify a wargoal on **" + main.users[arg1_user].name + "**! You need <:political_capital:716817688525275257> **" + parseNumber(config.justify_wargoal_cost-usr.political_capital) + "** more Political Capital in order to justify a wargoal on this nation!");
							}
						} else {
							msg.channel.send("You cannot justify a war on yourself!");
						}
					} else {
						msg.channel.send("You cannot justify a war on a nonexistent nation!");
					}
				} else {
					msg.channel.send("You must have a country in order to justify a war!");
				}
			}
			
			function parsePeace (arg0_peace_obj, arg1_war_obj) {
				var peace_country = arg0_peace_obj.country;
				var peace_obj = arg0_peace_obj.peace_terms;
				var war_obj = arg1_war_obj;
				var defeated_side = "";
				var winning_side = "";
				
				console.log("Peace Object: " + peace_obj.peace_terms);
				
				//Get war object from peace object
				var all_wars = Object.keys(main.users.global.wars);
				var all_other_wars = Object.keys(main.users.global.wars);
				
				for (var i = 0; i < all_other_wars.length; i++) {
					if (main.users.global.wars[all_other_wars[i]].name == war_obj.name) {
						all_other_wars.splice(i, 1);
					}
				}
				
				var remove_occupations = [];
				
				if (peace_obj != undefined) {
					for (var x = 0; x < main.users.global.occupations.length; x++) {
						var belongs_to_belligerent = false;
						//[prov_id, city, original_country, new_country]; ["0", true, "<user_id>", "<user_id>"];
						for (var y = 0; y < war_obj.attackers.length; y++) {
							if (main.users.global.occupations[x][2] == war_obj.attackers[y]) {
								transferProvince(main.users.global.occupations[x][3], main.users.global.occupations[x][0], main.users.global.occupations[x][2], "none");
								remove_occupations.push(main.users.global.occupations[x]);
							}
						}
						for (var y = 0; y < war_obj.defenders.length; y++) {
							if (main.users.global.occupations[x][2] == war_obj.defenders[y]) {
								transferProvince(main.users.global.occupations[x][3], main.users.global.occupations[x][0], main.users.global.occupations[x][2], "none");
								remove_occupations.push(main.users.global.occupations[x]);
							}
						}
					}
					
					for (var i = 0; i < war_obj.attackers.length; i++) {
						var preserve_wars = [];
						
						for (var x = 0; x < remove_occupations.length; x++) {
							for (var y = 0; y < main.users.global.occupations.length; y++) {
								if (main.users.global.occupations[y] == remove_occupations[x]) {
									main.users.global.occupations.splice(y, 1);
								}
							}
						}
						
						for (var x = 0; x < main.users[war_obj.attackers[i]].at_war.length; x++) {
							for (var y = 0; y < all_other_wars.length; y++) {
								var in_war = [false, ""]; //[in_war, opposing_side]
								for (var z = 0; z < main.users.global.wars[all_other_wars[y]].attackers.length; z++) {
									if (main.users.global.wars[all_other_wars[y]].attackers[z] == war_obj.attackers[i]) {
										in_war = [true, "defenders"];
									}
								}
								for (var z = 0; z < main.users.global.wars[all_other_wars[y]].defenders.length; z++) {
									if (main.users.global.wars[all_other_wars[y]].defenders[z] == war_obj.attackers[i]) {
										in_war = [true, "attackers"];
									}
								}
								
								//Check if opposing side contains any co-belligerents
								if (in_war[0]) {
									for (var z = 0; z < main.users.global.wars[all_other_wars[y]][in_war[1]].length; z++) {
										if (main.users.global.wars[all_other_wars[y]][in_war[1]][z] == main.users[war_obj.attackers[i]].at_war[x]) {
											preserve_wars.push(main.users[war_obj.attackers[i]].at_war[x]);
										}
									}
								}
							}
						}
						
						for (var y = 0; y < main.users[war_obj.attackers[i]].at_war.length; y++) {
							var in_war = false;
							for (var x = 0; x < preserve_wars.length; x++) {
								if (main.users[war_obj.attackers[i]].at_war[y] == preserve_wars[x]) {
									in_war = true;
								}
							}
							if (in_war == false) {
								main.users[war_obj.attackers[i]].at_war.splice(y, 1);
							}
						}
						
						if (war_obj.attackers[i] == peace_country) {
							defeated_side = "defenders";
							winning_side = "attackers";
						}
						
						console.log("Preserve wars array for attackers: " + preserve_wars);
					}
					
					//Clear at war array unless user is in another war
					for (var i = 0; i < war_obj.defenders.length; i++) {
						var preserve_wars = [];
						
						for (var x = 0; x < main.users[war_obj.defenders[i]].at_war.length; x++) {
							for (var y = 0; y < all_other_wars.length; y++) {
								var in_war = [false, ""]; //[in_war, opposing_side]
								for (var z = 0; z < main.users.global.wars[all_other_wars[y]].attackers.length; z++) {
									if (main.users.global.wars[all_other_wars[y]].attackers[z] == war_obj.defenders[i]) {
										in_war = [true, "defenders"];
									}
								}
								for (var z = 0; z < main.users.global.wars[all_other_wars[y]].defenders.length; z++) {
									if (main.users.global.wars[all_other_wars[y]].defenders[z] == war_obj.defenders[i]) {
										in_war = [true, "attackers"];
									}
								}
								
								//Check if opposing side contains any co-belligerents
								if (in_war[0]) {
									for (var z = 0; z < main.users.global.wars[all_other_wars[y]][in_war[1]].length; z++) {
										if (main.users.global.wars[all_other_wars[y]][in_war[1]][z] == main.users[war_obj.defenders[i]].at_war[x]) {
											preserve_wars.push(main.users[war_obj.defenders[i]].at_war[x]);
										}
									}
								}
							}
						}
						
						for (var y = 0; y < main.users[war_obj.defenders[i]].at_war.length; y++) {
							var in_war = false;
							for (var x = 0; x < preserve_wars.length; x++) {
								if (main.users[war_obj.defenders[i]].at_war[y] == preserve_wars[x]) {
									in_war = true;
								}
							}
							if (in_war == false) {
								main.users[war_obj.defenders[i]].at_war.splice(y, 1);
							}
						}
						
						if (war_obj.defenders[i] == peace_country) {
							defeated_side = "attackers";
							winning_side = "defenders";
						}
						
						console.log("Preserve wars array for defenders: " + preserve_wars);
					}
					
					/*
						Peace Offer Data Structure
						---
						status_quo: true/false - Done
						install_government: [[nation, user_government]] - Done
						cut_down_to_size: [nation_a, nation_b, nation_c] - Done
						liberation: true/false - Done
						puppet: [[overlord, puppet]] - Done
						retake_cores: [nation_a, nation_b, nation_c] - Done
						annexation: [[nation, [prov1, prov2, prov3]]] - Done
						
						transferProvince (arg0_user, arg1_id, arg2_user, arg3_msg)
					*/
					
					if (peace_obj.status_quo) {
						var all_money = 0;
						for (var i = 0; i < war_obj[defeated_side].length; i++) {
							//10% of their money to be taken as war reps to be equally distributed amongst the winning side
							all_money = all_money + main.users[war_obj[defeated_side][i]].money*0.1;
							main.users[war_obj[defeated_side][i]].money = main.users[war_obj[defeated_side][i]].money*0.9;
						}
						all_money = all_money/war_obj[winning_side].length;
						for (var i = 0; i < war_obj[winning_side].length; i++) {
							main.users[war_obj[winning_side][i]].money = main.users[war_obj[winning_side][i]].money + all_money;
						}
					}
					if (peace_obj.install_government != undefined) {
						if (peace_obj.install_government.length > 0) {
							for (var i = 0; i < peace_obj.install_government.length; i++) {
								main.users[peace_obj.install_government[i][0]].government = peace_obj.install_government[i][1];
							}
						}
					}
					if (peace_obj.cut_down_to_size != undefined) {
						if (peace_obj.cut_down_to_size.length > 0) {
							for (var i = 0; i < peace_obj.cut_down_to_size.length; i++) {
								var user_obj = main.users[peace_obj.cut_down_to_size[i]];
								//Demobilise first
								demobilise(user_obj.id, "none");
								
								//Then subtract 90% of their military
								user_obj.used_soldiers = user_obj.used_soldiers - Math.ceil(user_obj.used_soldiers*0.9);
						
								for (var x = 0; x < config.units.length; x++) {
									user_obj.military[config.units[x]] = Math.ceil(user_obj.military[config.units[x]]*0.1);
								}
								
								if (user_obj.armies.army_array.length > 0) {
									for (var x = 0; x < user_obj.armies.army_array.length; x++) {
										for (var y = 0; y < config.units.length; y++) {
											user_obj.armies[user_obj.armies.army_array[x]][config.units[y]] = Math.ceil(user_obj.armies[user_obj.armies.army_array[x]][config.units[y]]*0.1);
										}
									}
								}
							}
						}
					}
					if (peace_obj.liberation) {
						//Search for the overlord
						for (var i = 0; i < main.user_array.length; i++) {
							for (var x = 0; x < main.users[main.user_array[i]].vassals.length; x++) {
								if (main.users[main.user_array[i]].vassals[x] == peace_country) {
									main.users[main.user_array[i]].vassals.splice(x, 1);
								}
							}
						}
						main.users[peace_country].vassal_years = 0;
					}
					if (peace_obj.puppet != undefined) {
						if (peace_obj.puppet.length > 0) {
							for (var i = 0; i < peace_obj.puppet.length; i++) {
								main.users[peace_obj.puppet[i][0]].vassals.push(peace_obj.puppet[i][1]);
							}
						}
					}
					//transferProvince (arg0_user, arg1_id, arg2_user, arg3_msg)
					if (peace_obj.retake_cores != undefined) {
						if (peace_obj.retake_cores.length > 0) { //.culture
							for (var i = 0; i < peace_obj.retake_cores.length; i++) {
								//Loop through all of the opposing side provinces in search of this culture
								for (var x = 0; x < war_obj[defeated_side].length; x++) {
									var all_pops = Object.keys(main.users[war_obj[defeated_side][x]].pops);
									
									for (var y = 0; y < all_pops.length; y++) {
										if (main.users[war_obj[defeated_side][x]].pops[all_pops[y]].culture == main.users[peace_obj.retake_cores[i]].culture) {
											transferProvince(main.users[war_obj[defeated_side][x]], all_pops[y], peace_obj.retake_cores[i], "none");
										}
									}
								}
							}
						}
					}
					
					console.log("Annexation array: " + peace_obj.annexation);
					
					if (peace_obj.annexation != undefined) {
						if (peace_obj.annexation.length > 0) {
							for (var i = 0; i < peace_obj.annexation.length; i++) {
								for (var x = 0; x < peace_obj.annexation[i][1].length; x++) {
									//Search all countries for province ID
									for (var y = 0; y < main.user_array.length; y++) {
										var all_pops = Object.keys(main.users[main.user_array[y]].pops);
										console.log("All Pops in Object: " + all_pops.join(", "));
										
										for (var z = 0; z < all_pops.length; z++) {
											if (all_pops[z] == peace_obj.annexation[i][1][x]) {
												console.log("Annexing Province " + all_pops[z] + " to " + main.user_array[y]);
												transferProvince(main.user_array[y], all_pops[z], peace_obj.annexation[i][0], "none");
											}
										}
									}
								}
							}
						}
					}
					//Remove war object
					var capital_name = "";
					var all_cities = Object.keys(main.users[peace_country].cities);
					for (var i = 0; i < all_cities.length; i++) {
						if (main.users[peace_country].cities[all_cities[i]].province == main.users[peace_country].capital_id) {
							capital_name = main.users[peace_country].cities[all_cities[i]].name;
						}
					}
					if (capital_name == "") {
						capital_name = main.users[peace_country].name;
					}
					for (var i = 0; i < all_wars.length; i++) {
						if (main.users.global.wars[all_wars[i]].name == war_obj.name) {
							returnChannels.send(war_channel, "<:old_scroll:716828676880334881> The **Treaty of " + capital_name + "** was successfully ratified by all legal parties.");
							delete main.users.global.wars[all_wars[i]];
						}
					}
					cacheSVG();
					setTimeout(function(){
						for (var i = 0; i < map_channel.length; i++) {
							displaySVG(returnChannel(map_channel[i]));
						}
					},2000);
				} else {
					returnChannels.send(war_channel, "An error was encountered whilst attempting to invoke the parsePeace() function: undefined peace_obj variable.");
				}
			}
			
			function peaceOffer (arg0_user, arg1_war, arg2_mode, arg3_message) {
				var msg = arg3_message;
				var mode = arg2_mode;
				//mode: [create], [delete], [edit]
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					var war_exists = [false, ""];
					
					//Check if war exists - soft match
					var all_wars = Object.keys(main.users.global.wars);
					for (var i = 0; i < all_wars.length; i++) {
						if (main.users.global.wars[all_wars[i]].name.toLowerCase().indexOf(arg1_war.toLowerCase()) != -1) {
							war_exists = [true, all_wars[i]];
						}
					}
					//Check if war exists - hard match
					for (var i = 0; i < all_wars.length; i++) {
						if (main.users.global.wars[all_wars[i]].name.toLowerCase() == arg1_war.toLowerCase()) {
							war_exists = [true, all_wars[i]];
						}
					}
					
					if (war_exists[0]) {
						var war_leader_id = "";
						var war_side = "";
						var wargoal_side = "";
						//Check if user is on the defending or attacking side
						for (var i = 0; i < main.users.global.wars[war_exists[1]].defenders.length; i++) {
							if (main.users.global.wars[war_exists[1]].defenders[i] == arg0_user) {
								war_side = "defenders";
								wargoal_side = "defender";
							}
						}
						for (var i = 0; i < main.users.global.wars[war_exists[1]].attackers.length; i++) {
							if (main.users.global.wars[war_exists[1]].attackers[i] == arg0_user) {
								war_side = "attackers";
								wargoal_side = "attacker";
							}
						}
						
						if (war_side == "defenders" || war_side == "attackers") {
							var war_obj = main.users.global.wars[war_exists[1]];
							var opp_side = "";
							if (war_side == "defenders") {
								opp_side = "attackers";
							} else if (war_side == "attackers") {
								opp_side = "defenders";
							}
							if (mode[0] == "create") {
								var peace_offer_id = randomNumber(0, 100000000).toString();
								war_obj.peace_offers[peace_offer_id] = {};
								war_obj.peace_offers[peace_offer_id].country = arg0_user; //The country that proposed the peace deal
								war_obj.peace_offers[peace_offer_id].peace_terms = {};
								
								msg.channel.send("<:checkmark:725550245051760671> You have successfully created a peace offer!\nTo edit the terms of this peace, type `" + bot_prefix + "add-wargoal " + '"' + war_obj.name.trim() + '"' + " <wargoal>` to add a wargoal, and `" + bot_prefix + "remove-wargoal " + '"' + war_obj.name.trim() + '"' + " <wargoal>` to remove one. Valid wargoals include " + war_obj[wargoal_side + "_wargoals"] + ".\nTo clear this peace offer, and create a new one, type `" + bot_prefix + "clear-peace-treaty " + '"' + war_obj.name.trim() + '"`.');
							} else if (mode[0] == "delete") {
								var all_peace_offers = Object.keys(war_obj.peace_offers);
								var peace_offer_was_found = false;
								
								for (var i = 0; i < all_peace_offers.length; i++) {
									if (war_obj.peace_offers[all_peace_offers[i]].country == arg0_user) {
										peace_offer_was_found = true;
										delete war_obj[all_peace_offers[i]];
										msg.channel.send("<:checkmark:725550245051760671> You successfully cleared your peace offer for the **" + war_obj.name.trim() + "**. In order to create a new peace offer, type `" + bot_prefix + 'sign-peace-treaty "' + war_obj.name.trim() + '"`.');
									}
								}
								
								if (peace_offer_was_found == false) {
									msg.channel.send("You haven't created a peace offer for this war yet!");
								}
							} else if (mode[0] == "edit") { //[edit, add/delete, wargoal, [aims/boolean]]
								
								var all_peace_offers = Object.keys(war_obj.peace_offers);
								var peace_offer_exists = [false, ""];
								
								for (var i = 0; i < all_peace_offers.length; i++) {
									if (war_obj.peace_offers[all_peace_offers[i]].country == arg0_user) {
										peace_offer_exists = [true, all_peace_offers[i]];
									}
								}
								
								if (peace_offer_exists[0]) {
									var terms_obj = war_obj.peace_offers[peace_offer_exists[1]].peace_terms;
									if (mode[1] == "add") {
										var valid_wargoal = false;
										
										console.log("Opposing Side: " + opp_side);
										for (var i = 0; i < war_obj[wargoal_side + "_wargoals"].length; i++) {
											if (war_obj[wargoal_side + "_wargoals"][i] == mode[2]) {
												valid_wargoal = true;
											}
										}
										
										if (valid_wargoal) {
											if (mode[2] == "status_quo") {
												terms_obj.status_quo = true;
												msg.channel.send("You have added **White Peace** as one of your peace demands.");
											} else if (mode[2] == "install_government") {
												//Check that the nation needing to install a new government is part of the opposing side
												var fatal_error = [false, ""];
												var nation_found = false;
												
												for (var i = 0; i < war_obj[opp_side].length; i++) {
													if (war_obj[opp_side][i] == returnMention(mode[3])) {
														nation_found = true;
													}
												}
												
												if (nation_found == false) {
													fatal_error = [true, "The nation you requested to change their government isn't even part of the opposing side of this conflict!"];
												}
												
												//Check if there is already a demand for this nation
												
												if (terms_obj.install_government != undefined) {
													for (var i = 0; i < terms_obj.install_government.length; i++) {
														if (terms_obj.install_government[i][0] == mode[3]) {
															fatal_error = [true, "You have already demanded that this nation change out their government as part of your peace deal!"];
														}
													}
												}
												
												if (fatal_error[0] == false) {
													if (terms_obj.install_government == undefined) {
														terms_obj.install_government = [[mode[3], usr.government]];
													} else {
														terms_obj.install_government.push([mode[3], usr.government]); //[nation, user_government]
													}
													msg.channel.send("You requested that the country of **" + main.users[mode[3]].name + "** change its government type to " + config.governments[usr.government].name[0].toLowerCase() + ".");
												} else {
													msg.channel.send(fatal_error[1]);
												}
											} else if (mode[2] == "cut_down_to_size") {
												//Check that the nation to be contained is part of the opposing side
												var fatal_error = [false, ""];
												var nation_found = false;
												
												for (var i = 0; i < war_obj[opp_side].length; i++) {
													if (war_obj[opp_side][i] == returnMention(mode[3])) {
														nation_found = true;
													}
												}
												
												if (nation_found == false) {
													fatal_error = [true, "The nation you have specified was not part of the opposing side of this conflict!"];
												}
												
												//Check if this nation already needs to cut down their army size
												
												if (terms_obj.cut_down_to_size != undefined) {
													for (var i = 0; i < terms_obj.cut_down_to_size.length; i++) {
														if (terms_obj.cut_down_to_size[i] == mode[3]) {
															fatal_error = [true, "You have already demanded that this nation cut its army down to size!"];
														}
													}
												}
												
												if (fatal_error[0] == false) {
													if (terms_obj.cut_down_to_size == undefined) {
														terms_obj.cut_down_to_size = [mode[3]];
													} else {
														terms_obj.cut_down_to_size.push(mode[3]); //[nation1, nation2, nation3]
													}
													
													var nation_names = [];
													for (var i = 0; i < terms_obj.cut_down_to_size.length; i++) {
														nation_names.push(main.users[terms_obj.cut_down_to_size[i]].name);
													}
													
													msg.channel.send("You requested that the nations of **" + nation_names.join(", ") + "** cut their armies down to size.");
												} else {
													msg.channel.send(fatal_error[1]);
												}
											} else if (mode[2] == "liberation") {
												var is_vassal = false;
												
												//Check if user has an overlord
												for (var i = 0; i < main.user_array.length; i++) {
													for (var x = 0; x < main.users[main.user_array[i]].vassals.length; x++) {
														if (main.users[main.user_array[i]].vassals[x] == arg0_user) {
															is_vassal = true;
														}
													}
												}
												
												if (is_vassal) {
													terms_obj.liberation = true;
													msg.channel.send("You requested that you be liberated from the tyranny of your overlord.");
												} else {
													msg.channel.send("You aren't even a vassal, so why are you trying to demand your liberation?");
												}
											} else if (mode[2] == "puppet") {
												//Check that puppet is valid
												var fatal_error = [false, ""];
												var found_nation = false;
												console.log("User ID to puppet: " + returnMention(mode[3][1]));
												
												for (var i = 0; i < war_obj[opp_side].length; i++) {
													if (war_obj[opp_side][i] == returnMention(mode[3][1])) {
														found_nation = true;
													}
												}
												
												if (found_nation == false) {
													fatal_error = [true, "The nation you have specified was not part of the opposing side of this conflict!"];
												}
												
												//Check if country already has a puppet demand on it
												if (terms_obj.puppet != undefined) {
													for (var i = 0; i < terms_obj.puppet.length; i++) {
														if (terms_obj.puppet[i][1] == mode[3][1]) {
															fatal_error = [true, "You have already demanded this nation to be made the puppet of another user or yourself!"];
														}
													}
												}
												
												if (fatal_error[0] == false) {
													if (terms_obj.puppet == undefined) {
														terms_obj.puppet = [mode[3]]; //[overlord, puppet]
													} else {
														terms_obj.puppet.push(mode[3]);
													}
													msg.channel.send("You requested that the nation of **" + main.users[mode[3][1]].name + "** should become a protectorate of the country of " + main.users[mode[3][0]].name + ".");
												} else {
													msg.channel.send(fatal_error[1]);
												}
											} else if (mode[2] == "retake_cores") {
												var nations_found = 0;
												var nation_names = [];
												var fatal_error = [false, ""];
												
												for (var i = 0; i < main.user_array.length; i++) {
													for (var x = 0; x < mode[3].length; x++) {
														if (mode[3][x] == main.user_array[i]) {
															nations_found++;
														}
													}
												}
												
												if (nations_found < mode[3].length) {
													fatal_error = [true, "One of the nations you have specified turned out to be non-existent!"];
												}
												
												for (var i = 0; i < mode[3].length; i++) nation_names.push("**" + main.users[mode[3][i]].name + "**");
												
												if (fatal_error[0] == false) {
													terms_obj.retake_cores = mode[3]; //Array of all nations that regain all their core territory
													msg.channel.send("You requested that the nations of **" + nation_names.join(", ") + "** receive their core territories back from the defenders.");
												}
												
												//Remove any duplicates
												var unique_requests = [];
												for (var i = 0; i < terms_obj.retake_cores.length; i++) {
													var is_unique = true;
													for (var x = 0; x < unique_requests.length; x++) {
														if (unique_requests[x] == terms_obj.retake_cores[i]) {
															is_unique = false;
														}
													}
													
													if (is_unique) {
														unique_requests.push(terms_obj.retake_cores[i]);
													}
												}
													
												terms_obj.retake_cores = unique_requests;
											} else if (mode[2] == "annexation") {
												
												/*
													Peace Offer Data Structure
													---
													status_quo: true/false - Done
													install_government: [[nation, user_government]] - Done
													cut_down_to_size: [nation_a, nation_b, nation_c] - Done
													liberation: true/false - Done
													puppet: [[overlord, puppet]]
													retake_cores: [nation_a, nation_b, nation_c]
													annexation: [[nation, [prov1, prov2, prov3]]]
													
													transferProvince (arg0_user, arg1_id, arg2_user, arg3_msg)
												*/
												
												//Check that all provs are valid
												var fatal_error = [false, ""];
												
												if (main.users[mode[3][0]] == undefined) {
													fatal_error = [true, "The user you have specified turned out to be non-existent!"];
												}
												
												for (var i = 0; i < mode[3][1].length; i++) {
													var province_found = false;
													console.log("OPPOSING SIDE: " + war_obj[opp_side]);
													console.log("PEACE DEMANDS: " + mode[3][1]);
													for (var x = 0; x < war_obj[opp_side].length; x++) {
														console.log("POP ARRAY: " + main.users[war_obj[opp_side][x]].pops.pop_array);
														for (var y = 0; y < main.users[war_obj[opp_side][x]].pops.pop_array.length; y++) {
															if (main.users[war_obj[opp_side][x]].pops.pop_array[y].toString() == mode[3][1][i].toString()) {
																province_found = true;
															}
														}
													}
													for (var x = 0; x < main.users.global.occupations.length; x++) {
														if (main.users.global.occupations[x][0].toString() == mode[3][1][i].toString()) {
															for (var y = 0; y < war_obj[opp_side].length; y++) {
																if (war_obj[opp_side][y] == main.users.global.occupations[x][2]) {
																	province_found = true;
																}
															}
														}
													}
													if (province_found == false) {
														fatal_error = [true, "Province **" + mode[3][1][i] + "** is not a valid province as it does not belong to a nation of the opposing side!"];
													}
												}
												
												//If a peace demand already exists for this nation, simply override it
												for (var i = 0; i < mode[3][1].length; i++) {
													if (terms_obj.annexation != undefined) {
														for (var x = 0; x < terms_obj.annexation.length; x++) {
															for (var y = 0; y < terms_obj.annexation[x][1].length; y++) {
																if (terms_obj.annexation[x][1][y] == mode[3][1][i]) {
																	terms_obj.annexation[x][1] = mode[3][1];
																}
															}
														}
													}
												}
												
												if (fatal_error[0] == false) {
													if (terms_obj.annexation == undefined) {
														terms_obj.annexation = [mode[3]]; //[[nation, [prov_1, prov_2, prov_3]]
													} else {
														terms_obj.annexation.push(mode[3]);
													}
													console.log("ANNEXATION REQUEST ADDED!");
													console.log(mode[3][0]);
													msg.channel.send("You added an annexation request for the provinces of " + mode[3][1].join(", ") + " on behalf of the nation of **" + main.users[mode[3][0]].name + "**.");
													
													//Remove any duplicates
													var unique_requests = [];
													for (var i = 0; i < terms_obj.annexation.length; i++) {
														var is_unique = true;
														for (var x = 0; x < unique_requests.length; x++) {
															if (unique_requests[x] == terms_obj.annexation[i]) {
																is_unique = false;
															}
														}
														
														if (is_unique) {
															unique_requests.push(terms_obj.annexation[i]);
														}
													}
													
													terms_obj.annexation = unique_requests;
												} else {
													msg.channel.send(fatal_error[1]);
												}
											} else {
												msg.channel.send("how.");
											}
										} else {
											msg.channel.send("You can't add invalid wargoals to a peace offer!");
										}
									} else if (mode[1] == "remove") {
										if (terms_obj[mode[2]] != undefined) {
											if (mode[2] == "status_quo") {
												delete terms_obj.status_quo;
											} else if (mode[2] == "install_government") { //removes entry for corresponding country only
												for (var i = 0; i < terms_obj.install_government.length; i++) {
													if (terms_obj.install_government[i][0] == mode[3]) {
														terms_obj.install_government.splice(i, 1);
													}
												}
												msg.channel.send("You removed the demand for **" + main.users[mode[3]].name + "** to change its government type.");
											} else if (mode[2] == "cut_down_to_size") { //removes entry for corresponding country only
												for (var i = 0; i < terms_obj.cut_down_to_size.length; i++) {
													if (terms_obj.cut_down_to_size[i] == mode[3]) {
														terms_obj.cut_down_to_size.splice(i, 1);
													}
												}
												msg.channel.send("You removed the demand for **" + main.users[mode[3]].name + "** to cut its army down to size.");
											} else if (mode[2] == "liberation") {
												delete terms_obj.liberation;
												msg.channel.send("You removed the demand for you to be liberated from your own overlord.");
											} else if (mode[2] == "puppet") { //removes entry for corresponding country only
												for (var i = 0; i < terms_obj.puppet.length; i++) {
													if (terms_obj.puppet[i][1] == mode[3]) {
														terms_obj.puppet.splice(i, 1);
													}
												}
												msg.channel.send("You removed the demand for **" + main.users[mode[3]].name + "** to become a puppet.");
											} else if (mode[2] == "retake_cores") { //removes all entries for demand
												delete terms_obj.retake_cores;
												msg.channel.send("You removed the demand for allied countries as well as yourself to regain any cores the opposing side holds.");
											} else if (mode[2] == "annexation") { //removes all entries for corresponding country
												var provinces_to_annex = 0;
												console.log(mode[3]);
												for (var i = 0; i < terms_obj.annexation.length; i++) {
													if (terms_obj.annexation[i][0] == mode[3]) {
														provinces_to_annex = terms_obj.annexation[i][1].length;
														terms_obj.annexation.splice(i, 1);
													}
												}
												msg.channel.send("You removed the demand for **" + main.users[mode[3]].name + "** to annex **" + provinces_to_annex + "** provinces.");
											} else {
												msg.channel.send("You have specified an invalid wargoal!");
											}
										} else {
											msg.channel.send("You have already cleared your wargoals in this category!");
										}
									}
								} else {
									msg.channel.send("You need to create a peace offer before you can edit anything on it!");
								}
							}
						} else {
							msg.channel.send("You need to be involved in this conflict in order to send a peace offer!");
						}
					} else {
						msg.channel.send("The war you have specified does not exist!");
					}
				} else {
					msg.channel.send("You must have a nation before creating any peace offers!");
				}
			}
			
			function printCBs (arg0_user, arg1_user, arg2_message) {
				var msg = arg2_message;
				var casus_belli_string_array = [];
				
				if (main.users[arg0_user] != undefined) {
					if (main.users[arg1_user] != undefined) {
						var usr = main.users[arg0_user];
						if (usr.casus_belli.length > 0) {
							for (var i = 0; i < usr.casus_belli.length; i++) {
								if (usr.casus_belli[i][1] == arg1_user) {
									casus_belli_string_array.push("**" + usr.casus_belli[i][0] + "**: Type `" + bot_prefix + "justify-wargoal " + '"' + main.users[arg1_user].name + '" ' + usr.casus_belli[i][0] + '` to justify a wargoal using this CB.');
								}
							}
						}
						if (casus_belli_string_array.length == 0) {
							casus_belli_string_array.push("_You have no valid CBs as of yet on this nation._");
						}
						
						const embed_cbs = new Discord.MessageEmbed()
							.setColor('#a98ac7')
							.setAuthor('Triumph & Tragedy:', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
							.setTitle('**Viewing Valid CB List for ' + main.users[arg1_user].name + ':**\n------------------')
							.setThumbnail('https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
							.setDescription(casus_belli_string_array.join("\n"))
							.setTimestamp();
							
						msg.channel.send(embed_cbs);
					} else {
						msg.channel.send("You must specify a valid user in order to view your CBs for that person!");
					}
				} else {
					msg.channel.send("You must have a nation in order to attempt justifying wars on other people!");
				}
			}
			
			function printWargoals (arg0_user, arg1_user, arg2_message) {
				var msg = arg2_message;
				var wargoal_string_array = [];
				
				if (main.users[arg0_user] != undefined) {
					if (main.users[arg1_user] != undefined) {
						var usr = main.users[arg0_user];
						var ot_user = main.users[arg1_user];
						
						if (usr.wargoals.length > 0) {
							for (var i = 0; i < usr.wargoals.length; i++) {
								if (usr.wargoals[i][1] == arg1_user) {
									wargoal_string_array.push("**" + usr.wargoals[i][0] + "**. Type `" + bot_prefix + "declare-war " + '"' + main.users[arg1_user].name + '"` to declare war on this user using this wargoal.');
								}
							}
						} else {
							wargoal_string_array.push("_You have no valid wargoals as of yet on this nation._");
							wargoal_string_array.push("Consider justifying some by typing `" + bot_prefix + "justify-war`.");
						}
						
						const embed_wargoals = new Discord.MessageEmbed()
							.setColor('#a98ac7')
							.setAuthor('Triumph & Tragedy:', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
							.setTitle('**Viewing Valid Wargoal List for ' + main.users[arg1_user].name + ':**\n------------------')
							.setThumbnail('https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
							.setDescription(wargoal_string_array.join("\n"))
							.setTimestamp();
							
						msg.channel.send(embed_wargoals);
					} else {
						msg.channel.send("You must specify a valid country to declare war on!");
					}
				} else {
					msg.channel.send("You must have a nation in order to declare wars on other people!");
				}
			}
			
			function proclaimGuarantee (arg0_user, arg1_user, arg2_message) {
				var msg = arg2_message;
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					
					if (main.users[arg1_user] != undefined) {
						if (usr.used_diplomatic_slots < usr.modifiers.starting_diplomatic_slots) {
							if (arg0_user != arg1_user) {
								if (usr.political_capital >= config.guarantee_independence_cost) {
									var already_guaranteed = false;
									var is_rival = false;
									
									for (var i = 0; i < usr.guarantees.length; i++) {
										if (usr.guarantees[i] == arg1_user) {
											already_guaranteed = true;
										}
									}
									
									for (var i = 0; i < usr.rivals.length; i++) {
										if (usr.rivals[i] == arg1_user) {
											is_rival = true;
										}
									}
									
									if (already_guaranteed) {
										msg.channel.send("**" + main.users[arg1_user].name + "** is already guaranteed by you.");
									} else if (is_rival) {
										msg.channel.send("You can't guarantee the independence of a rival country! Unrival them first.");
									} else {
										usr.political_capital = usr.political_capital - config.guarantee_independence_cost;
										localisation.push(usr.name);
										usr.guarantees.push(arg1_user);
										main.users.global.current_scope = arg0_user;
										usr.used_diplomatic_slots++;
										printEvent(arg1_user, "a_guarantee_for_our_nation");
										msg.channel.send("<:checkmark:725550245051760671> We have guaranteed the independence of **" + main.users[arg1_user].name + "**! Only good can result from this ...");
									}
								} else {
									msg.channel.send("You don't have enough political power remaining to guarantee the independence of **" + main.users[arg1_user].name + "**! You need <:political_capital:716817688525275257> **" + parseNumber(config.guarantee_independence_cost-usr.political_capital) + "** more Political Capital to carry out this action.");
								}
							} else {
								msg.channel.send("You can't guarantee yourself!");
							}
						} else {
							msg.channel.send("You don't have enough diplomatic slots remaining to guarantee a nation!");
						}
					} else {
						msg.channel.send("The user you are trying to guarantee is nonexistent!");
					}
				} else {
					msg.channel.send("You must possess a nation in order to conduct diplomatic affairs!");
				}
			}
			
			function revokeGuarantee (arg0_user, arg1_user, arg2_message) {
				var msg = arg2_message;
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					
					if (main.users[arg1_user] != undefined) {
						var guarantee_exists = false;
						for (var i = 0; i < usr.guarantees.length; i++) {
							if (usr.guarantees[i] == arg1_user) {
								guarantee_exists = true;
							}
						}
						
						if (guarantee_exists) {
							for (var i = 0; i < usr.guarantees.length; i++) {
								if (usr.guarantees[i] == arg1_user) {
									usr.guarantees.splice(i, 1);
								}
							}
							usr.used_diplomatic_slots--;
							localisation.push(usr.name);
							printEvent(arg1_user, "guarantee_broken");
							msg.channel.send("<:checkmark:725550245051760671> We have broken off our guarantee with **" + main.users[arg1_user].name + "**.");
						} else {
							if (arg0_user == arg1_user) {
								msg.channel.send("We already guarantee our own independence!");
							} else {
								msg.channel.send("We do not have an existing guarantee **" + main.users[arg1_user].name + "**!");
							}
						}
					} else {
						msg.channel.send("The person you are attempting to break off relations with does not have a nation!");
					}
				} else {
					msg.channel.send("You must have a nation in order to conduct diplomatic relations!");
				}
			}
			
			function rival (arg0_user, arg1_user, arg2_message) {
				var msg = arg2_message;
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					
					if (main.users[arg1_user] != undefined) {
						var is_ally = false;
						var is_rival = false;
						
						for (var i = 0; i < usr.rivals.length; i++) {
							if (usr.rivals[i] == arg1_user) {
								is_rival = true;
							}
						}
						for (var i = 0; i < main.users[arg1_user].allies.length; i++) {
							if (main.users[arg1_user].allies[i][0] == arg0_user) {
								is_ally = true;
							}
						}
						
						if (is_rival) {
							msg.channel.send("You have already rivalled this nation!");
						} else {
							if (is_ally) {
								msg.channel.send("You are currently allies with this country!");
							} else {
								if (arg0_user != arg1_user) {
									var relations_too_high = false;
									for (var i = 0; i < usr.relations.length; i++) {
										if (usr.relations[i][1] == arg1_user) {
											if (usr.relations[i][0] >= 50) {
												relations_too_high = true;
											}
										}
									}
									if (relations_too_high) {
										msg.channel.send("Current relations are too high! Relations must be at least below **+50** in order to rival a nation.");
									} else {
										if (usr.political_capital >= config.declare_rival_cost) {
											//Check for rival slots
												if (usr.rivals.length < usr.rival_slots) {
												usr.political_capital = usr.political_capital - config.declare_rival_cost;
												//Add as rivals for both countries
												usr.rivals.push(arg1_user);
												main.users[arg1_user].rivals.push(arg0_user);
												localisation.push(usr.name);
												main.users.global.current_scope = arg0_user;
												printEvent(arg1_user, "rival_declared");
												msg.channel.send("<:infamy:716817688453709905> You have rivalled the enemy nation of **" + main.users[arg1_user].name + "**.");
											} else {
												msg.channel.send("You don't have any rival slots remaining to rival this user!");
											}
										} else {
											msg.channel.send("You don't have enough Political Capital remaining! You need at least <:political_capital:716817688525275257> **" + config.declare_rival_cost + "** to declare a rivalry!");
										}
									}
								} else {
									msg.channel.send("You can't rival yourself!");
								}
							}
						}
					} else {
						msg.channel.send("The person you are trying to conduct diplomatic relations with does not exist!");
					}
				} else {
					msg.channel.send("You must exist as a nation in order to hold diplomatic relations!");
				}
			}
			
			function sendPeaceOffer (arg0_user, arg1_war, arg2_message) {
				var msg = arg2_message;
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					
					//Check if user is involved in a war and has a peace deal active - WIP
					var war_exists = [false, ""];
					var all_wars = Object.keys(main.users.global.wars);
					
					//Soft match
					for (var i = 0; i < all_wars.length; i++) {
						if (main.users.global.wars[all_wars[i]].name.toLowerCase().indexOf(arg1_war.toLowerCase()) != -1) {
							war_exists = [true, all_wars[i]];
						}
					}
					
					//Hard match
					for (var i = 0; i < all_wars.length; i++) {
						if (main.users.global.wars[all_wars[i]].name.toLowerCase() == arg1_war.toLowerCase()) {
							war_exists = [true, all_wars[i]];
						}
					}
					
					if (war_exists[0]) {
						var user_involved = false;
						var user_side = "";
						var war_obj = main.users.global.wars[war_exists[1]];
						
						for (var i = 0; i < war_obj.defenders.length; i++) {
							if (war_obj.defenders[i] == arg0_user) {
								user_involved = true;
								user_side = "defenders";
							}
						}
						for (var i = 0; i < war_obj.attackers.length; i++) {
							if (war_obj.attackers[i] == arg0_user) {
								user_involved = true;
								user_side = "attackers";
							}
						}
						
						if (user_involved) {
							var peace_offer_exists = [false, ""];
							var all_peace_offers = Object.keys(war_obj.peace_offers);
							
							for (var i = 0; i < all_peace_offers.length; i++) {
								if (war_obj.peace_offers[all_peace_offers[i]].country == arg0_user) {
									peace_offer_exists = [true, all_peace_offers[i]];
								}
							}
							
							if (peace_offer_exists[0]) {
								var peace_obj = war_obj.peace_offers[peace_offer_exists[1]];
								var opposing_side = "";
								var friendly_warscore_side = "";
								var opposing_war_leader = "";
								if (user_side == "defenders") {
									opposing_side = "attackers";
									friendly_warscore_side = "defender";
									opposing_war_leader = war_obj.original_attacker;
								} else if (user_side == "attackers") {
									opposing_side = "defenders";
									friendly_warscore_side = "attacker";
									opposing_war_leader = war_obj.original_target;
								}
								console.log("Opposing War Leader: " + opposing_war_leader);
								
								//Send peace offers to war leader
								if (war_obj[friendly_warscore_side + "_warscore"] >= 100) {
									//send forced acceptance event
									console.log("Peace Offer: " + war_obj.peace_offers[peace_offer_exists[1]]);
									printEvent(opposing_war_leader, "the_national_disaster");
									parsePeace(war_obj.peace_offers[peace_offer_exists[1]], main.users.global.wars[war_exists[1]]);
									msg.channel.send("<:checkmark:725550245051760671> You have successfully sent a peace offer to the enemy war leader, **" + main.users[opposing_war_leader].name + "**. They have signed an unconditional surrender, and will be forced to accept its terms.");
								} else {
									//send conditional acceptance event
									console.log("Peace Offer: " + war_obj.peace_offers[peace_offer_exists[1]]);
									localisation.push(main.users[peace_obj.country].name);
									main.users.global.current_scope = [war_obj.peace_offers[peace_offer_exists[1]], main.users.global.wars[war_exists[1]]];
									printEvent(opposing_war_leader, "an_offer_to_lay_down_arms");
									viewPeaceOffer(usr.id, war_obj.name, ["dm", opposing_war_leader]);
									msg.channel.send("<:checkmark:725550245051760671> You have successfully sent a peace offer to the enemy war leader, **" + main.users[opposing_war_leader].name + "**.");
								}
							} else {
								msg.channel.send("You do not currently have an active peace offer available to be sent!");
							}
						} else {
							msg.channel.send("You are not currently in a conflict by this name!");
						}
					} else {
						msg.channel.send("The war you have specified is not currently active!");
					}
				} else {
					msg.channel.send("You must have a registered nation in order to send peace offers to other players!");
				}
			}
			
			function vassalise (arg0_user, arg1_user, arg2_message) {
				var msg = arg2_message;
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					if (main.users[arg1_user] != undefined) {
						if (arg0_user != arg1_user) {
							var already_vassalised = false;
							
							for (var i = 0; i < usr.vassals.length; i++) {
								if (usr.vassals[i] == arg1_user) {
									already_vassalised = true;
								}
							}
							
							if (already_vassalised == false) {
								if (usr.political_capital >= config.vassalise_cost) {
									usr.political_capital = usr.political_capital - config.vassalise_cost;
									localisation.push(usr.name);
									main.users.global.current_scope = arg0_user;
									printEvent(arg1_user, "the_option_to_submit");
									msg.channel.send("<:checkmark:725550245051760671> We have sent **" + main.users[arg1_user].name + "** a request for them to become our vassal.");
								} else {
									msg.channel.send("You don't have enough political capital to request the vassalisation of another country! You need **" + parseNumber(config.vassalise_cost-usr.political_capital) + "** more <:political_capital:716817688525275257> Political Capital in order to send this request.");
								}
							} else {
								msg.channel.send("You have already vassalised the nation of **" + main.users[arg1_user].name + "**!");
							}
						} else {
							msg.channel.send("You can't vassalise yourself!");
						}
					} else {
						msg.channel.send("The person you are trying to vassalise doesn't even have a country!");
					}
				} else {
					msg.channel.end("You must have a nation in order to attempt to vassalise anyone!");
				}
			}
			
			function viewDiplomacy (arg0_user, arg1_user, arg2_message) {
				var msg = arg2_message;
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					
					if (main.users[arg1_user] != undefined) {
						var ot_user = main.users[arg1_user];
						var diplomacy_view_array = [];
						var capital_string = "";
						if (ot_user.capital_id != 0) {
							capital_string = "(Capital ID: Province " + ot_user.capital_id + ")";
						} else {
							capital_string = "(No set capital)";
						}
						
						//Push statistics
						diplomacy_view_array.push("**" + ot_user.name + "** ¦ <@" + arg1_user + ">");
						try {
							diplomacy_view_array.push("<:political_capital:716817688525275257> Government: **" + config.governments[ot_user.government].name[0] + "**");
						} catch {}
						diplomacy_view_array.push("<:provinces:716809229603700737> Provinces: **" + ot_user.provinces + "** " + capital_string);
						diplomacy_view_array.push("<:population:716817688810356826> Population: **" + parseNumber(ot_user.population) + "**");
						diplomacy_view_array.push("<:soldiers:732730754592669702> Active Personnel: **" + parseNumber(ot_user.used_soldiers) + "**");
						diplomacy_view_array.push("<:technology:716812861514711040> Techs Researched: **" + ot_user.techs_researched + "**");
						diplomacy_view_array.push("");
						
						//Push relations
						diplomacy_view_array.push("<:faculty:732730754911436830> Diplomatic Slots: (**"  + ot_user.used_diplomatic_slots + "**/**" + ot_user.modifiers.starting_diplomatic_slots + "**)");
						diplomacy_view_array.push("<:infamy:716817688453709905> Infamy: **" + parseNumber(ot_user.infamy) + "**");
						diplomacy_view_array.push("");
						
						//[value, player_id, [improving/decreasing/none, turns]]
						
						var ot_player_relations = 0;
						var actual_player_relations = 0;
						var ot_player_relations_suffix = "";
						var actual_player_relations_suffix = "";
						var relations_string = "";
						var ot_relations_string = "";
						
						for (var i = 0; i < ot_user.relations.length; i++) {
							if (ot_user.relations[i][1] == arg0_user) {
								ot_player_relations = ot_user.relations[i][0];
								if (ot_user.relations[i][2][0] == "improving") {
									ot_relations_string = " (Improving to " + (ot_user.relations[i][0]+(ot_user.relations[i][2][1]*10)) + " in " + parseNumber(ot_user.relations[i][2][1]) + " turns).";
								} else if (ot_user.relations[i][2][0] == "decreasing") {
									ot_relations_string = " (Decreasing to " + (ot_user.relations[i][0]-(ot_user.relations[i][2][1]*10)) + " in " + parseNumber(ot_user.relations[i][2][1]) + " turns).";
								}
							}
						}
						for (var i = 0; i < usr.relations.length; i++) {
							if (usr.relations[i][1] == arg1_user) {
								actual_player_relations = usr.relations[i][0];
								if (usr.relations[i][2][0] == "improving") {
									relations_string = " (Improving to " + (usr.relations[i][0]+(usr.relations[i][2][1]*10)) + " in " + parseNumber(usr.relations[i][2][1]) + " turns).";
								} else if (usr.relations[i][2][0] == "decreasing") {
									relations_string = " (Decreasing to " + (usr.relations[i][0]-(usr.relations[i][2][1]*10)) + " in " + parseNumber(usr.relations[i][2][1]) + " turns).";
								}
							}
						}
						if (ot_player_relations >= 0) {
							ot_player_relations_suffix = "+";
						}
						if (actual_player_relations >= 0) {
							actual_player_relations_suffix = "+";
						}
						
						diplomacy_view_array.push("Our relations with them: **" + actual_player_relations_suffix + actual_player_relations + "**" + relations_string);
						diplomacy_view_array.push("Their relations with us: **" + ot_player_relations_suffix + ot_player_relations + "**" + ot_relations_string);
						
						var allies_array = [];
						var rivals_array = [];
						var guaranteed_array = [];
						var military_access_array = [];
						var non_aggression_pact_array = [];
						var vassal_array = [];
						var vassal_string = "";
						
						var user_is_ally = false;
						var user_is_rival = false;
						var user_is_vassal = false;
						var user_is_guaranteed = false;
						var user_grants_mil_access = false;
						var user_has_non_agg_pact = [false, 0];
						var user_already_vassal = false;
						
						var can_declare_war = false;
						var is_justifying = false;
						
						var justifying_cbs = [[], 0];
						
						diplomacy_view_array.push("");
						
						for (var i = 0; i < usr.justifications.length; i++) {
							if (usr.justifications[i][1] == ot_user.id) {
								justifying_cbs[0].push("**" + config.casus_belli[usr.justifications[i][0]].name.toLowerCase() + "**");
								justifying_cbs[1] = Math.min(justifying_cbs[1], usr.justifications[i][2]);
								is_justifying = true;
							}
						}
						
						console.log(justifying_cbs);
						
						var wars_prefix = (justifying_cbs[0].length > 1) ? "wars of " : "a war of ";
						
						for (var i = 0; i < ot_user.allies.length; i++) {
							allies_array.push(main.users[ot_user.allies[i][0]].name);
							if (ot_user.allies[i][0] == arg0_user) {
								user_is_ally = true;
							}
						}
						for (var i = 0; i < ot_user.rivals.length; i++) {
							rivals_array.push(main.users[ot_user.rivals[i]].name);
							if (ot_user.rivals[i] == arg0_user) {
								user_is_rival = true;
							}
						}
						for (var i = 0; i < ot_user.vassals.length; i++) {
							vassal_array.push(main.users[ot_user.vassals[i]].name);
						}
						for (var i = 0; i < main.user_array.length; i++) {
							for (var x = 0; x < main.users[main.user_array[i]].guarantees.length; x++) {
								if (main.users[main.user_array[i]].guarantees[x] == arg1_user) {
									guaranteed_array.push(main.users[main.user_array[i]].name);
								}
							}
						}
						for (var i = 0; i < usr.guarantees.length; i++) {
							if (usr.guarantees[i] == arg1_user) {
								user_is_guaranteed = true;
							}
						}
						for (var i = 0; i < main.user_array.length; i++) {
							for (var x = 0; x < main.users[main.user_array[i]].military_access.length; x++) {
								if (main.users[main.user_array[i]].military_access[x] == arg1_user) {
									military_access_array.push(main.users[main.user_array[i]].name);
								}
							}
						}
						for (var i = 0; i < usr.military_access.length; i++) {
							if (usr.military_access[i] == arg1_user) {
								user_grants_mil_access = true;
							}
						}
						for (var i = 0; i < ot_user.non_aggression_pacts.length; i++) {
							non_aggression_pact_array.push(main.users[ot_user.non_aggression_pacts[i][0]].name + " (**" + parseNumber(ot_user.non_aggression_pacts[i][1]+1) + "**)");
							if (ot_user.non_aggression_pacts[i][0] == arg0_user) {
								user_has_non_agg_pact = [true, ot_user.non_aggression_pacts[i][1]];
							}
						}
						for (var i = 0; i < main.user_array.length; i++) {
							for (var x = 0; x < main.users[main.user_array[i]].vassals.length; x++) {
								if (main.users[main.user_array[i]].vassals[x] == arg1_user) {
									vassal_string = "**" + ot_user.name + "** is a vassal of **" + main.users[main.user_array[i]].name + "**.";
									if (main.user_array[i] == arg0_user) {
										user_is_vassal = true;
										user_already_vassal = true;
									} else {
										user_already_vassal = true;
									}
								}
							}
						}
						for (var i = 0; i < usr.wargoals.length; i++) {
							if (usr.wargoals[i][1] == ot_user.id) {
								can_declare_war = true;
							}
						}
						
						if (allies_array.length > 0) {
							diplomacy_view_array.push("The following nations are allied to **" + ot_user.name + "**: " + allies_array.join(", ") + ".");
						}
						if (vassal_array.length > 0) {
							diplomacy_view_array.push("The following nations are vassals to **" + ot_user.name + "**: " + vassal_array.join(", ") + ".");
						}
						if (rivals_array.length > 0) {
							diplomacy_view_array.push("The following nations are rivals of **" + ot_user.name + "**: " + rivals_array.join(", ") + ".");
						}
						if (guaranteed_array.length > 0) {
							diplomacy_view_array.push("The following nations are currently guaranteeing the independence of **" + ot_user.name + "**: " + guaranteed_array.join(", ") + ".");
						}
						if (military_access_array.length > 0) {
							diplomacy_view_array.push("The following nations have military access through **" + ot_user.name + "**: " + military_access_array.join(", ") + ".");
						}
						if (non_aggression_pact_array.length > 0) {
							diplomacy_view_array.push("The following nations have a non-aggression pact with **" + ot_user.name + "**: " + non_aggression_pact_array.join(", ") + ".");
							
							if (user_has_non_agg_pact[0]) diplomacy_view_array.push("- You currently have a non-aggression pact with this country for the next **" + parseNumber(user_has_non_agg_pact[1]+1) + "** turn(s).");
						}
						
						if (vassal_string != "") {
							diplomacy_view_array.push(vassal_string);
						}
						
						diplomacy_view_array.push("------------------");
						diplomacy_view_array.push("**Diplomatic Actions:**");
						diplomacy_view_array.push("");
						
						if (ot_user != usr) {
							if (!is_justifying) {
								if (can_declare_war == false) {
									diplomacy_view_array.push("**Justify Wargoal** - " + config.justify_wargoal_cost + " PC");
									diplomacy_view_array.push("- `" + bot_prefix + "justify-wargoal " + '"' + ot_user.name + '"' + " <wargoal>`");
									diplomacy_view_array.push("Type `" + bot_prefix + "view-cb " + '"' + ot_user.name + '"' + "` to view a list of valid CBs.");
								} else {
									diplomacy_view_array.push("**Declare War**");
									diplomacy_view_array.push("- `" + bot_prefix + "declare-war`");
									diplomacy_view_array.push("Type `" + bot_prefix + "view-wargoals " + '"' + ot_user.name + '"' + "` to view a list of valid wargoals.");
								}
							} else {
								diplomacy_view_array.push("We are currently justifying " + wars_prefix + justifying_cbs[0].join(", ") + " against this nation.\nType `" + bot_prefix + "cancel-justification` in order to cancel our wargoal justification against them.");
							}
							diplomacy_view_array.push("**Improve Relations** - " + config.improve_relations_cost + " PC");
							diplomacy_view_array.push("- `" + bot_prefix + "improve-relations " + '"' + ot_user.name + '"' + "`");
							diplomacy_view_array.push("**Decrease Relations** - " + config.decrease_relations_cost + " PC");
							diplomacy_view_array.push("- `" + bot_prefix + "decrease-relations " + '"' + ot_user.name + '"' + "`");
							diplomacy_view_array.push("");
							
							if (user_is_ally) {
								diplomacy_view_array.push("**Break Alliance** - " + config.break_alliance_cost + " PC");
								diplomacy_view_array.push("- `" + bot_prefix + "break-alliance " + '"' + ot_user.name + '"' + "`");
							} else {
								diplomacy_view_array.push("**Request Alliance** - " + config.vassalise_cost + " PC");
								diplomacy_view_array.push("- `" + bot_prefix + "ally " + '"' + ot_user.name + '"' + "`");
							}
							if (user_is_rival) {
								diplomacy_view_array.push("**End Rivalry**");
								diplomacy_view_array.push("- `" + bot_prefix + "end-rivalry " + '"' + ot_user.name + '"' + "`");
							} else {
								diplomacy_view_array.push("**Declare Rivalry** - " + config.declare_rival_cost + " PC");
								diplomacy_view_array.push("- `" + bot_prefix + "rival " + '"' + ot_user.name + '"' + "`");
							}
							if (user_is_guaranteed) {
								diplomacy_view_array.push("**Revoke Guarantee**");
								diplomacy_view_array.push("- `" + bot_prefix + "revoke-guarantee " + '"' + ot_user.name + '"' + "`");
							} else {
								diplomacy_view_array.push("**Guarantee Independence** - " + config.guarantee_independence_cost + " PC");
								diplomacy_view_array.push("- `" + bot_prefix + "proclaim-guarantee " + '"' + ot_user.name + '"' + "`");
							}
							if (user_grants_mil_access == false) {
								diplomacy_view_array.push("**Request Military Access** - " + config.request_military_access_cost + " PC");
								diplomacy_view_array.push("- `" + bot_prefix + "request-military-access " + '"' + ot_user.name + '"' + "`");
							}
							if (!user_has_non_agg_pact[0]) {
								diplomacy_view_array.push("**Sign Non-Aggression Pact** - " + config.sign_non_aggression_pact_cost + " PC");
								diplomacy_view_array.push("- `" + bot_prefix + "sign-non-aggression-pact " + '"' + ot_user.name + '"' + "`");
							}
							if (user_already_vassal && user_is_vassal) {
								diplomacy_view_array.push("**Liberate**");
								diplomacy_view_array.push("- `" + bot_prefix + "liberate " + '"' + ot_user.name + '"' + "`");
								diplomacy_view_array.push("**Demand Annexation** - " + config.annex_cost + " PC");
								diplomacy_view_array.push("- `" + bot_prefix + "annex " + '"' + ot_user.name + '"' + "`");
							} else {
								if (user_already_vassal == false && user_is_vassal == false) {
									diplomacy_view_array.push("**Demand Vassalisation** - " + config.vassalise_cost + " PC");
									diplomacy_view_array.push("- `" + bot_prefix + "vassalise " + '"' + ot_user.name + '"' + "`");
								}
							}
						} else {
							diplomacy_view_array.push("_You can't conduct diplomatic relations with yourself!_");
						}
						
						const embed_diplomatic_actions = new Discord.MessageEmbed()
							.setColor('#a98ac7')
							.setAuthor('Triumph & Tragedy:', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
							.setTitle('**Viewing Diplomacy for ' + ot_user.name + ':\n------------------**')
							.setThumbnail(ot_user.flag)
							.setDescription(diplomacy_view_array.join("\n"))
							.setTimestamp()
							.setFooter('To access this menu again, type ' + bot_prefix + 'view-diplomacy ' + ot_user.name + '.', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png');
							
						msg.channel.send(embed_diplomatic_actions);
					} else {
						msg.channel.send("The country you wish to look at does not exist!");
					}
				} else {
					msg.channel.send("You must have a country in order to conduct diplomatic relations!");
				}
			}
		
			function viewPeaceOffer (arg0_user, arg1_war, arg2_message) {
				var msg = arg2_message;
				var peace_string_array = [];
				
				if (main.users[arg0_user] != undefined) {
					//Check if war exists
					var all_wars = Object.keys(main.users.global.wars);
					var war_exists = [false, ""];
					
					//Soft match first
					for (var i = 0; i < all_wars.length; i++) {
						if (main.users.global.wars[all_wars[i]].name.toLowerCase().indexOf(arg1_war.toLowerCase()) != -1) {
							war_exists = [true, all_wars[i]];
						}
					}
					//Hard match next
					for (var i = 0; i < all_wars.length; i++) {
						if (main.users.global.wars[all_wars[i]].name.toLowerCase() == arg1_war.toLowerCase()) {
							war_exists = [true, all_wars[i]];
						}
					}
					
					if (war_exists[0]) {
						//Check if country is involved in war
						var involved_in_war = false;
						var war_obj = main.users.global.wars[war_exists[1]];
						
						for (var i = 0; i < war_obj.defenders.length; i++) {
							if (war_obj.defenders[i] == arg0_user) {
								involved_in_war = true;
							}
						}
						for (var i = 0; i < war_obj.attackers.length; i++) {
							if (war_obj.attackers[i] == arg0_user) {
								involved_in_war = true;
							}
						}
						
						if (involved_in_war) {
							//Check that peace offer exists
							var all_offers = Object.keys(war_obj.peace_offers);
							var has_peace_offer = [false, ""];
							for (var i = 0; i < all_offers.length; i++) {
								if (war_obj.peace_offers[all_offers[i]].country == arg0_user) {
									has_peace_offer = [true, all_offers[i]];
								}
							}
							
							if (has_peace_offer[0]) {
								var peace_obj = war_obj.peace_offers[has_peace_offer[1]].peace_terms;
								var no_terms = true;
								//Parse peace offer and output to message
								var wargoals = ["status_quo", "install_government", "cut_down_to_size", "liberation", "puppet", "retake_cores", "annexation"];
								console.log(peace_obj);
								for (var i = 0; i < wargoals.length; i++) {
									if (peace_obj[wargoals[i]] != undefined) {
										no_terms = false;
									}
								}
								
								peace_string_array.push("<@" + arg0_user + ">'s Peace Offer for the **" + war_obj.name + "**:");
								peace_string_array.push("------------------");
								peace_string_array.push("");
								
								if (no_terms) {
									peace_string_array.push("• White Peace");
								} else {
									for (var i = 0; i < wargoals.length; i++) {
										if (wargoals[i] == "status_quo") {
											if (peace_obj[wargoals[i]] != undefined) {
												peace_string_array.push("• The opposing side will be forced to pay **10%** of their cash reserves as war reparations.");
											}
										} else if (wargoals[i] == "install_government") {
											if (peace_obj[wargoals[i]] != undefined) {
												if (peace_obj[wargoals[i]].length > 0) {
													for (var x = 0; x < peace_obj[wargoals[i]].length; x++) {
														console.log("GOVERNMENT CHANGE:");
														console.log(peace_obj[wargoals[i]][x][1]);
														peace_string_array.push("• The nation of **" + main.users[peace_obj[wargoals[i]][x][0]].name + "** will be forced to change their government to " + config.governments[peace_obj[wargoals[i]][x][1]].name[0].toLowerCase() + ".");
													}
												}
											}
										} else if (wargoals[i] == "cut_down_to_size") {
											if (peace_obj[wargoals[i]] != undefined) {
												if (peace_obj[wargoals[i]].length > 0) {
													for (var x = 0; x < peace_obj[wargoals[i]].length; x++) {
														peace_string_array.push("• " + main.users[peace_obj[wargoals[i]][x]].name + " will be required to demobilise and disband 90% of its active forces in all divisions and armies.");
													}
												}
											}
										} else if (wargoals[i] == "liberation") {
											if (peace_obj[wargoals[i]] != undefined) {
												peace_string_array.push("The country of **" + main.users[peace_obj.country].name + "** has demanded her liberation from its overlord.");
											}
										} else if (wargoals[i] == "puppet") {
											if (peace_obj[wargoals[i]] != undefined) {
												if (peace_obj[wargoals[i]].length > 0) {
													for (var x = 0; x < peace_obj[wargoals[i]].length; x++) {
														peace_string_array.push("• **" + main.users[peace_obj[wargoals[i]][x][0]].name + "** will gain overlordship over the nation of **" + main.users[peace_obj[wargoals[i]][x][1]].name + "**.");
													}
												}
											}
										} else if (wargoals[i] == "retake_cores") {
											if (peace_obj[wargoals[i]] != undefined) {
												if (peace_obj[wargoals[i]].length > 0) {
													for (var x = 0; x < peace_obj[wargoals[i]].length; x++) {
														peace_string_array.push("• **" + main.users[peace_obj[wargoals[i]][x]].name + "** will be returned all of its core provinces from the opposing side.");
													}
												}
											}
										} else if (wargoals[i] == "annexation") {
											console.log("Annexation check passed");
											if (peace_obj[wargoals[i]] != undefined) {
												console.log("Annexation is not undefined.");
												if (peace_obj[wargoals[i]].length > 0) {
													console.log("Annexation demand is not undefined.");
													for (var x = 0; x < peace_obj[wargoals[i]].length; x++) {
														console.log("Found demand for " + main.users[peace_obj[wargoals[i]][x][0]] + ": " + peace_obj[wargoals[i]][x]);
														peace_string_array.push("• **" + main.users[peace_obj[wargoals[i]][x][0]].name + "** gains the provinces of **" + peace_obj[wargoals[i]][x][1].join(", ") + "** from the opposing side.");
													}
												}
											}
										}
									}
								}
								
								peace_string_array.push("");
								peace_string_array.push("Type `" + bot_prefix + "send-peace-offer` to send your peace offer to the enemy war leader.");
								
								if (msg[0] != "dm") {
									longMessage(msg, peace_string_array, 20);
								} else {
									longMessage(msg, peace_string_array, 20, [true, msg[1]]);
								}
							} else {
								if (msg[0] != "dm") {
									msg.channel.send("You must have a peace offer active in order to view it! Create a peace offer by typing `" + bot_prefix + 'sign-peace-treaty "' + war_obj.name + '"`.');
								}
							}
						} else {
							if (msg[0] != "dm") {
								msg.channel.send("You need to be an active participant of the war in order to have a peace offer to view!");
							}
						}
					} else {
						if (msg[0] != "dm") {
							msg.channel.send("The war you have specified does not exist!");
						}
					}
				} else {
					if (msg[0] != "dm") {
						msg.channel.send("You must have a nation in order to send and edit peace offers!");
					}
				}
			}
		
			function whitePeace (arg0_war) {
				var war_obj = main.users.global.wars[arg0_war];
				
				//Get war object from peace object
				var all_wars = Object.keys(main.users.global.wars);
				
				var remove_occupations = [];
				
				for (var x = 0; x < main.users.global.occupations.length; x++) {
					var belongs_to_belligerent = false;
					//[prov_id, city, original_country, new_country]; ["0", true, "<user_id>", "<user_id>"];
					for (var y = 0; y < war_obj.attackers.length; y++) {
						if (main.users.global.occupations[x][2] == war_obj.attackers[y]) {
							transferProvince(main.users.global.occupations[x][3], main.users.global.occupations[x][0], main.users.global.occupations[x][2], "none");
							remove_occupations.push(main.users.global.occupations[x]);
						}
					}
					for (var y = 0; y < war_obj.defenders.length; y++) {
						if (main.users.global.occupations[x][2] == war_obj.defenders[y]) {
							transferProvince(main.users.global.occupations[x][3], main.users.global.occupations[x][0], main.users.global.occupations[x][2], "none");
							remove_occupations.push(main.users.global.occupations[x]);
						}
					}
				}
				
				for (var i = 0; i < war_obj.attackers.length; i++) {
					var preserve_wars = [];
					
					for (var x = 0; x < remove_occupations.length; x++) {
						for (var y = 0; y < main.users.global.occupations.length; y++) {
							if (main.users.global.occupations[y] == remove_occupations[x]) {
								main.users.global.occupations.splice(y, 1);
							}
						}
					}
						
					for (var x = 0; x < main.users[war_obj.attackers[i]].at_war.length; x++) {
						for (var y = 0; y < all_wars.length; y++) {
							var in_war = [false, ""]; //[in_war, opposing_side]
							for (var z = 0; z < main.users.global.wars[all_wars[y]].attackers.length; z++) {
								if (main.users.global.wars[all_wars[y]].attackers[z] == war_obj.attackers[i]) {
									in_war = [true, "defenders"];
								}
							}
							for (var z = 0; z < main.users.global.wars[all_wars[y]].defenders.length; z++) {
								if (main.users.global.wars[all_wars[y]].defenders[z] == war_obj.attackers[i]) {
									in_war = [true, "attackers"];
								}
							}
							
							//Check if opposing side contains any co-belligerents
							if (in_war[0]) {
								for (var z = 0; z < main.users.global.wars[all_wars[y]][in_war[1]].length; z++) {
									if (main.users.global.wars[all_wars[y]][in_war[1]][z] == main.users[war_obj.attackers[i]].at_war[x]) {
										preserve_wars.push(main.users[war_obj.attackers[i]].at_war[x]);
									}
								}
							}
						}
					}
					
					for (var y = 0; y < main.users[war_obj.attackers[i]].at_war.length; y++) {
						var in_war = false;
						for (var x = 0; x < preserve_wars.length; x++) {
							if (main.users[war_obj.attackers[i]].at_war[y] == preserve_wars[x]) {
								in_war = true;
							}
						}
						if (in_war == false) {
							main.users[war_obj.attackers[i]].at_war.splice(y, 1);
						}
					}
						
					console.log("Preserve wars array for attackers: " + preserve_wars);
				}
				
				//Clear at war array unless user is in another war
				for (var i = 0; i < war_obj.defenders.length; i++) {
					var preserve_wars = [];
					
					for (var x = 0; x < main.users[war_obj.defenders[i]].at_war.length; x++) {
						for (var y = 0; y < all_wars.length; y++) {
							var in_war = [false, ""]; //[in_war, opposing_side]
							for (var z = 0; z < main.users.global.wars[all_wars[y]].attackers.length; z++) {
								if (main.users.global.wars[all_wars[y]].attackers[z] == war_obj.defenders[i]) {
									in_war = [true, "defenders"];
								}
							}
							for (var z = 0; z < main.users.global.wars[all_wars[y]].defenders.length; z++) {
								if (main.users.global.wars[all_wars[y]].defenders[z] == war_obj.defenders[i]) {
									in_war = [true, "attackers"];
								}
							}
							
							//Check if opposing side contains any co-belligerents
							if (in_war[0]) {
								for (var z = 0; z < main.users.global.wars[all_wars[y]][in_war[1]].length; z++) {
									if (main.users.global.wars[all_wars[y]][in_war[1]][z] == main.users[war_obj.defenders[i]].at_war[x]) {
										preserve_wars.push(main.users[war_obj.defenders[i]].at_war[x]);
									}
								}
							}
						}
					}
						
					for (var y = 0; y < main.users[war_obj.defenders[i]].at_war.length; y++) {
						var in_war = false;
						for (var x = 0; x < preserve_wars.length; x++) {
							if (main.users[war_obj.defenders[i]].at_war[y] == preserve_wars[x]) {
								in_war = true;
							}
						}
						if (in_war == false) {
							main.users[war_obj.defenders[i]].at_war.splice(y, 1);
						}
					}
					
					console.log("Preserve wars array for defenders: " + preserve_wars);
				}
			}
		}
		
		//Events commands
		{
			function updateString (arg0_string, arg1_user) {
				var current_string = arg0_string;
				console.log("Current event string read as " + arg0_string);
				
				if (current_string != undefined) {
					current_string = current_string.replace(/\{0}/gm, getLoc(0));
					current_string = current_string.replace(/\{1}/gm, getLoc(1));
					current_string = current_string.replace(/\{2}/gm, getLoc(2));
					current_string = current_string.replace(/\{3}/gm, getLoc(3));
					current_string = current_string.replace(/\{4}/gm, getLoc(4));
					current_string = current_string.replace(/\{5}/gm, getLoc(5));
					current_string = current_string.replace(/\{6}/gm, getLoc(6));
					current_string = current_string.replace(/\{7}/gm, getLoc(7));
					current_string = current_string.replace(/\{8}/gm, getLoc(8));
					
					function getAnyAcceptedCulture (usr, str, rgx, rgx2) {
						var all_cultures = current_string.match(rgx2);
						if (all_cultures != null) {
							for (var i = 0; i < all_random_cultures.length; i++) {
								var random_culture_name = "";
								if (usr.accepted_cultures.length > 0) {
									random_culture_name = randomElement(usr.accepted_cultures);
								}
								
								str = str.replace(rgx, random_culture_name);
							}
						}
					}
					
					function getAnyNonAcceptedCulture (usr, str, rgx, rgx2) {
						var all_non_accepted_cultures = current_string.match(rgx2);
						if (all_non_accepted_cultures != null) {
							var unique_non_accepted_cultures = [];
							for (var i = 0; i < usr.pops.pop_array.length; i++) {
								var is_accepted = false;
								for (var x = 0; x < usr.accepted_cultures.length; x++) {
									if (usr.pops[usr.pops.pop_array[i]].culture == usr.accepted_cultures[x]) {
										is_accepted = true;
									}
								}
									
								if (is_accepted == false) {
									var already_included = false;
									
									for (var x = 0; x < unique_non_accepted_cultures.length; x++) {
										if (unique_non_accepted_cultures[x] == usr.pops[usr.pops.pop_array[i]].culture) {
											already_included = true;
										}
									}
									
									if (already_included == false) {
										unique_non_accepted_cultures.push(usr.pops[usr.pops.pop_array[i]].culture);
									}
								}
							}
							for (var i = 0; i < all_non_accepted_cultures.length; i++) {
								if (unique_non_accepted_cultures.length > 0) {
									str = str.replace(rgx, randomElement(unique_non_accepted_cultures));
								} else {
									str = str.replace(rgx, "");
								}
							}
						}
					}
					function getAnyCulture (usr, str, rgx, rgx2) {
						var all_cultures = current_string.match(rgx2);
						if (all_cultures != null) {
							var unique_cultures = [];
							for (var i = 0; i < usr.pops.pop_array.length; i++) {
								var already_included = false;
									
								for (var x = 0; x < unique_cultures.length; x++) {
									if (unique_cultures[x] == usr.pops[usr.pops.pop_array[i]].culture) {
										already_included = true;
									}
								}
									
								if (already_included == false) {
									unique_cultures.push(usr.pops[usr.pops.pop_array[i]].culture);
								}
							}
							for (var i = 0; i < all_cultures.length; i++) {
								if (unique_cultures.length > 0) {
									str = str.replace(rgx, randomElement(unique_cultures));
								} else {
									str = str.replace(rgx, "");
								}
							}
						}
					}
					function getCapital (usr, str, rgx, rgx2) {
						var all_capitals = current_string.match(rgx2);
						if (all_capitals != null) {
							var capital_name = "";
							for (var i = 0; i < usr.cities.city_array.length; i++) {
								if (usr.cities[usr.cities.city_array[i]].type == "capital") {
									capital_name = usr.cities[usr.cities.city_array[i]].name;
								}
							}
							for (var i = 0; i < all_capitals.length; i++) {
								str = str.replace(rgx, capital_name);
							}
						}
					}
					function getCity (usr, str, rgx, rgx2) {
						var all_cities = current_string.match(rgx2);
						if (all_cities != null) {
							var city_name_array = [];
							for (var i = 0; i < usr.cities.city_array.length; i++) {
								if (usr.cities[usr.cities.city_array[i]].type != "capital") {
									city_name_array.push(usr.cities[usr.cities.city_array[i]].name);
								}
							}
							for (var i = 0; i < all_cities.length; i++) {
								if (city_name_array.length > 0) {
									str = str.replace(rgx, randomElement(city_name_array));
								} else {
									str = str.replace(rgx, "");
								}
							}
						}
					}
					function getAnyCity (usr, str, rgx, rgx2) {
						var all_cities = current_string.match(rgx2);
						if (all_cities != null) {
							var city_name_array = [];
							for (var i = 0; i < usr.cities.city_array.length; i++) {
								city_name_array.push(usr.cities[usr.cities.city_array[i]].name);
							}
							for (var i = 0; i < all_cities.length; i++) {
								if (city_name_array.length > 0) {
									str = str.replace(rgx, randomElement(city_name_array));
								} else {
									str = str.replace(rgx, "");
								}
							}
						}
					}
					function getOccupiedCity (usr, str, rgx, rgx2) {
						var all_occupied_cities = current_string.match(rgx2);
						if (all_occupied_cities != null) {
							var occ_cities = [];
							var potential_occ_array = [];
							for (var i = 0; i < usr.allies.length; i++) {
								if (usr.allies[i][1] == "accepted") {
									potential_occ_array.push(usr.allies[i][0]);
								}
							}
							potential_occ_array.push(usr.id);
							
							for (var i = 0; i < main.users.global.occupations.length; i++) {
								if (main.users.global.occupations[i][1]) {
									var is_friendly = false;
									for (var x = 0; x < potential_occ_array.length; x++) {
										if (potential_occ_array[x] == main.users.global.occupations[i][3]) {
											is_friendly = true;
										}
									}
									
									if (is_friendly) {
										var city_name = "";
										for (var x = 0; x < main.user_array.length; x++) {
											for (var y = 0; y < main.users[main.user_array[x]].cities.city_array.length; y++) {
												if (main.users[main.user_array[x]].cities[main.users[main.user_array[x]].cities.city_array[y]].province == main.users.global.occupations[i][0]) {
													city_name = main.users[main.user_array[x]].cities[main.users[main.user_array[x]].cities.city_array[y]].name;
												}
											}
										}
										
										if (city_name != "") {
											occ_cities.push(city_name);
										}
									}
								}
							}
							for (var i = 0; i < all_occupied_cities.length; i++) {
								if (occ_cities.length > 0) {
									str = str.replace(rgx, randomElement(occ_cities));
								} else {
									str = str.replace(rgx, "");
								}
							}
						}
					}
					function getBelligerentOccupiedCity (usr, str, rgx, rgx2) {
						var all_occupied_cities = current_string.match(rgx2);
						if (all_occupied_cities != null) {
							var occ_cities = [];
							var potential_occ_array = [];
							
							for (var i = 0; i < usr.at_war.length; i++) {
								for (var x = 0; x < main.user_array.length; x++) {
									if (main.users[main.user_array[x]].name == usr.at_war[i]) {
										potential_occ_array.push(main.user_array[x]);
									}
								}
							}
							for (var i = 0; i < main.users.global.occupations.length; i++) {
								var city_name = "";
								if (main.users.global.occupations[i][1]) {
									if (main.users.global.occupations[i][2] == usr.id) {
										//Which city was it?
										for (var x = 0; x < usr.cities.city_array.length; x++) {
											if (usr.cities[usr.cities.city_array[x]].province == main.users.global.occupations[i][0]) {
												occ_cities.push(usr.cities[usr.cities.city_array[x]].name);
											}
										}
									}
								}
							}
							for (var i = 0; i < all_occupied_cities.length; i++) {
								if (occ_cities.length > 0) {
									str = str.replace(rgx, randomElement(occ_cities));
								} else {
									str = str.replace(rgx, "");
								}
							}
						}
					}
					function getArmy (usr, str, rgx, rgx2) {
						var all_armies = current_string.match(rgx2);
						if (all_armies != null) {
							var all_army_names = [];
							for (var i = 0; i < usr.armies.army_array.length; i++) {
								if (usr.armies[usr.armies.army_array[i]].name != "deleted-army") {
									if (usr.armies[usr.armies.army_array[i]].type == "army") {
										all_army_names.push(usr.armies[usr.armies.army_array[i]].name);
									}
								}
							}
							
							for (var i = 0; i < all_armies.length; i++) {
								if (all_army_names.length > 0) {
									str = str.replace(rgx, randomElement(all_army_names));
								} else {
									str = str.replace(rgx, "");
								}
							}
						}
					}
					function getFleet (usr, str, rgx, rgx2) {
						var all_fleets = current_string.match(rgx2);
						if (all_fleets != null) {
							var all_fleet_names = [];
							for (var i = 0; i < usr.armies.army_array.length; i++) {
								if (usr.armies[usr.armies.army_array[i]].name != "deleted-army") {
									if (usr.armies[usr.armies.army_array[i]].type == "navy") {
										all_fleet_names.push(usr.armies[usr.armies.army_array[i]].name);
									}
								}
							}
							
							for (var i = 0; i < all_armies.length; i++) {
								if (all_fleet_names.length > 0) {
									str = str.replace(rgx, randomElement(all_fleet_names));
								} else {
									str = str.replace(rgx, "");
								}
							}
						}
					}
					function getAirWing (usr, str, rgx, rgx2) {
						var all_air_wings = current_string.match(rgx2);
						if (all_air_wings != null) {
							var all_air_wing_names = [];
							for (var i = 0; i < usr.armies.army_array.length; i++) {
								if (usr.armies[usr.armies.army_array[i]].name != "deleted-army") {
									if (usr.armies[usr.armies.army_array[i]].type == "air force") {
										all_air_wing_names.push(usr.armies[usr.armies.army_array[i]].name);
									}
								}
							}
							
							for (var i = 0; i < all_armies.length; i++) {
								if (all_air_wing_names.length > 0) {
									str = str.replace(rgx, randomElement(all_air_wing_names));
								} else {
									str = str.replace(rgx, "");
								}
							}
						}
					}
					function getAnyForce (usr, str, rgx, rgx2) {
						var all_forces = current_string.match(rgx2);
						if (all_forces != null) {
							var all_force_names = [];
							for (var i = 0; i < usr.armies.army_array.length; i++) {
								if (usr.armies[usr.armies.army_array[i]].name != "deleted-army") {
									all_force_names.push(usr.armies[usr.armies.army_array[i]].name);
								}
							}
							
							for (var i = 0; i < all_armies.length; i++) {
								if (all_force_names.length > 0) {
									str = str.replace(rgx, randomElement(all_force_names));
								} else {
									str = str.replace(rgx, "");
								}
							}
						}
					}
					
					if (arg1_user != undefined) {
						var user = main.users[arg1_user];
					
						function getValue (str) {
							return str.split(".").reduce((o, d) => o[d], user);
						}
						
						current_string = current_string.replace(/\{name}/gm, user.name);
						current_string = current_string.replace(/\{motto}/gm, user.motto);
						current_string = current_string.replace(/\{culture}/gm, user.culture);
						
						getAnyAcceptedCulture(user, current_string, /\{any_accepted_culture}/, /\{any_accepted_culture}/gm);
						getAnyNonAcceptedCulture(user, current_string, /\{any_non_accepted_culture}/, /\{any_non_accepted_culture}/gm);
						getAnyCulture(user, current_string, /\{any_culture}/, /\{any_culture}/gm);
						
						getCapital(user, current_string, /\{capital}/, /\{capital}/gm);
						getCity(user, current_string, /\{city}/, /\{city}/gm);
						getAnyCity(user, current_string, /\{any_city}/, /\{any_city}/gm);
						
						getOccupiedCity(user, current_string, /\{occupied_city}/, /\{occupied_city}/gm);
						getBelligerentOccupiedCity(user, current_string, /\{belligerent_occupied_city}/, /\{belligerent_occupied_city}/gm);
						
						getArmy(user, current_string, /\{army}/, /\{army}/gm);
						getFleet(user, current_string, /\{fleet}/, /\{fleet}/gm);
						getAirWing(user, current_string, /\{air_wing}/, /\{air_wing}/gm);
						getAnyForce(user, current_string, /\{any_force}/, /\{any_force}/gm);
						
						//For belligerents/allies/random scopes
						var belligerent_array = [];
						var allied_array = [];
						for (var i = 0; i < user.at_war.length; i++) {
							for (var x = 0; x < main.user_array.length; x++) {
								if (main.users[main.user_array[x]].name == user.at_war[i]) {
									var already_included = false;
									
									for (var y = 0; y < belligerent_array.length; y++) {
										if (belligerent_array[y] == main.users[main.user_array[x]].id) {
											already_included = true;
										}
									}
									
									if (already_included == false) {
										belligerent_array.push(main.users[main.user_array[x]].id);
									}
								}
							}
						}
						for (var i = 0; i < user.allies.length; i++) {
							if (user.allies[i][1] == "accepted") {
								allied_array.push(user.allies[i][0]);
							}
						}
						
						if (belligerent_array.length > 0) {
							user = main.users[randomElement(belligerent_array)];
							
							getAnyAcceptedCulture(user, current_string, /\{any_accepted_culture}/, /\{any_accepted_culture}/gm);
							getAnyNonAcceptedCulture(user, current_string, /\{any_non_accepted_culture}/, /\{any_non_accepted_culture}/gm);
							getAnyCulture(user, current_string, /\{any_culture}/, /\{any_culture}/gm);
							
							getCapital(user, current_string, /\{capital}/, /\{capital}/gm);
							getCity(user, current_string, /\{city}/, /\{city}/gm);
							getAnyCity(user, current_string, /\{any_city}/, /\{any_city}/gm);
							
							getOccupiedCity(user, current_string, /\{occupied_city}/, /\{occupied_city}/gm);
							getBelligerentOccupiedCity(user, current_string, /\{belligerent_occupied_city}/, /\{belligerent_occupied_city}/gm);
							
							getArmy(user, current_string, /\{army}/, /\{army}/gm);
							getFleet(user, current_string, /\{fleet}/, /\{fleet}/gm);
							getAirWing(user, current_string, /\{air_wing}/, /\{air_wing}/gm);
							getAnyForce(user, current_string, /\{any_force}/, /\{any_force}/gm);
						}
						if (allied_array.length > 0) {
							user = main.users[randomElement(allied_array)];
							
							getAnyAcceptedCulture(user, current_string, /\{any_accepted_culture}/, /\{any_accepted_culture}/gm);
							getAnyNonAcceptedCulture(user, current_string, /\{any_non_accepted_culture}/, /\{any_non_accepted_culture}/gm);
							getAnyCulture(user, current_string, /\{any_culture}/, /\{any_culture}/gm);
							
							getCapital(user, current_string, /\{capital}/, /\{capital}/gm);
							getCity(user, current_string, /\{city}/, /\{city}/gm);
							getAnyCity(user, current_string, /\{any_city}/, /\{any_city}/gm);
							
							getOccupiedCity(user, current_string, /\{occupied_city}/, /\{occupied_city}/gm);
							getBelligerentOccupiedCity(user, current_string, /\{belligerent_occupied_city}/, /\{belligerent_occupied_city}/gm);
							
							getArmy(user, current_string, /\{army}/, /\{army}/gm);
							getFleet(user, current_string, /\{fleet}/, /\{fleet}/gm);
							getAirWing(user, current_string, /\{air_wing}/, /\{air_wing}/gm);
							getAnyForce(user, current_string, /\{any_force}/, /\{any_force}/gm);
						}
						
						//Random user scope
						
						user = main.users[randomElement(main.user_array)];
							
						getAnyAcceptedCulture(user, current_string, /\{any_accepted_culture}/, /\{any_accepted_culture}/gm);
						getAnyNonAcceptedCulture(user, current_string, /\{any_non_accepted_culture}/, /\{any_non_accepted_culture}/gm);
						getAnyCulture(user, current_string, /\{any_culture}/, /\{any_culture}/gm);
							
						getCapital(user, current_string, /\{capital}/, /\{capital}/gm);
						getCity(user, current_string, /\{city}/, /\{city}/gm);
						getAnyCity(user, current_string, /\{any_city}/, /\{any_city}/gm);
							
						getOccupiedCity(user, current_string, /\{occupied_city}/, /\{occupied_city}/gm);
						getBelligerentOccupiedCity(user, current_string, /\{belligerent_occupied_city}/, /\{belligerent_occupied_city}/gm);
							
						getArmy(user, current_string, /\{army}/, /\{army}/gm);
						getFleet(user, current_string, /\{fleet}/, /\{fleet}/gm);
						getAirWing(user, current_string, /\{air_wing}/, /\{air_wing}/gm);
						getAnyForce(user, current_string, /\{any_force}/, /\{any_force}/gm);
						
						user = main.users[arg1_user];
						
						//get_global_variable regex: \{get_variable:.*\}
						var all_global_variables = current_string.match(/\{get_global_variable:.*\}/gm);
						if (all_global_variables != null) {
							for (var i = 0; i < all_global_variables.length; i++) {
								var local_processing = all_global_variables[i];
								local_processing = local_processing.replace("{get_global_variable:", "");
								local_processing = local_processing.replace("}", "");
								var local_variable = getValue(local_processing);
								
								if (local_variable == undefined) {
									local_variable = "";
								}
								for (var x = 0; x < all_global_variables.length; x++) {
									current_string = current_string.replace("{get_variable:" + local_processing + "}", local_variable);
								}
							}
						}
						//get_variable
						var all_local_variables = current_string.match(/\{get_variable:.*\}/gm);
						if (all_local_variables != null) {
							for (var i = 0; i < all_local_variables.length; i++) {
								var local_processing = all_local_variables[i];
								local_processing = local_processing.replace("{get_variable:", "");
								local_processing = local_processing.replace("}", "");
								var local_variable = getValue(local_processing);
								
								if (local_variable == undefined) {
									local_variable = "";
								}
								for (var x = 0; x < all_local_variables.length; x++) {
									current_string = current_string.replace("{get_variable:" + local_processing + "}", local_variable);
								}
							}
						}
						
						//percentile
						var all_percentile_variables = current_string.match(/\{percentile:.*\}/gm);
						if (all_percentile_variables != null) {
							for (var i = 0; i < all_percentile_variables.length; i++) {
								var local_processing = all_percentile_variables[i];
								local_processing = local_processing.replace("{percentile:", "");
								local_processing = local_processing.replace("}", "");
								var local_variable = getValue(local_processing);
								
								if (local_variable == undefined) {
									local_variable = "";
								} else {
									local_variable = (Math.round((local_variable-1)*100)/100) + "%";
								}
								
								for (var x = 0; x < all_percentile_variables.length; x++) {
									current_string = current_string.replace("{percentile:" + local_processing + "}", local_variable);
								}
							}
						}
						
						//inverse_percentile
						var all_inverse_percentile_variables = current_string.match(/\{inverse_percentile:.*\}/gm);
						if (all_inverse_percentile_variables != null) {
							for (var i = 0; i < all_inverse_percentile_variables.length; i++) {
								var local_processing = all_inverse_percentile_variables[i];
								local_processing = local_processing.replace("{inverse_percentile:", "");
								local_processing = local_processing.replace("}", "");
								var local_variable = user[local_processing];
								
								if (local_variable == undefined) {
									local_variable = "";
								} else {
									local_variable = ((Math.round((local_variable-1)*100)/100)*-1) + "%";
								}
								
								for (var x = 0; x < all_inverse_percentile_variables.length; x++) {
									current_string = current_string.replace("{inverse_percentile:" + local_processing + "}", local_variable);
								}
							}
						}
						
						//suffix
						var all_suffixes = current_string.match(/\{suffix:.*\}/gm);
						if (all_suffixes != null) {
							for (var i = 0; i < all_suffixes.length; i++) {
								var local_processing = all_suffixes[i];
								local_processing = local_processing.replace("{suffix:", "");
								local_processing = local_processing.replace("}", "");
								var local_variable = user[local_processing];
								
								if (local_variable == undefined) {
									local_variable = parseInt(local_processing);
								}
								
								var suffix_str = "";
								if (isNaN(local_variable) == false) {
									if (local_variable > 0) {
										suffix_str = "+";
									}
								}
								local_variable = suffix_str + local_variable.toString();
								
								for (var x = 0; x < all_suffixes.length; x++) {
									current_string = current_string.replace("{suffix:" + local_processing + "}", local_variable);
								}
							}
						}
					}
				}
				
				return current_string;
			}
			
			function printEvent (arg0_user, arg1_event) {
				
				var actual_id = arg0_user;
				var all_user_keys = Object.keys(main.users.global.user_map);
				for (var i = 0; i < all_user_keys.length; i++) if (main.users.global.user_map[all_user_keys[i]] == arg0_user) actual_id = all_user_keys[i];
				console.log(arg1_event + " invoked as event. Event Target: " + actual_id);
				
				var usr = main.users[arg0_user];
				//Get all keys in config.events
				var events = Object.keys(config.events);
				var called_event = arg1_event;
				var event_exists = false;
				
				var event_string = [];
				
				for (var i = 0; i < events.length; i++) {
					if (events[i] == called_event) {
						event_exists = true;
					}
				}
				
				if (event_exists) {
					var ev = config.events[called_event];
					
					event_string.push("------------------");
					event_string.push("");
					if (ev.description != undefined) {
						event_string.push(updateString(ev.description, usr.id));
					}
					var alphabet = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z"];
					var random_option = [];
					var has_image = false;
					
					for (var i = 0; i < alphabet.length; i++) {
						var has_limits = false;
						
						if (ev["option_" + alphabet[i] + "_limits"] != undefined) {
							has_limits = true;
						}
						
						if (has_limits) {
							if (ev["option_" + alphabet[i] + "_limits"]()) {
								if (ev["option_" + alphabet[i] + "_ai_chance"] != undefined) {
									random_option.push(ev["option_" + alphabet[i] + "_ai_chance"](usr));
								} else {
									if (ev["option_" + alphabet[i]] != undefined) {
										random_option.push(0);
									}
								}
							} else {
								random_option.push(0);
							}
						} else {
							if (ev["option_" + alphabet[i] + "_ai_chance"] != undefined) {
								random_option.push(ev["option_" + alphabet[i] + "_ai_chance"](usr));
							} else {
								if (ev["option_" + alphabet[i]] != undefined) {
									random_option.push(0);
								}
							}
						}
					}
					
					if (ev.event_image != undefined) {
						has_image = true;
					}
					
					var total_sum = 0;
					var id_array = [];
					
					var all_ids = usr.previous_option_id;
					for (var i = 0; i < random_option.length; i++) {
						total_sum = total_sum + random_option[i];
						id_array.push(all_ids+i);
					}
					
					if (total_sum == 0) {
						//random pick for 100
						var random_pick = randomNumber(0, random_option.length-1);
						random_option[random_pick] = 100;
					}
					
					for (var i = 0; i < alphabet.length; i++) {
						if (ev["option_" + alphabet[i] + "_limits"] != undefined) {
							has_limits = true;
						}
						
						var fulfills_conditions = false;
						
						if (has_limits) {
							if (ev["option_" + alphabet[i] + "_limits"]()) {
								fulfills_conditions = true;
							}
						} else {
							fulfills_conditions = true;
						}
						
						if (fulfills_conditions) {
							if (ev["option_" + alphabet[i] + "_title"] != undefined) {
								event_string.push("");
								event_string.push("**[" + updateString(ev["option_" + alphabet[i] + "_title"], usr.id) + "]** `" + bot_prefix + "resolve " + id_array[i] + "`");
								//event_string.push(updateString(ev["option_" + alphabet[i] + "_description"]));
								event_string.push(updateString(ev["option_" + alphabet[i] + "_description"], usr.id));
							}
						}
					}
					event_string.push("");
					event_string.push("_If you do not respond to this event within 5 turns, a random choice will be automatically chosen for you._");
					
					var save_scope = main.users.global.current_scope;
					
					usr.events.push([[arg1_event, 5], id_array, random_option, save_scope]);
					usr.previous_option_id = usr.previous_option_id + id_array.length;
					
					if (has_image == false) {
						const embed_event = new Discord.MessageEmbed()
							.setColor('#a98ac7')
							.setAuthor('Triumph & Tragedy:', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
							.setTitle('**' + ev.name + '**')
							.setThumbnail('https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
							.setDescription(event_string.join("\n"))
							.setTimestamp();
						
						client.users.fetch(actual_id).then((user) => {
							try { user.send(embed_event); } catch {}
						}).catch(error => console.log("Failed to DM user."));
					} else {
						const embed_event = new Discord.MessageEmbed()
							.setColor('#a98ac7')
							.setAuthor('Triumph & Tragedy:', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
							.setTitle('**' + ev.name + '**')
							.setThumbnail('https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
							.setDescription(event_string.join("\n"))
							.setImage(ev.event_image)
							.setTimestamp();
						
						client.users.fetch(actual_id).then((user) => {
							try { user.send(embed_event); } catch {}
						}).catch(error => console.log("Failed to DM user."));
					}
				}
			}
		
			function resolveEvent (arg0_user, arg1_id, arg2_msg) {
				var option_id = arg1_id;
				var msg = arg2_msg;
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					
					var alphabet = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z"];
					var event_name = "";
					var option_name = "";
					var event_index_position = 0;
					//[[["comet_sighted",5],[0]],[["comet_sighted",5],[1]],[["comet_sighted",5],[2]]]
					for (var i = 0; i < usr.events.length; i++) {
						for (var x = 0; x < usr.events[i][1].length; x++) {
							if (usr.events[i][1][x].toString() == arg1_id.toString()) {
								event_name = usr.events[i][0][0];
								option_name = alphabet[x];
								event_index_position = i;
								console.log("Selected Option: " + alphabet[x]);
							}
						}
					}
					
					if (event_name != "" || option_name != "") {
						main.users.global.current_scope = usr.events[event_index_position][3];
						config.events[event_name]["option_" + option_name](usr);
						usr.events.splice(event_index_position, 1);
						msg.channel.send("<:checkmark:725550245051760671> **" + config.events[event_name].name + "** resolved.");
					} else {
						msg.channel.send("You failed to specify a correct ID. Please check the resolve command provided.");
					}
				}
			}
		}
		
		//Map (Experimental) commands
		{
			function writeSVGS () {
				fs.writeFile("./maps/political_map.svg", original_svg, function (err, data) { if (err) { return console.log(err); } });
			}
			
			function componentToHex(c) {
				var hex = c.toString(16);
				return hex.length == 1 ? "0" + hex : hex;
			}
					
			function truncateString (str, num) {
				if (str.length <= num) {
					return str;
				}
				return str.slice(0, num) + '...'
			}
			
			function initMap (arg0_user, arg1_mode, arg2_message) {
				var mode = arg1_mode;
				var msg = arg2_message;
				open_maps[open_map_id] = {};
				var map_obj = open_maps[open_map_id];
				
				//Initialise screen
				map_obj.title_str = "Please wait ...";
				map_obj.thumbnail_str = "https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png";
				map_obj.interface_string = ["<a:loading:778453104249143326> Currently loading map viewer ..."];
				map_obj.image_str = "https://cdn.discordapp.com/attachments/722997700391338046/736141424315203634/margin.png";
				
				const init_screen = {
					"title": map_obj.title_str,
					"color": 9686188,
					"thumbnail": {
						"url": map_obj.thumbnail_str
					},
					"description": map_obj.interface_string.join("\n"),
					"image": {
					  "url": map_obj.image_str
					}
				};
				//Initialise check
				map_obj.user = arg0_user;
				map_obj.id = open_map_id;
				map_obj.message_id = "";
				map_obj.message_collectors = [];
				map_obj.embed_history = [];
				//Initialise controls
				map_obj.left_arrow = false;
				map_obj.right_arrow = false;
				map_obj.up_arrow = false;
				map_obj.down_arrow = false;
				map_obj.zoom_in = false;
				map_obj.zoom_out = false;
				//Initialise stats
				map_obj.original_img = "";
				map_obj.x = 0;
				map_obj.y = 0;
				map_obj.zoom = 1;
				
				open_map_id++;
				
				if (mode == "mobile") {
					//Work on later
					map_obj.mode = "mobile";
					msg.channel.send({embed: init_screen}).then(sent => {
						map_obj.message_id = sent.id;
						map_obj.message_collectors.push(sent.id);
						sent.react("⬅️").then(() => { sent.react("⬆️"); }).then(() => { sent.react("⬇️"); }).then(() => { sent.react("➡️"); }).then(() => { sent.react("785931430215155754"); }).then(() => { sent.react("785931430407700482"); });
					});
				} else if (mode == "desktop") {
					map_obj.mode = "desktop";
					msg.channel.send({embed: init_screen}).then(sent => {
						map_obj.message_id = sent.id;
						map_obj.message_collectors.push(sent.id);
						sent.react("778437227276402688").then(() => { sent.react("⬆️"); }).then(() => { sent.react("785931430215155754"); });
						
						msg.channel.send({files: [{ attachment: "empty.png", name: "control1.png" }]}).then(sent => {
							map_obj.message_collectors.push(sent.id);
							sent.react("⬅️").then(() => { sent.react("🔘"); }).then(() => { sent.react("➡️"); });
							
							msg.channel.send({files: [{ attachment: "empty.png", name: "control2.png" }]}).then(sent => {
								map_obj.message_collectors.push(sent.id);
								sent.react("778437227276402688").then(() => { sent.react("⬇️"); }).then(() => { sent.react("785931430407700482"); });
							});
						});
					});
				}
				
				//Initialise map and upload it
				var label_placement = config.map_label_placement; //Last column is overflow
				var labels = []; //[[label1, label2, label3], [label4, label5]]
				var total_provinces = 0;
				
				if (fs.readFileSync("./maps/political_map.svg", "utf8").toString().length > 0) {
					var current_element = 0;
					var counter = 0;
					for (var i = 0; i < main.user_array.length; i++) {
						if (main.users[main.user_array[i]].eliminated) {} else {
							if (label_placement[current_element] != undefined) {
								if (counter == label_placement[current_element]) {
									counter = 0;
									current_element++;
								}
								if (counter < label_placement[current_element]) {
									counter++;
									if (main.users[main.user_array[i]].provinces > 0) {
										if (labels[current_element] == undefined) {
											labels[current_element] = [main.user_array[i]];
										} else {
											labels[current_element].push(main.user_array[i]);
										}
									}
								}
							}
						}
					}
					
					console.log(labels);
					
					const canvas = Canvas.createCanvas(config.map_resolution[0], config.map_resolution[1]);
					const ctx = canvas.getContext("2d");
						
					//Load map
					const background = new Canvas.Image();
					const prov_ids = new Canvas.Image();
					const img = new Canvas.Image();
						
					background.onload = () => ctx.drawImage(background, 0, 0, config.map_resolution[0], config.map_resolution[1]);
					background.onerror = err => { throw err; }
					background.src = "./maps/" + config.map_background;
					img.onload = () => ctx.drawImage(img, 0, 0, config.map_resolution[0], config.map_resolution[1]);
					img.onerror = err => { throw err; }
					img.src = "./maps/political_map.svg";
					prov_ids.onload = () => ctx.drawImage(prov_ids, 0, 0, config.map_resolution[0], config.map_resolution[1]);
					prov_ids.onerror = err => { throw err; }
					prov_ids.src = "./maps/" + config.map_overlay;
						
					//Generate Key
					ctx.font = "36px Bahnschrift Condensed";
					ctx.fillStyle = "#ffffff";
					ctx.fillText("Nations of the World: ", (config.map_label_coords[0]*2)-2, (config.map_label_coords[1]*2));
						
					ctx.strokeStyle = "#ffffff";
					for (var i = 0; i < labels.length; i++) {
						for (var x = 0; x < labels[i].length; x++) {
							ctx.fillStyle = rgbToHex(parseInt(main.users[labels[i][x]].colour[0]), parseInt(main.users[labels[i][x]].colour[1]), parseInt(main.users[labels[i][x]].colour[2]));
							ctx.fillRect((config.map_label_coords[0]*2)+(i*320), ((config.map_label_coords[1]*2)+15)+(x*40), 36, 36);
							ctx.beginPath();
							ctx.rect((config.map_label_coords[0]*2)+(i*320), ((config.map_label_coords[1]*2)+15)+(x*40), 36, 36);
							ctx.stroke();
							
							ctx.fillStyle = "#ffffff";
							ctx.fillText(truncateString(main.users[labels[i][x]].name, 15), ((config.map_label_coords[0]*2)+50)+(i*320), ((config.map_label_coords[1]*2)+47)+(x*40));
						}
					}
					//JPEG compression
					const main_cache = canvas.toBuffer("image/jpeg");
					fs.writeFileSync("./maps/cache/main_map.jpg", main_cache);
					
					const attachment = new Discord.MessageAttachment(canvas.toBuffer(), "map_cache.jpg");
					returnChannel(cache_channel).send(map_channel[0] + "_" + open_map_id, {
						files: ["./maps/cache/main_map.jpg"]
					}).then(message => {
						var Attachment = (message.attachments).array();
						Attachment.forEach(function(attachment) {
							//Initialise map
							map_obj.title_str = "Map Viewer:";
							map_obj.interface_string = [
								"You are now viewing the **political** mapmode.",
								"Zoom: " + map_obj.zoom + " ¦ X: " + map_obj.x + " ¦ Y: " + map_obj.y,
								"",
								"Use the arrow keys and magnifying icons at the bottom to navigate around the map."
							];
							map_obj.original_img = attachment.url;
							map_obj.image_str = attachment.url;
							console.log("Image String changed to: " + attachment.url);
						});
					});
				}
				
				async function reloadMap () {
					var render_new = false;
					if (map_obj.left_arrow || map_obj.right_arrow || map_obj.up_arrow || map_obj.down_arrow || map_obj.zoom_in || map_obj.zoom_out) {
						render_new = true;
					}
					
					if (render_new) {
						const canvas = Canvas.createCanvas(Math.ceil(config.map_resolution[0]/4), Math.ceil(config.map_resolution[1]/4));
						const ctx = canvas.getContext("2d");
						const img = await Canvas.loadImage(map_obj.original_img);
						//Centre alignment how?
						var offset_x = 0;
						var offset_y = 0;
						if (map_obj.zoom > 1) {
							offset_x = -(Math.ceil(config.map_resolution[0]/8))*(map_obj.zoom-1);
							offset_y = -(Math.ceil(config.map_resolution[1]/8))*(map_obj.zoom-1);
						}
						/*
							Centre X:
							Scale 1: 1000 = 0    ; 500 = 0
							Scale 2: 2000 = 500  ; 1000 = 250
							Scale 3: 3000 = 750  ; 1500 = 375
							Scale 4: 4000 = 1000 ; 2000 = 500
							Scale 5: 5000 = 1250 ; 2500 = 625
							Scale 6: 6000 = 1500 ; 3000 = 750
						*/
						ctx.drawImage(img, offset_x+(map_obj.x*map_obj.zoom), offset_y+(map_obj.y*map_obj.zoom), Math.ceil(config.map_resolution[0]/4)*map_obj.zoom, Math.ceil(config.map_resolution[1]/4)*map_obj.zoom);
						
						const attachment = new Discord.MessageAttachment(canvas.toBuffer(), "map_viewer.jpg");
						returnChannel(cache_channel).send(map_channel[0] + "_" + open_map_id, attachment).then(message => {
							var Attachment = (message.attachments).array();
							Attachment.forEach(function(attachment) {
								//Initialise map
								map_obj.title_str = "Map Viewer:";
								map_obj.interface_string = [
									"You are now viewing the **political** mapmode.",
									"Zoom: " + map_obj.zoom + " ¦ X: " + (Math.round(map_obj.x*100)/100) + " ¦ Y: " + (Math.round(map_obj.y*100)/100),
									"",
									"Use the arrow keys and magnifying icons at the bottom to navigate around the map."
								];
								map_obj.image_str = attachment.url;
							});
						});
					}
				}
				
				setTimeout(function(){
					var objects = [];
					
					function reloadInterface (embed_obj) {
						if ((map_obj.embed_history[map_obj.embed_history.length-2] != map_obj.embed_history[map_obj.embed_history.length-1]) || (objects[objects.length-2] != objects[objects.length-1])) {
							msg.channel.messages.fetch(map_obj.message_id).then(message => {
								message.edit({embed: embed_obj});
								console.log(embed_obj);
							});
						}
					}
					//Logic loop
					setInterval(function(){
						const interface_screen = {
							"title": map_obj.title_str,
							"color": 9686188,
							"thumbnail": {
								"url": map_obj.thumbnail_str
							},
							"description": map_obj.interface_string.join("\n"),
							"image": {
							  "url": map_obj.image_str
							}
						};
						
						objects.push(map_obj.image_str);
						
						//End of loop
						map_obj.embed_history.push(map_obj.interface_string.join("\n"));
						if (map_obj.embed_history.length > 3) {
							map_obj.embed_history.splice(0, 1);
						}
						if (objects.length > 3) {
							objects.splice(0, 1);
						}
						
						if (map_obj.zoom_in) {
							map_obj.zoom++;
							if (map_obj.zoom > 10) {
								map_obj.zoom = 10;
							}
						}
						if (map_obj.zoom_out) {
							map_obj.zoom--;
							if (map_obj.zoom < 1) {
								map_obj.zoom = 1;
							}
						}
						if (map_obj.left_arrow) {
							map_obj.x = map_obj.x + (1000/map_obj.zoom);
						}
						if (map_obj.right_arrow) {
							map_obj.x = map_obj.x - (1000/map_obj.zoom);
						}
						if (map_obj.up_arrow) {
							map_obj.y = map_obj.y + (1000/map_obj.zoom);
						}
						if (map_obj.down_arrow) {
							map_obj.y = map_obj.y - (1000/map_obj.zoom);
						}
						
						if (map_obj.original_img != "") {
							reloadMap(); //Reload map function
						}
						
						reloadInterface(interface_screen);
						map_obj.left_arrow = false;
						map_obj.right_arrow = false;
						map_obj.up_arrow = false;
						map_obj.down_arrow = false;
						map_obj.zoom_in = false;
						map_obj.zoom_out = false;
					}, 200);
				},3000);
			}
			
			function checkOwner (arg0_province, arg1_message) {
				var msg = arg1_message;
				var province_debug_string = [];
				
				if (isNaN(parseInt(arg0_province)) == false) {
					if (parseInt(arg0_province) >= config.min_provinces && parseInt(arg0_province) <= config.max_provinces) {
						var has_owner = false;
						var ownership_array = [];
						var occupation_array = [];
						var colonisation_array = [];
						
						var province_type = ""; //Uncolonised/Rural/Urban
						for (var i = 0; i < main.user_array.length; i++) {
							var usr = main.users[main.user_array[i]];
							
							//Check for urbanity
							for (var x = 0; x < usr.cities.city_array.length; x++) {
								if (usr.cities[usr.cities.city_array[x]].province == arg0_province) {
									province_type = "Urban";
								}
							}
							
							if (province_type == "") {
								for (var x = 0; x < usr.pops.pop_array.length; x++) {
									if (usr.pops.pop_array[x] == arg0_province) {
										province_type = "Rural";
									}
								}
							}
						}
						
						if (province_type == "") {
							province_type = "Uncolonised";
						}
						
						province_debug_string.push("**Viewing " + province_type + " Province " + arg0_province + ":**");
						province_debug_string.push("---");
						province_debug_string.push("");
						province_debug_string.push("**Ownership:**");
						province_debug_string.push("");
						
						var city_name = "";
						
						for (var i = 0; i < main.user_array.length; i++) {
							var mark_owner = [false, ""];
							var usr = main.users[main.user_array[i]];
							
							//Check for ownership
							for (var x = 0; x < usr.cities.city_array.length; x++) {
								if (usr.cities[usr.cities.city_array[x]].province == arg0_province) {
									mark_owner = [true, usr.name];
									has_owner = true;
									city_name = usr.cities[usr.cities.city_array[x]].name;
								}
							}
							for (var x = 0; x < usr.pops.pop_array.length; x++) {
								if (usr.pops.pop_array[x] == arg0_province) {
									mark_owner = [true, usr.name];
									has_owner = true;
								}
							}
							
							if (mark_owner[0]) {
								var ending_string = "";
								if (city_name != "") {
									ending_string = "Type `" + bot_prefix + 'city "' + city_name + '"` to view more details about this urban province.';
								}
								
								ownership_array.push("Controlled by **" + usr.name + "**. " + ending_string);
							}
							
							//Check if province is being colonised
							for (var x = 0; x < usr.expeditions.length; x++) {
								if (usr.expeditions[x][2].length > 0) {
									for (var y = 0; y < usr.expeditions[x][2].length; y++) {
										if (usr.expeditions[x][2][y] == arg0_province) {
											colonisation_array.push("In the process of being colonised by **" + usr.name + "** as part of Charter #" + x + ". Their efforts will complete in **" + parseNumber(usr.expeditions[x][1]) + "** turn(s).");
										}
									}
								}
							}
						}
							
						//Check if occupied
						for (var i = 0; i < main.users.global.occupations.length; i++) {
							if (main.users.global.occupations[i][0] == arg0_province) {
								occupation_array.push("Currently occupied by **" + main.users[main.users.global.occupations[i][3]].name + "**");
							}
						}
						
						if (ownership_array.length > 0) {
							province_debug_string.push(ownership_array.join("\n"));
						} else {
							province_debug_string.push("Currently uncolonised.");
						}
						
						if (occupation_array.length > 0) {
							province_debug_string.push(occupation_array.join("\n"));
						}
						
						if (colonisation_array.length > 0) {
							province_debug_string.push(colonisation_array.join("\n"));
						}
						
						if (ownership_array.length > 0) {
							province_debug_string.push("");
							province_debug_string.push("---");
							province_debug_string.push("");
							province_debug_string.push("**Population Statistics:**");
							province_debug_string.push("");
							
							var pop_counter = 0;
							var unique_users = [];
							for (var i = 0; i < main.user_array.length; i++) {
								var usr = main.users[main.user_array[i]];
								for (var x = 0; x < usr.pops.pop_array.length; x++) {
									if (usr.pops.pop_array[x] == arg0_province) {
										pop_counter++;
										
										for (var y = 0; y < config.pop_array.length; y++) {
											province_debug_string.push(config.pop_array[y] + ": " + parseNumber(usr.pops[usr.pops.pop_array[x]][config.pop_array[y]]));
										}
										province_debug_string.push("population: " + parseNumber(usr.pops[usr.pops.pop_array[x]].population));
										province_debug_string.push("culture: " + usr.pops[usr.pops.pop_array[x]].culture);
										if (usr.pops[usr.pops.pop_array[x]].supply_limit) {
											province_debug_string.push("supply limit: " + usr.pops[usr.pops.pop_array[x]].supply_limit);
										} else {
											province_debug_string.push("supply limit: " + config.base_supply_limit);
										}
										province_debug_string.push("");
										unique_users.push(usr.id);
									}
								}
							}
							
							province_debug_string.push("Population object found in **" + parseNumber(pop_counter) + "** unique instances in User IDs: (" + unique_users.join(", ") + ").");
						}
						
						msg.channel.send(province_debug_string.join("\n"));
					} else {
						msg.channel.send("You must specify a province ID within the bounds of " + parseNumber(config.min_provinces) + " and " + parseNumber(config.max_provinces) + "!");
					}
				} else {
					msg.channel.send("You must specify a valid numeric ID!");
				}
			}
			
			function forceRender (arg0_mode) {
				var mode = arg0_mode;
				
				if (mode == "political") {
					for (var i = 0; i < main.user_array.length; i++) {
						if (main.users[main.user_array[i]].provinces > 0) {
							var all_province_changes = [];
								
							for (var x = 0; x < main.users[main.user_array[i]].cities.province_array.length; x++) {
								var not_included = true;
								for (var y = 0; y < all_province_changes.length; y++) {
									if (all_province_changes[y] == main.users[main.user_array[i]].cities.province_array[x]) {
										not_included = false;
									}
								}
								if (not_included) {
									all_province_changes.push(main.users[main.user_array[i]].cities.province_array[x]);
								}
							}
							
							for (var x = 0; x < main.users[main.user_array[i]].pops.pop_array.length; x++) {
								var not_included = true;
								for (var y = 0; y < all_province_changes.length; y++) {
									if (all_province_changes[y] == main.users[main.user_array[i]].pops.pop_array[x]) {
										not_included = false;
									}
								}
								if (not_included) {
									all_province_changes.push(main.users[main.user_array[i]].pops.pop_array[x]);
								}
							}
							
							console.log("All province changes: " + all_province_changes);
							
							for (var x = 0; x < all_province_changes.length; x++) {
								original_svg = processSVG([main.users[main.user_array[i]].colour, all_province_changes[x]], original_svg);
							}
						}
					}
					
					//Render occupations
					if (main.users.global.occupations.length > 0) {
						for (var i = 0; i < main.users.global.occupations.length; i++) {
							var new_occ_array = main.users[main.users.global.occupations[i][3]].colour.map((x) => x);
							for (var x = 0; x < new_occ_array.length; x++) {
								new_occ_array[x] = new_occ_array[x] + 20;
							}
							original_svg = processSVG([new_occ_array, main.users.global.occupations[i][0]], original_svg);
						}
					}
				}
				
				writeSVGS();
			}
			
			function rgbToHex(r, g, b) {
				return "#" + componentToHex(r) + componentToHex(g) + componentToHex(b);
			}
			
			function cacheSVG () {
				console.log("Cache SVG called!");
				
				var label_placement = config.map_label_placement; //Last column is overflow
				var labels = []; //[[label1, label2, label3], [label4, label5]]
				
				if (fs.readFileSync("./maps/political_map.svg", "utf8").toString().length > 0) {
					var current_element = 0;
					var counter = 0;
					for (var i = 0; i < main.user_array.length; i++) {
						if (main.users[main.user_array[i]].eliminated) {} else {
							if (label_placement[current_element] != undefined) {
								if (counter == label_placement[current_element]) {
									counter = 0;
									current_element++;
								}
								if (counter < label_placement[current_element]) {
									counter++;
									if (main.users[main.user_array[i]].provinces > 0) {
										if (labels[current_element] == undefined) {
											labels[current_element] = [main.user_array[i]];
										} else {
											labels[current_element].push(main.user_array[i]);
										}
									}
								}
							}
						}
					}
					
					console.log(labels);
					
					const canvas = Canvas.createCanvas(config.map_resolution[0], config.map_resolution[1]);
					const ctx = canvas.getContext("2d");
						
					//Load map
					const background = new Canvas.Image();
					const prov_ids = new Canvas.Image();
					const img = new Canvas.Image();
						
					background.onload = () => ctx.drawImage(background, 0, 0, config.map_resolution[0], config.map_resolution[1]);
					background.onerror = err => { throw err; }
					background.src = "./maps/" + config.map_background;
					img.onload = () => ctx.drawImage(img, 0, 0, config.map_resolution[0], config.map_resolution[1]);
					img.onerror = err => { throw err; }
					img.src = "./maps/political_map.svg";
					prov_ids.onload = () => ctx.drawImage(prov_ids, 0, 0, config.map_resolution[0], config.map_resolution[1]);
					prov_ids.onerror = err => { throw err; }
					prov_ids.src = "./maps/" + config.map_overlay;
						
					//Generate Key
					ctx.font = "36px Bahnschrift Condensed";
					ctx.fillStyle = "#ffffff";
					ctx.fillText("Nations of the World: ", (config.map_label_coords[0]*2)-2, (config.map_label_coords[1]*2));
						
					ctx.strokeStyle = "#ffffff";
					for (var i = 0; i < labels.length; i++) {
						for (var x = 0; x < labels[i].length; x++) {
							ctx.fillStyle = rgbToHex(parseInt(main.users[labels[i][x]].colour[0]), parseInt(main.users[labels[i][x]].colour[1]), parseInt(main.users[labels[i][x]].colour[2]));
							ctx.fillRect((config.map_label_coords[0]*2)+(i*320), ((config.map_label_coords[1]*2)+15)+(x*40), 36, 36);
							ctx.beginPath();
							ctx.rect((config.map_label_coords[0]*2)+(i*320), ((config.map_label_coords[1]*2)+15)+(x*40), 36, 36);
							ctx.stroke();
							
							ctx.fillStyle = "#ffffff";
							ctx.fillText(truncateString(main.users[labels[i][x]].name, 15), ((config.map_label_coords[0]*2)+50)+(i*320), ((config.map_label_coords[1]*2)+47)+(x*40));
						}
					}
					
					//JPEG compression
					const main_cache = canvas.toBuffer("image/jpeg");
					fs.writeFileSync("./maps/cache/map_" + Math.floor(main.year).toString() + ".jpg", main_cache);
				}
			}
			
			function displaySVG (arg0_channel) {
				try {
					var msg = arg0_channel;
					msg.send("__**Map of the World in the year of our Lord, " + returnYear(main.year) + ":**__", {
						files: ["./maps/cache/map_" + Math.floor(main.year).toString() + ".jpg"]
					});
				} catch {}
			}
			
			function processSVG (arg0_options, arg1_var) {
				//console.time("Processing Province #" + arg0_options[1] + ":");
				var output_array = [];
				
				{
					//Process SVG
					var svg_array = arg1_var.split("");
					var in_path = false;
					var in_id_string = false;
					var in_fill = false;
					var fill_counter = 0;
					
					var current_path = [];
					var id = [];
					var starting_element = 0;
					var fill_array = [parseInt(arg0_options[0][0]), parseInt(arg0_options[0][1]), parseInt(arg0_options[0][2])];
					for (var i = 0; i < fill_array.length; i++) {
						if (fill_array[i] < 0) {
							fill_array[i] = 0;
						} else if (fill_array[i] > 255) {
							fill_array[i] = 255;
						}
					}
					
					var original_colour = ("fill:" + rgbToHex(fill_array[0], fill_array[1], fill_array[2]));
					
					var i = 0;
					if (parseInt(arg0_options[1]) > 20) {
						var match = arg1_var.indexOf('id="' + arg0_options[1] + '"');
						i = match-30000;
					}
					while (i++ < svg_array.length) {
						if (svg_array[i-5] == "<" && svg_array[i-4] == "p") {
							in_path = true;
							starting_element = i;
						}
						if (in_path && svg_array[i-4] == "i" && svg_array[i-3] == "d" && svg_array[i-2] == "=" && svg_array[i-1] == '"') {
							in_id_string = true;
						}
						
						//Get ID here
						if (in_id_string && svg_array[i] == '"') {
							in_id_string = false;
							
							if (id.join("") == arg0_options[1]) {
								for (var x = 0; x < current_path.length; x++) {
									if (current_path[x] == "f" && current_path[x+1] == "i" && current_path[x+2] == "l" && current_path[x+3] == 'l' && current_path[x+4] == ':') {
										in_fill = true;
									}
									
									if (current_path[x] == ";") {
										if (in_fill) {
											in_fill = false;
											fill_counter = 0;
										}
									}
									
									if (in_fill) {
										svg_array[starting_element+x] = original_colour[fill_counter];
										fill_counter++;
									}
								}
								break;
							}
							
							id = [];
						}
						
						if (in_path && svg_array[i] == "/" && svg_array[i+1] == ">") {
							in_path = false;
							current_path = [];
						}
						
						if (in_path) {
							current_path.push(svg_array[i]);
						}
						
						if (in_id_string) {
							id.push(svg_array[i]);
						}
					}
					return svg_array.join("");
				}
				//console.timeEnd("Processing Province #" + arg0_options[1] + ":");
			}
		}
		
		//Politics commands
		{
			function coup (arg0_user, arg1_ideology, arg2_msg) {
				var msg = arg2_msg;
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					if (main.users[arg0_user].political_capital >= config.coup_cost) {
						var ideology_exists = false;
						var ideology_valid = false;
						
						for (var i = 0; i < config.government_list.length; i++) {
							if (arg1_ideology.toLowerCase() == config.government_list[i]) {
								ideology_exists = true;
							}
						}
						
						if (ideology_exists) {
							for (var i = 0; i < main.users[arg0_user].available_governments.length; i++) {
								if (arg1_ideology.toLowerCase() == main.users[arg0_user].available_governments[i]) {
									ideology_valid = true;
								}
							}
							if (ideology_valid) {
								usr.political_capital = usr.political_capital - config.coup_cost;
								main.users[arg0_user].overthrow_this_turn = arg1_ideology.toLowerCase();
								msg.channel.send("You have initiated a coup! Your country will begin embracing **" + arg1_ideology.toLowerCase() + "** next turn.");
							} else {
								msg.channel.send("Your people haven't heard of such an ideology yet!");
							}
						} else {
							msg.channel.send("The ideology you have specified is non-existent! Try `" + bot_prefix + "government list` for a valid list of government types.");
						}
					} else {
						msg.channel.send("You don't have enough political capital to afford a coup!");
					}
				} else {
					msg.channel.send("You don't even have a country!");
				}
			}
			
			function enactReform (arg0_user, arg1_reform, arg2_msg, arg3_force_reform) {
				var msg = arg2_msg;
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					
					if (usr.government != "absolute_monarchy" || arg3_force_reform) {
						if (usr.at_war.length == 0 || arg3_force_reform) {
							if (usr.political_capital >= config.reform_cost || arg3_force_reform) {
								var can_enact_reform = false;
								var reform_category_exists = [false, ""];
								var reform_name = "";
								var reform_index = 0;
								
								var all_reform_categories = Object.keys(config.reforms);
								for (var i = 0; i < all_reform_categories.length; i++) {
									var all_reforms_in_category = Object.keys(config.reforms[all_reform_categories[i]]);
									
									for (var x = 0; x < all_reforms_in_category.length; x++) {
										if (all_reforms_in_category[x] == "name") {
											all_reforms_in_category.splice(x, 1);
										}
									}
									
									for (var x = 0; x < all_reforms_in_category.length; x++) {
										if (config.reforms[all_reform_categories[i]][all_reforms_in_category[x]].name.toLowerCase().indexOf(arg1_reform.toLowerCase()) != -1) {
											reform_category_exists = [true, all_reform_categories[i]];
											reform_name = all_reforms_in_category[x];
											reform_index = x;
										}
									}
								}
								for (var i = 0; i < all_reform_categories.length; i++) {
									var all_reforms_in_category = Object.keys(config.reforms[all_reform_categories[i]]);
									
									for (var x = 0; x < all_reforms_in_category.length; x++) {
										if (all_reforms_in_category[x] == "name") {
											all_reforms_in_category.splice(x, 1);
										}
									}
									
									for (var x = 0; x < all_reforms_in_category.length; x++) {
										console.log("Current Policy Name: " + config.reforms[all_reform_categories[i]][all_reforms_in_category[x]].name);
										if (config.reforms[all_reform_categories[i]][all_reforms_in_category[x]].name.toLowerCase() == arg1_reform.toLowerCase()) {
											reform_category_exists = [true, all_reform_categories[i]];
											reform_name = all_reforms_in_category[x];
											reform_index = x;
										}
									}
								}
								
								if (reform_category_exists[0]) {
									var current_reform_index = 0;
									var current_reforms = Object.keys(config.reforms[reform_category_exists[1]]);
									for (var i = 0; i < current_reforms.length; i++) {
										if (current_reforms[i] == "name") {
											current_reforms.splice(i, 1);
										}
									}
									for (var i = 0; i < current_reforms.length; i++) {
										if (current_reforms[i] == usr[reform_category_exists[1]]) {
											current_reform_index = i;
										}
									}
									
									console.log("[Triumph & Tragedy]: CURRENT REFORMS: " + current_reforms);
									console.log("[Triumph & Tragedy]: REFORM INDEX: " + reform_index + ", CURRENT REFORM INDEX: " + current_reform_index);
									
									if ((reform_index == current_reform_index-1 || reform_index == current_reform_index+1) || arg3_force_reform) {
										var can_enact_reform = false;
										
										for (var i = 0; i < usr.available_reforms.length; i++) {
											if (usr.available_reforms[i] == reform_category_exists[1]) {
												can_enact_reform = true;
											}
										}
										
										if (can_enact_reform || arg3_force_reform) {
											var old_reform_obj = config.reforms[reform_category_exists[1]][usr[reform_category_exists[1]]];
											var reform_obj = config.reforms[reform_category_exists[1]][reform_name]
											
											//Remove old reform modifiers
											if (old_reform_obj.political_appeasement != undefined) {
												for (var i = 0; i < config.government_list.length; i++) {
													try {
														if (old_reform_obj.political_appeasement[config.government_list[i] + "_discontent"] != undefined) {
															usr.modifiers[config.government_list[i] + "_discontent"] = usr.modifiers[config.government_list[i] + "_discontent"] + old_reform_obj.political_appeasement[config.government_list[i] + "_discontent"]*-1;
														}
													} catch {}
												}
											}
											if (old_reform_obj.effects != undefined) {
												for (var i = 0; i < old_reform_obj.effects.length; i++) {
													try {
														if (old_reform_obj.effects[i][0] == "stability" || old_reform_obj.effects[i][0] == "max_tax" || old_reform_obj.effects[i][0] == "manpower_percentage" || old_reform_obj.effects[i][0] == "pop_growth_modifier") {
															usr[old_reform_obj.effects[i][0]] = usr[old_reform_obj.effects[i][0]] + old_reform_obj.effects[i][1]*-1;
														} else {
															usr.modifiers[old_reform_obj.effects[i][0]] = usr.modifiers[old_reform_obj.effects[i][0]] + old_reform_obj.effects[i][1]*-1;
														}
													} catch {}
												}
											}
											
											//Add new reform modifiers
											if (reform_obj.political_appeasement != undefined) {
												for (var i = 0; i < config.government_list.length; i++) {
													try {
														if (reform_obj.political_appeasement[config.government_list[i] + "_discontent"] != undefined) {
															usr.modifiers[config.government_list[i] + "_discontent"] = usr.modifiers[config.government_list[i] + "_discontent"] + reform_obj.political_appeasement[config.government_list[i] + "_discontent"]*-1;
														}
													} catch {}
												}
											}
											if (reform_obj.effects != undefined) {
												for (var i = 0; i < reform_obj.effects.length; i++) {
													try {
														if (reform_obj.effects[i][0] == "stability" || reform_obj.effects[i][0] == "max_tax" || reform_obj.effects[i][0] == "manpower_percentage" || reform_obj.effects[i][0] == "pop_growth_modifier") {
															usr[reform_obj.effects[i][0]] = usr[reform_obj.effects[i][0]] + reform_obj.effects[i][1];
														} else {
															usr.modifiers[reform_obj.effects[i][0]] = usr.modifiers[reform_obj.effects[i][0]] + reform_obj.effects[i][1];
														}
													} catch {}
												}
											}
											
											//Subtract political capital
											if (arg3_force_reform != true) {
												usr.political_capital = usr.political_capital - config.reform_cost;
											}
											
											//Random voting by which parties would be in favour of such a bill if democracy
											
											var voting_passed = true;
											var ayes = 0;
											var nays = 0;
											var abstentions = 0;
											
											if ((usr.government == "constitutional_monarchy" || usr.government == "democracy" || usr.government == "socialism") && arg3_force_reform != true) {
												var parliament_report = [];
												parliament_report.push("**__" + reform_obj.name + " Act__**");
												parliament_report.push("------------------");
												parliament_report.push("");
												for (var i = 0; i < config.government_list.length; i++) {
													var stance = ""; //in support, in opposition, neutral
													
													console.log("[Triumph & Tragedy]: Reform Object in Parliament: " + reform_obj);
													if (reform_obj.political_appeasement[config.government_list[i] + "_discontent"] != undefined) {
														if (reform_obj.political_appeasement[config.government_list[i] + "_discontent"] == old_reform_obj.political_appeasement[config.government_list[i] + "_discontent"]) {
															stance = "neutral";
														} else if (reform_obj.political_appeasement[config.government_list[i] + "_discontent"] > old_reform_obj.political_appeasement[config.government_list[i] + "_discontent"]) {
															stance = "in opposition";
														} else if (reform_obj.political_appeasement[config.government_list[i] + "_discontent"] < old_reform_obj.political_appeasement[config.government_list[i] + "_discontent"]) {
															stance = "in support";
														}
													} else {
														stance = "neutral";
													}
													
													if (usr.politics[config.government_list[i]] > 0) {
														if (stance == "in support") {
															var party_ayes = randomNumber(0, usr.politics[config.government_list[i]]);
															var party_abstentions = usr.politics[config.government_list[i]] - party_ayes;
															ayes = ayes + party_ayes;
															abstentions = abstentions + party_abstentions;
															parliament_report.push("The **" + config.governments[config.government_list[i]].name[1] + "** were **supportive** of the motion, with **" + ayes + "** voting in favour, and **" + party_abstentions + "** abstaining.");
														} else if (stance == "in opposition") {
															var party_nays = randomNumber(0, usr.politics[config.government_list[i]]);
															var party_abstentions = usr.politics[config.government_list[i]] - party_nays;
															nays = nays + party_nays;
															abstentions = abstentions + party_abstentions;
															parliament_report.push("The **" + config.governments[config.government_list[i]].name[1] + "** were **opposed** to the motion, with **" + nays + "** voting in opposition, and **" + party_abstentions + "** abstaining.");
														} else if (stance == "neutral") {
															abstentions = abstentions + usr.politics[config.government_list[i]];
															parliament_report.push("The **" + config.governments[config.government_list[i]].name[1] + "** were neither **in favour** nor **in opposition** to the motion, with their entire party of **" + usr.politics[config.government_list[i]] + "** representatives abstaining.");
														}
													}
												}
													
												parliament_report.push("");
												parliament_report.push("The Ayes to the right, **" + ayes + "**, the Noes to the left, **" + nays + "**.\n**" + abstentions + "** MPs refrained from voting on the issue. Unlock.");
												if (msg != "none") {
													msg.channel.send(parliament_report.join("\n"));
												}
											}
											
											if ((usr.government == "constitutional_monarchy" || usr.government == "democracy" || usr.government == "socialism") && arg3_force_reform != true) {
												
												if (usr.modifiers.reform_desire >= 0.5) {
													usr.modifiers.reform_desire = usr.modifiers.reform_desire - 0.5;
												} else {
													usr.modifiers.reform_desire = 0;
												}
												
												if (ayes > nays) {
													if (msg != "none") {
														msg.channel.send("<:checkmark:725550245051760671> You have changed your policy on **" + config.reforms[reform_category_exists[1]].name + "** from **" + old_reform_obj.name + "** to **" + reform_obj.name + "**.");
													}
													usr[reform_category_exists[1]] = reform_name;
												} else {
													if (msg != "none") {
														msg.channel.send("The reform unfortunately failed to pass Parliament.");
													}
												}
											} else {
												if (usr.modifiers.reform_desire >= 0.5) {
													usr.modifiers.reform_desire = usr.modifiers.reform_desire - 0.5;
												} else {
													usr.modifiers.reform_desire = 0;
												}
												usr[reform_category_exists[1]] = reform_name;
												if (msg != "none") {
													msg.channel.send("<:checkmark:725550245051760671> You have changed your policy on **" + config.reforms[reform_category_exists[1]].name + "** from **" + old_reform_obj.name + "** to **" + reform_obj.name + "**.");
												}
											}
										} else {
											if (msg != "none") {
												msg.channel.send("You were unable to enact this reform. Try researching additional technologies first.");
											}
										}
									} else if (reform_index == current_reform_index) {
										if (msg != "none") {
											msg.channel.send("You have already enacted this reform!");
										}
									} else {
										if (msg != "none") {
											msg.channel.send("You cannot proceed to that reform yet!");
										}
									}
								} else {
									if (msg != "none") {
										msg.channel.send("The reform you have specified does not exist!");
									}
								}
							} else {
								if (msg != "none") {
									msg.channel.send("You don't have enough Political Capital to attempt to enact that reform yet! You need **" + (config.reform_cost-usr.political_capital) + "** <:political_capital:716817688525275257> more Political Capital.");
								}
							}
						} else {
							if (msg != "none") {
								msg.channel.send("You can't enact reforms whilst you're at war! Focus on the war effort first.");
							}
						}
					} else {
						if (msg != "none") {
							msg.channel.send("Absolute monarchies cannot enact reforms!");
						}
					}
				} else {
					if (msg != "none") {
						msg.channel.send("You must have a country before you can begin enacting reforms!");
					}
				}
			}
			
			function printCultures (arg0_user, arg1_msg) {
				var msg = arg1_msg;
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					var total_population = 0;
					var culture_string_array = [];
					
					var all_cultures = [];
					var all_culture_provinces = [];
					var all_culture_populations = [];
					
					//Get names of all cultures, and how many provinces and population each culture has.
					//Get names
					for (var i = 0; i < usr.pops.pop_array.length; i++) {
						var culture_already_exists = false;
						if (all_cultures.length > 0) {
							for (var x = 0; x < all_cultures.length; x++) {
								if (usr.pops[usr.pops.pop_array[i]].culture == all_cultures[x]) {
									culture_already_exists = true;
								}
							}
							
							if (culture_already_exists == false) {
								all_cultures.push(usr.pops[usr.pops.pop_array[i]].culture);
							}
						} else {
							all_cultures.push(usr.pops[usr.pops.pop_array[i]].culture);
						}
					}
					
					//Get provinces and population
					for (var i = 0; i < all_cultures.length; i++) {
						var local_provinces = 0;
						var local_population = 0;
						for (var x = 0; x < usr.pops.pop_array.length; x++) {
							if (usr.pops[usr.pops.pop_array[x]].culture == all_cultures[i]) {
								local_provinces++;
								local_population = local_population + usr.pops[usr.pops.pop_array[x]].population;
							}
						}
						
						all_culture_provinces.push(local_provinces);
						all_culture_populations.push([local_population, all_cultures[i], local_provinces]);
					}
					
					var sorted_population_array = all_culture_populations.sort((a,b) => b[0] - a[0]);
					
					culture_string_array.push("<:culture:758424912049864784> Primary Culture: **" + usr.culture + "**.");
					culture_string_array.push("<:consciousness:758424911852470293> Accepted Cultures: " + usr.accepted_cultures.join(", "));
					culture_string_array.push("");
					culture_string_array.push("<:political_capital:716817688525275257> Political Capital: **" + usr.political_capital + "**");
					var has_non_accepted_cultures = false;
					var total_non_accepted_provs = 0;
					var total_non_accepted_pops = 0;
					
					for (var i = 0; i < usr.pops.pop_array.length; i++) {
						var is_accepted = false;
						
						for (var x = 0; x < usr.accepted_cultures.length; x++) {
							if (usr.pops[usr.pops.pop_array[i]].culture == usr.accepted_cultures[x]) {
								is_accepted = true;
							}
						}
						
						if (is_accepted == false) {
							has_non_accepted_cultures = true;
							total_non_accepted_provs++;
							var pop_obj = usr.pops[usr.pops.pop_array[i]];
							total_non_accepted_pops = total_non_accepted_pops + pop_obj.population;
						}
					}
					
					if (has_non_accepted_cultures) {
						culture_string_array.push("<:population:716817688810356826> We have **" + parseNumber(total_non_accepted_provs) + "** non-accepted provinces with a total population of **" + parseNumber(total_non_accepted_pops) + "**, of which we are receiving just **" + (Math.round(usr.modifiers.non_core_manpower*100*100)/100) + "%** of in manpower.");
					}
					
					culture_string_array.push("---");
					culture_string_array.push("");
					
					console.log("All cultures: " + all_cultures);
					console.log("Sorted population array: " + sorted_population_array);
					
					for (var i = 0; i < sorted_population_array.length; i++) {
						total_population = total_population + sorted_population_array[i][0];
					}
					
					for (var i = 0; i < sorted_population_array.length; i++) {
						var culture_description = "";
						
						var primary_culture = false;
						var accepted_culture = false;
						for (var x = 0; x < usr.accepted_cultures.length; x++) {
							if (usr.accepted_cultures[x] == sorted_population_array[i][1]) {
								accepted_culture = true;
							}
						}
						if (usr.culture == sorted_population_array[i][1]) {
							primary_culture = true;
						}
						
						if (primary_culture) {
							culture_description = "our primary culture.";
						} else if (accepted_culture && primary_culture == false) {
							culture_description = "an accepted culture.";
						} else {
							culture_description = "an unaccepted culture. Either assimilate their provinces in `" + bot_prefix + "pops view`, or add them as an accepted culture for **" + config.accepted_culture_cost + "** <:political_capital:716817688525275257> Political Capital."
						}
						
						culture_string_array.push("**" + Math.floor((sorted_population_array[i][0]/total_population)*100) + "%** of our population, or **" + sorted_population_array[i][2] + "** of our provinces identify as **" + sorted_population_array[i][1] + "**, " + culture_description);
					}
					
					culture_string_array.push("");
					culture_string_array.push("---");
					
					if (usr.cultural_integrations.length > 0) {
						//[turns, culture]
						for (var i = 0; i < usr.cultural_integrations.length; i++) {
							culture_string_array.push("We are currently integrating the **" + usr.cultural_integrations[i][1] + "** culture into our society. Our advisors estimate that it will take **" + usr.cultural_integrations[i][0] + "** more turns before they are fully integrated.");
						}
					} else {
						culture_string_array.push("_We are currently not integrating any cultures into our societal fabric._\n\nType `" + bot_prefix + "add-accepted-culture` to begin the integration process for <:political_capital:716817688525275257> **" + config.accepted_culture_cost + "** Political Capital.\nType `" + bot_prefix + "assimilate-all` to attempt the integration of all provinces of a specific culture.");
					}
					
					//Generate embeds
					
					var culture_embeds = [];
					var local_culture_string = [];
					var current_character_count = 0;
					
					if (culture_string_array.length > 0) {
						for (var i = 0; i < culture_string_array.length; i++) {
							local_culture_string.push(culture_string_array[i]);
							current_character_count += culture_string_array[i].length;
							if (i != 0 || culture_string_array.length == 1) {
								if (current_character_count > 3000 || i == culture_string_array.length-1) {
									const embed_cultures = new Discord.MessageEmbed()
										.setColor('#a98ac7')
										.setAuthor('Triumph & Tragedy:', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
										.setTitle('**Cultures:\n------------------**')
										.setThumbnail('https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
										.setDescription(local_culture_string.join("\n"))
										.setTimestamp()
										.setFooter('To access this menu again, type ' + bot_prefix + 'culture.', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png');
										
									culture_embeds.push(embed_cultures);
									current_character_count = 0;
									local_culture_string = [];
								}
							}
						}
					}
					
					console.log(culture_embeds);
					scrollMessage(msg, culture_embeds);
				} else {
					msg.channel.send("The user you have specified must have a nation in order to view your culture screen!");
				}
			}
			
			function printReforms (arg0_user, arg1_page, arg2_msg) {
				var msg = arg2_msg;
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					var all_reform_categories = usr.available_reforms;
					var reform_embeds = [];
					var local_reforms_string = [];
					var prefix_string = [];
					
					prefix_string.push("Reforms are governmental policies that you can choose to attempt to enact at a cost of **" + config.reform_cost + "** <:political_capital:716817688525275257> Political Capital. Successfully enacting reforms will also lower your people's <:consciousness:758424911852470293> Reform Desire.");
					prefix_string.push("<:political_capital:716817688525275257> Political Capital: **" + usr.political_capital + "**");
					prefix_string.push("<:consciousness:758424911852470293> Reform Desire: **" + Math.round(usr.modifiers.reform_desire*100) + "%**");
					prefix_string.push("");
					
					if (all_reform_categories.length > 0) {
						for (var i = 0; i < all_reform_categories.length; i++) {
							local_reforms_string.push("**__" + config.reforms[all_reform_categories[i]].name + ":__**");
							local_reforms_string.push("---");
							local_reforms_string.push("");
							
							var all_reforms_in_category = Object.keys(config.reforms[all_reform_categories[i]]);
							for (var x = 0; x < all_reforms_in_category.length; x++) {
								if (all_reforms_in_category[x] == "name") {
									all_reforms_in_category.splice(x, 1);
								}
							}
							
							for (var x = 0; x < all_reforms_in_category.length; x++) {
								var reform_obj = config.reforms[all_reform_categories[i]][all_reforms_in_category[x]];
								var ending_string = "";
								
								var reform_position = 0;
								for (var y = 0; y < all_reforms_in_category.length; y++) {
									if (all_reforms_in_category[y] == usr[all_reform_categories[i]]) {
										reform_position = y;
									}
								}
								
								if (x == (reform_position-1) || x == (reform_position+1)) {
									ending_string = " - `" + bot_prefix + "enact " + '"' + config.reforms[all_reform_categories[i]][all_reforms_in_category[x]].name + '"' + "`";
								} else if (x == reform_position) {
									ending_string = " - We currently have this reform set to our policy on this matter.";
								} else {
									ending_string = " - This reform is not yet available.";
								}
								
								if (reform_obj.description != undefined) {
									local_reforms_string.push("**[" + reform_obj.name + "](http://tooltip/ '" + reform_obj.description + "')**" + ending_string);
								} else {
									local_reforms_string.push("**[" + reform_obj.name + "](http://tooltip/ '" + reform_obj.description + "')**" + ending_string);
								}
							}
							//Append embed to reform_embeds every 3 reform categories
							const embed_reform_page = new Discord.MessageEmbed()
								.setColor('#a98ac7')
								.setAuthor('Triumph & Tragedy:', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
								.setTitle('**Political Reforms: (Page ' + (i+1) + '/' + (usr.available_reforms.length) + ')\n------------------**')
								.setThumbnail('https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
								.setDescription(prefix_string.join("\n") + local_reforms_string.join("\n"))
								.setTimestamp()
								.setFooter('To access this menu again, type ' + bot_prefix + 'reforms <page>.', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png');
								
								reform_embeds.push(embed_reform_page);
								local_reforms_string = [];
						}
					} else {
						local_reforms_string.push("---");
						local_reforms_string.push("");
						local_reforms_string.push("_You currently have have no available reforms that you can pursue._");
						local_reforms_string.push("Research additional <:technology:716812861514711040> **Technologies** in order to unlock more reforms.");
						const embed_reform_page = new Discord.MessageEmbed()
							.setColor('#a98ac7')
							.setAuthor('Triumph & Tragedy:', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
							.setTitle('**Political Reforms:\n------------------**')
							.setThumbnail('https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
							.setDescription(prefix_string.join("\n") + local_reforms_string.join("\n"))
							.setTimestamp()
							.setFooter('To access this menu again, type ' + bot_prefix + 'reforms <page>.', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png');
							
							reform_embeds.push(embed_reform_page);
					}
					
					if (isNaN(arg1_page) == false) {
						if (arg1_page <= Math.ceil(all_reform_categories.length)) {
							scrollMessage(msg, reform_embeds, arg1_page-1);
						} else {
							msg.channel.send("You have specified an invalid page.");
						}
					} else {
						msg.channel.send("You must specify a valid page in numerical form.");
					}
				} else {
					msg.channel.send("You must have an independent nation in order to enact reforms!");
				}
			}
			
			function raiseStability (arg0_user, arg1_msg) {
				var msg = arg1_msg;
				
				if (main.users[arg0_user] != undefined) {
					var user_id = main.users[arg0_user];
					
					if (user_id.political_capital >= config.stability_cost) {
						if (user_id.stability_decay < config.max_stab_boost) {
							msg.channel.send("<:stability:716817688722407424> You have raised your stability by **10%**! (-1% per turn).");
							
							user_id.political_capital = user_id.political_capital - config.stability_cost;
							user_id.stability = user_id.stability + 10;
							
							if (user_id.stability > 100) {
								user_id.stability = 100;
							}
							
							user_id.stability_decay = user_id.stability_decay + 10;
						} else {
							msg.channel.send("You can't boost your stability beyond **" + config.max_stab_boost + "%**!");
						}
					} else {
						msg.channel.send("You don't have enough Political Capital to raise stability yet! You need **" + parseNumber(config.stability_cost-user_id.political_capital) + "** more <:political_capital:716817688525275257> **Political Capital** to raise your stability by **10%**.");
					}
				} else {
					msg.channel.send("You don't even have a country yet!");
				}
			}
			
			function supportParty (arg0_user, arg1_party, arg2_msg) {
				var msg = arg2_msg;
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					var valid_party = false;
					for (var i = 0; i < usr.available_governments.length; i++) {
						if (usr.available_governments[i] == arg1_party) {
							valid_party = true;
						}
					}
					
					if (valid_party) {
						if (usr.political_capital >= 50) {
							if (usr.politics[arg1_party] == 100) {
								msg.channel.send("**" + arg1_party + "** already has maximum support!");
							} else {
								usr.political_capital = usr.political_capital - 50;
								usr.politics[arg1_party] = usr.politics[arg1_party] + 10;
								
								var total_percentage = 0;
								for (var i = 0; i < config.government_list.length; i++) {
									total_percentage = total_percentage + usr.politics[config.government_list[i]];
									console.log("[Triumph & Tragedy]: Political Party Adjustment Needed: " + (total_percentage-100));
								}
								
								if (total_percentage > 100) {
									var decrease_needed = total_percentage-100;
									for (var i = 0; i < config.government_list.length; i++) {
										if (config.government_list[i] != arg1_party) {
											if (decrease_needed > 0) {
												if (usr.politics[config.government_list[i]] >= decrease_needed) {
													usr.politics[config.government_list[i]] = usr.politics[config.government_list[i]] - decrease_needed;
													decrease_needed = 0;
												} else {
													decrease_needed = decrease_needed - usr.politics[config.government_list[i]];
													usr.politics[config.government_list[i]] = 0;
												}
											}
										}
									}
									if (decrease_needed > 0) {
										for (var i = 0; i < config.government_list.length; i++) {
											if (config.government_list[i] != arg1_party) {
												usr.politics[config.government_list[i]] = 0;
											} else {
												usr.politics[config.government_list[i]] = 100;
											}
										}
										decrease_needed = 0;
									}
								}
								
								msg.channel.send("You boosted **" + arg1_party + "** by **10%** for <:political_capital:716817688525275257> 50 Political Capital.");
							}
						} else {
							msg.channel.send("You need at least <:political_capital:716817688525275257> " + (50-usr.political_capital) + " Political Capital to be able to promote **" + arg1_party + "**!");
						}
					} else {
						msg.channel.send("The party you have specified does not exist! Try using " + usr.available_governments.join(", ") + " instead.");
					}
				} else {
					msg.channel.send("You can't support a nonexistent party in a nonexistent country!");
				}
			}
		}
		
		//Population commands
		{
			function addAcceptedCulture (arg0_user, arg1_culture, arg2_msg) {
				var msg = arg2_msg;
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					var all_cultures = [];
					
					for (var i = 0; i < usr.pops.pop_array.length; i++) {
						var culture_already_exists = false;
						
						if (all_cultures.length > 0) {
							for (var x = 0; x < all_cultures.length; x++) {
								if (all_cultures[x] == usr.pops[usr.pops.pop_array[i]].culture) {
									culture_already_exists = true;
								}
							}
						}
						
						if (culture_already_exists == false) {
							all_cultures.push(usr.pops[usr.pops.pop_array[i]].culture);
						}
					}
					
					var culture_exists = [false, ""];
					
					//Soft match first
					for (var i = 0; i < all_cultures.length; i++) {
						if (all_cultures[i].toLowerCase().indexOf(arg1_culture.toLowerCase()) != -1) {
							culture_exists = [true, all_cultures[i]];
						}
					}
					//Hard match second
					for (var i = 0; i < all_cultures.length; i++) {
						if (all_cultures[i].toLowerCase() == arg1_culture.toLowerCase()) {
							culture_exists = [true, all_cultures[i]];
						}
					}
					
					if (culture_exists[0]) {
						var culture_is_already_accepted = false;
						
						for (var i = 0; i < usr.accepted_cultures.length; i++) {
							if (usr.accepted_cultures[i] == culture_exists[1]) {
								culture_is_already_accepted = true;
							}
						}
						
						if (culture_is_already_accepted == false) {
							//Check for Political Capital costs
							
							if (usr.political_capital >= config.accepted_culture_cost) {
								usr.political_capital = usr.political_capital - config.accepted_culture_cost;
								
								//[turns, culture]
								usr.cultural_integrations.push([config.integration_turns, culture_exists[1]]);
								msg.channel.send("You have begun to integrate the **" + culture_exists[1] + "** culture into your nation's societal fabric. Your analysts estimate that this will take up to **" + config.integration_turns + "** turns.");
							} else {
								msg.channel.send("You need <:political_capital:716817688525275257> **" + (config.accepted_culture_cost-usr.political_capital) + "** more Political Capital to begin integrating an entire culture into your country.");
							}
						} else {
							msg.channel.send("The culture you have specified is already accepted in your country!");
						}
					} else {
						msg.channel.send("The culture you have specified could not be found in your nation! Type `" + bot_prefix + "culture` for a list of valid cultures that comprise the social fabric of your country.");
					}
				} else {
					msg.channel.send("You need a country before you can start assimilating other cultures into it!");
				}
			}
			
			function assimilate (arg0_user, arg1_province, arg2_culture, arg3_msg) {
				//Convert from parameters
				var user_id = arg0_user;
				var province_id = arg1_province;
				var culture_name = arg2_culture;
				var msg = arg3_msg;
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					var province_exists = [false, ""];
					
					for (var i = 0; i < usr.pops.pop_array.length; i++) {
						if (usr.pops.pop_array[i] == province_id) {
							province_exists = [true, usr.pops[usr.pops.pop_array[i]]];
						}
					}
					
					if (province_exists[0]) {
						var is_accepted_culture = [false, ""];
						
						//Soft match
						for (var i = 0; i < usr.accepted_cultures.length; i++) {
							if (usr.accepted_cultures[i].toLowerCase().indexOf(culture_name.toLowerCase()) != -1) {
								is_accepted_culture = [true, usr.accepted_cultures[i]];
							}
						}
						//Hard match
						for (var i = 0; i < usr.accepted_cultures.length; i++) {
							if (usr.accepted_cultures[i].toLowerCase() == culture_name.toLowerCase()) {
								is_accepted_culture = [true, usr.accepted_cultures[i]];
							}
						}
						
						if (is_accepted_culture[0]) {
							//Check for assimilate_cost and assimilate_fiscal_cost
							if (province_exists[1].culture != usr.culture) {
								if (usr.political_capital >= config.assimilate_cost) {
									if (usr.money >= config.assimilate_fiscal_cost) {
										//Check if province is already being assimilated
										var is_being_assimilated = [false, ""];
										for (var i = 0; i < usr.assimilations.length; i++) {
											if (usr.assimilations[i][2] == province_id) {
												is_being_assimilated = [true, usr.assimilations[i]];
											}
										}
										
										if (!is_being_assimilated[0]) {
											//[turns, culture, province]
											usr.assimilations.push([config.assimilation_turns, is_accepted_culture[1], province_id]);
											usr.political_capital = usr.political_capital - config.assimilate_cost;
											usr.money = usr.money - config.assimilate_fiscal_cost;
											if (msg != "none") {
												msg.channel.send("We have begun assimilating the province of **" + province_id + "** for <:political_capital:716817688525275257> **" + parseNumber(config.assimilate_cost) + "** Political Capital and <:money:716817688718213192> " + parseNumber(config.assimilate_fiscal_cost) + " into our cultural fabric. Your advisor estimates that it will take up to **" + config.assimilation_turns + "** turns before the locals learn to embrace our culture.");
												
												return true;
											}
										} else {
											if (msg != "none") {
												msg.channel.send("Province **" + province_id + "** is already being assimilated to the **" + is_being_assimilated[1][1] + "** culture! Your advisor estimates that it will take up to **" + parseNumber(is_being_assimilated[1][0]) + "** turn(s) for the province to finish the assimilation process.");
											}
										}
									} else {
										if (msg != "none") {
											msg.channel.send("You don't have enough money to assimilate this province! You need **£" + parseNumber(config.assimilate_fiscal_cost-usr.money) + "** more to carry out this action.");
										}
									}
								} else {
									if (msg != "none") {
										msg.channel.send("You don't have enough Political Capital to assimilate this province! You need **" + (config.assimilate_cost-usr.political_capital) + "** more <:political_capital:716817688525275257> Political Capital to carry out this action.");
									}
								}
							} else {
								if (msg != "none") {
									msg.channel.send("You may not integrate a province that is already of your own primary culture already!");
								}
							}
						} else {
							if (msg != "none") {
								msg.channel.send("You must choose a valid accepted culture to assimilate to! Try using your nation's primary culture. If you're not sure what that is, type `" + bot_prefix + "culture`.");
							}
						}
					} else {
						if (msg != "none") {
							msg.channel.send("You must type in a valid province ID within your nation's control!");
						}
					}
				} else {
					if (msg != "none") {
						msg.channel.send("You must have a country first before you can start assimilating others to your nation's culture!");
					}
				}
			}
			
			function assimilateAll (arg0_user, arg1_culture, arg2_culture, arg3_msg) {
				//Convert from parameters
				var assimilating_culture = getCulture(arg1_culture);
				var core_culture = getCulture(arg2_culture);
				var msg = arg3_msg;
				var raw_assimilating_culture = arg1_culture;
				var raw_core_culture = arg2_culture;
				var user_id = arg0_user;
				var usr = (main.users[arg0_user]) ? main.users[arg0_user] : undefined;
				
				//Declare local instance variables
				var assimilated_provinces = 0;
				var target_provinces = [];
				var total_unassimilated_provinces = 0;
				var unassimilated_culture_exists = false;
				
				//Check if user is defined
				if (usr) {
					if (assimilating_culture) {
						if (core_culture) {
							if (usr.accepted_cultures.includes(core_culture)) {
								//Check if assimilating_culture exists in a user's territory
								for (var i = 0; i < usr.pops.pop_array.length; i++) {
									var local_pop_obj = usr.pops[usr.pops.pop_array[i]];
									unassimilated_culture_exists = (local_pop_obj.culture == assimilating_culture) ? true : unassimilated_culture_exists;
								}
								
								if (unassimilated_culture_exists) {
									//Fetch local instance statistics first
									for (var i = 0; i < usr.pops.pop_array.length; i++) {
										var local_pop_obj = usr.pops[usr.pops.pop_array[i]];
										
										if (local_pop_obj.culture == assimilating_culture) {
											total_unassimilated_provinces++;
											target_provinces.push(usr.pops.pop_array[i]);
										}
									}
									
									//Then begin trying to assimilate as many marked provinces as found
									for (var i = 0; i < target_provinces.length; i++) {
										var province_assimilation_status = assimilate(user_id, target_provinces[i], core_culture, "none");
										if (province_assimilation_status) assimilated_provinces++;
									}
									
									//Print status message
									if (assimilated_provinces == total_unassimilated_provinces) {
										msg.channel.send("You have successfully begun integrating all **" + assimilated_provinces + "** " + assimilating_culture + " province(s) underneath your control to the **" + core_culture + "** culture.");
									} else {
										msg.channel.send("You have begun integrating **" + assimilated_provinces + "**/**" + total_unassimilated_provinces + "** " + assimilating_culture + " province(s) underneath your control to the **" + core_culture + "** culture. The others could not be assimilating either due to a shortage of <:political_capital:716817688525275257> Political Capital, or <:money:716817688718213192> Money.");
									}
								} else {
									msg.channel.send("No such culture as **" + assimilating_culture + "** could even be found in your territory!");
								}
							} else {
								msg.channel.send("You cannot assimilate other peoples to a non-accepted culture of yours!");
							}
						} else {
							msg.channel.send("The culture you have mandated the assimilation of **" + assimilating_culture + "** to, **" + raw_core_culture + "** proved as imaginary as the people of Prester John!");
						}
					} else {
						msg.channel.send("The culture you have mandated the assimilation of, **" + raw_assimilating_culture + "** could not be found anywhere in the world!");
					}
				} else {
					msg.channel.send("You can't start assimilating people if you don't even have a nation at hand to do so!");
				}
			}
			
			function removeAcceptedCulture (arg0_user, arg1_culture, arg2_msg) {
				//Convert from parameters
				var culture_name = arg1_culture;
				var msg = arg2_msg;
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					var culture_exists = [false, ""];
					var all_cultures = [];
					
					for (var i = 0; i < usr.pops.pop_array.length; i++) {
						var culture_already_exists = false;
						
						if (all_cultures.length > 0) {
							for (var x = 0; x < all_cultures.length; x++) {
								if (all_cultures[x] == usr.pops[usr.pops.pop_array[i]].culture) {
									culture_already_exists = true;
								}
							}
						}
						
						if (culture_already_exists == false) {
							all_cultures.push(usr.pops[usr.pops.pop_array[i]].culture);
						}
					}
					
					//Soft match first
					for (var i = 0; i < all_cultures.length; i++) {
						if (all_cultures[i].toLowerCase().indexOf(culture_name.toLowerCase()) != -1) {
							culture_exists = [true, all_cultures[i]];
						}
					}
					//Hard match second
					for (var i = 0; i < all_cultures.length; i++) {
						if (all_cultures[i].toLowerCase() == culture_name.toLowerCase()) {
							culture_exists = [true, all_cultures[i]];
						}
					}
					
					if (culture_exists[0]) {
						var is_accepted_culture = false;
						
						for (var i = 0; i < usr.accepted_cultures.length; i++) {
							if (accepted_cultures[i] == culture_exists[1]) {
								is_accepted_culture = true;
							}
						}
						
						if (is_accepted_culture) {
							if (usr.culture == culture_exists[1]) {
								msg.channel.send("You cannot oppress your primary culture!");
							} else {
								for (var i = 0; i < usr.accepted_cultures.length; i++) {
									if (usr.accepted_cultures[i] == culture_exists[1]) {
										usr.accepted_cultures.splice(i, 1);
									}
								}
								
								msg.channel.send("We have begun oppressing the **" + culture_exists[1] + "** minority in our country, and as such they have been removed from the list of accepted cultures.");
							}
						} else {
							msg.channel.send("The culture you have specified is already not an accepted culture! Check `" + bot_prefix + "culture` for a list of accepted cultures.");
						}
					} else {
						msg.channel.send("The culture you have specified doesn't even exist in your country!");
					}
				} else {
					msg.channel.send("You must have a nation in order to begin oppressing minorities!");
				}
			}
			
			function renameCulture (arg0_user, arg1_name, arg2_msg, arg3_vassal) {
				//Convert from parameters
				var msg = arg2_msg;
				var vassal_string = (arg3_vassal) ? "vassal's " : "";
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					var culture_already_exists = false;
					
					for (var i = 0; i < main.user_array.length; i++) {
						if (main.users[main.user_array[i]].culture.toLowerCase() == arg1_name.toLowerCase()) {
							culture_already_exists = true;
						}
					}
					
					if (arg1_name.indexOf("@everyone") == -1 && arg1_name.indexOf("@here") == -1) {
						if (arg1_name.length <= 25) {
							if (culture_already_exists == false) {
								if (!usr.customisation_locked) {
									for (var i = 0; i < main.user_array.length; i++) {
										for (var x = 0; x < main.users[main.user_array[i]].pops.pop_array.length; x++) {
											if (main.users[main.user_array[i]].pops[main.users[main.user_array[i]].pops.pop_array[x]].culture == usr.culture) {
												main.users[main.user_array[i]].pops[main.users[main.user_array[i]].pops.pop_array[x]].culture = arg1_name;
											}
										}
										for (var x = 0; x < main.users[main.user_array[i]].accepted_cultures.length; x++) {
											if (main.users[main.user_array[i]].accepted_cultures[x] == usr.culture) {
												main.users[main.user_array[i]].accepted_cultures[x] = arg1_name;
											}
										}
										for (var x = 0; x < main.users[main.user_array[i]].assimilations.length; x++) {
											if (main.users[main.user_array[i]].assimilations[x][1] == usr.culture) {
												main.users[main.user_array[i]].assimilations[x][1] = arg1_name;
											}
										}
									}
									usr.culture = arg1_name;
									
									msg.channel.send("You have successfully changed your " + vassal_string + "culture name to **" + arg1_name + "**.");
								} else {
									msg.channel.send("Your overlord has decreed that you may not change the name of your culture!");
								}
							} else {
								msg.channel.send("A culture by that name already exists!");
							}
						} else {
							msg.channel.send("Your " + vassal_string + " culture name exceeded the maximum of 25 characters!");
						}
					} else {
						msg.channel.send("Stop trying to ping everyone! This is a warnable offence.");
					}
				} else {
					msg.channel.send("You must have a nation before being able to rename your culture!");
				}
			}
			
			function viewPops (arg0_user, arg1_msg) {
				var msg = arg1_msg;
				var embed_pop_array = [];
				var local_arrays = [];
				
				//Check if user exists
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					var total_array = [];
					for (var i = 0; i < usr.pops.pop_array.length; i++) {
						total_array.push(usr.pops.pop_array[i]);
					}
					
					if (usr.pops.pop_array.length > 0) {
						//Sort out cities first
						if (usr.cities.city_array.length > 0) {
							var city_array = [];
							var city_name_array = [];
							for (var i = 0; i < usr.cities.city_array.length; i++) {
								city_array.push(usr.cities[usr.cities.city_array[i]].province);
								city_name_array.push(usr.cities[usr.cities.city_array[i]].name);
							}
							for (var i = 0; i < city_array.length; i++) {
								try {
									var current_demographics = [];
									current_demographics.push("**" + city_name_array[i] + "**:");
									if (usr.pops[city_array[i]] != undefined) {
										current_demographics.push(" - population: **" + parseNumber(usr.pops[city_array[i]].population) + "**");
										for (var x = 0; x < config.pop_array.length; x++) {
											current_demographics.push(" - " + config.pop_array[x] + ": " + parseNumber(usr.pops[city_array[i]][config.pop_array[x]]));
										}
										current_demographics.push(" - culture: " + usr.pops[city_array[i]].culture);
										//Check if culture is accepted. If not, add assimilate command.
										var culture_accepted = false;
										for (var x = 0; x < usr.accepted_cultures.length; x++) {
											if (usr.accepted_cultures[x] == usr.pops[city_array[i]].culture) {
												culture_accepted = true;
											}
										}
										//assimilations: [turns, culture, province]
										var is_assimilating = [false, 0, ""];
										if (usr.assimilations.length > 0) {
											for (var x = 0; x < usr.assimilations.length; x++) {
												if (usr.assimilations[x][2] == city_array[i]) {
													is_assimilating = [true, usr.assimilations[x][0], usr.assimilations[x][1]];
												}
											}
										}
										
										if (culture_accepted == false) {
											if (is_assimilating[0]) {
												current_demographics.push(" - This province is currently assimilating to the **" + is_assimilating[2] + "** culture. We expect assimilation to be complete in **" + is_assimilating[1] + "** more turns.");
											} else {
												current_demographics.push(" - `" + bot_prefix + "assimilate " + city_array[i] + "`");
											}
										}
										local_arrays.push(current_demographics);
										total_array.remove(city_array[i]);
									} else {
										console.log("Province " + city_array[i] + " returned undefined!");
									}
								} catch {}
							}
						}
						//Sort out the rest of the provinces
						for (var i = 0; i < total_array.length; i++) {
							try {
								var current_demographics = [];
								current_demographics.push("**Province " + total_array[i] + "**:");
								current_demographics.push(" - population: " + parseNumber(usr.pops[total_array[i]].population));
								for (var x = 0; x < config.pop_array.length; x++) {
									current_demographics.push(" - " + config.pop_array[x] + ": " + parseNumber(usr.pops[total_array[i]][config.pop_array[x]]));
								}
								current_demographics.push(" - culture: " + usr.pops[total_array[i]].culture);
								//Check if culture is accepted. If not, add assimilate command.
								var culture_accepted = false;
								for (var x = 0; x < usr.accepted_cultures.length; x++) {
									if (usr.accepted_cultures[x] == usr.pops[total_array[i]].culture) {
										culture_accepted = true;
									}
								}
								//assimilations: [turns, culture, province]
								var is_assimilating = [false, 0, ""];
								if (usr.assimilations.length > 0) {
									for (var x = 0; x < usr.assimilations.length; x++) {
										if (usr.assimilations[x][2] == city_array[i]) {
											is_assimilating = [true, usr.assimilations[x][0], usr.assimilations[x][1]];
										}
									}
								}
								
								if (culture_accepted == false) {
									if (is_assimilating[0]) {
										current_demographics.push(" - This province is currently assimilating to the **" + is_assimilating[2] + "** culture. We expect assimilation to be complete in **" + is_assimilating[1] + "** more turns.");
									} else {
										current_demographics.push(" - `" + bot_prefix + "assimilate " + total_array[i] + "`");
									}
								}
								local_arrays.push(current_demographics);
								total_array.remove(city_array[i]);
							} catch {}
						}
						//Add provinces to array
						if (local_arrays.length > 5) {
							var temp_array_string = [];
							for (var i = 0; i < local_arrays.length; i++) {
								if (temp_array_string.length < 5) {
									temp_array_string.push(local_arrays[i].join("\n"));
								} else {
									const embed_pop = new Discord.MessageEmbed()
										.setColor('#a98ac7')
										.setAuthor('Triumph & Tragedy:', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
										.setTitle('**Population Overview:\n------------------**\nPage ' + (embed_pop_array.length+1) + ' of ' + Math.ceil((local_arrays.length/5)) + '\n')
										.setThumbnail('https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
										.setDescription(temp_array_string.join("\n"))
										.setTimestamp()
										.setFooter('To access this menu again, type ' + bot_prefix + 'pops.', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png');
									embed_pop_array.push(embed_pop);
									temp_array_string = [];
									temp_array_string.push(local_arrays[i].join("\n"));
								}
											
								if (local_arrays.length > 5) {
									if (i == local_arrays.length-1) {
										const embed_pop = new Discord.MessageEmbed()
											.setColor('#a98ac7')
											.setAuthor('Triumph & Tragedy:', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
											.setTitle('**Population Overview:\n------------------**\nPage ' + (embed_pop_array.length+1) + ' of ' + Math.ceil((local_arrays.length/5)) + '\n')
											.setThumbnail('https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
											.setDescription(temp_array_string.join("\n"))
											.setTimestamp()
											.setFooter('To access this menu again, type ' + bot_prefix + 'pops view.', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png');
										embed_pop_array.push(embed_pop);
										temp_array_string = [];
									}
								}
							}
							scrollMessage(msg, embed_pop_array);
						} else {
							var break_arrays = [];
							for (var i = 0; i < local_arrays.length; i++) {
								break_arrays.push(local_arrays[i].join("\n"));
							}
							const embed_pop = new Discord.MessageEmbed()
								.setColor('#a98ac7')
								.setAuthor('Triumph & Tragedy:', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
								.setTitle('**Population Overview:\n------------------**\nPage ' + 1 + ' of ' + Math.ceil(local_arrays.length/10) + '\n')
								.setThumbnail('https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
								.setDescription(break_arrays.join("\n"))
								.setTimestamp()
								.setFooter('To access this menu again, type ' + bot_prefix + 'pops view.', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png');
							msg.channel.send(embed_pop);
						}
					} else {
						msg.channel.send("The user you have specified has a population of ... zero.");
					}
				} else {
					msg.channel.send("The user you have specified does not have a country!");
				}
			}
		}
		
		//Print commands
		{
			function printAllModifiers (arg0_user, arg1_msg) {
				var msg = arg1_msg;
				
				if (main.users[arg0_user] != undefined) {
					//printNumber, parses numbers and rounds them
					function printNumber (arg0_number, arg1_mode) {
						if (arg1_mode == "inverse") {
							if (arg0_number < 1 || arg0_number == 1) {
								return "-" + Math.abs(Math.round((1-arg0_number)*100)) + "%";
							} else {
								return "+" + Math.abs(Math.round((1-arg0_number)*100)) + "%";
							}
						}
						if (arg1_mode != undefined) {
							if (arg1_mode.indexOf("percentile") != -1) {
								//Round to the nearest hundred
								var minus = 0;
								if (arg1_mode.indexOf("regular") != -1) {
									minus = 100;
								}
								var rounded_number = Math.round(arg0_number*100)-minus;
								
								if (rounded_number >= 0) {
									return "+" + rounded_number + "%";
								} else if (rounded_number < 0) {
									return rounded_number + "%";
								}
							}
						} else {
							if (arg0_number > 0) {
								return "+" + Math.round(arg0_number*100)/100;
							} else {
								return Math.round(arg0_number*100)/100;
							}
						}
					}
					
					var usr = main.users[arg0_user];
					
					var political_modifiers_array = [];
					var economic_modifiers_array = [];
					var military_modifiers_array = [];
					
					//Political
					political_modifiers_array.push("Administrative Efficiency: **" + printNumber(usr.modifiers.administrative_efficiency, "percentile") + "**");
					political_modifiers_array.push("Advisor Cost: **" + printNumber(usr.modifiers.advisor_cost, "inverse") + "**");
					political_modifiers_array.push("CB Generation Speed: **" + printNumber(usr.modifiers.cb_generation_speed, "percentile") + "**");
					political_modifiers_array.push("Centralisation: **" + printNumber(usr.modifiers.centralisation, "percentile") + "**");
					political_modifiers_array.push("Diplomatic Slots: **" + printNumber(usr.modifiers.starting_diplomatic_slots) + "**");
					political_modifiers_array.push("Infamy Loss: **" + printNumber(usr.modifiers.infamy_loss) + "**");
					political_modifiers_array.push("Influence Gain: **" + printNumber(usr.modifiers.influence_gain) + "**");
					political_modifiers_array.push("Jingoism: **" + printNumber(usr.modifiers.jingoism, "percentile") + "**");
					political_modifiers_array.push("Opinion Modifier: **" + printNumber(usr.modifiers.opinion_modifier) + "**");
					political_modifiers_array.push("Overextension: **" + printNumber(usr.modifiers.overextension, "percentile") + "**");
					political_modifiers_array.push("Stability: **" + printNumber(Math.round(usr.stability+usr.modifiers.stability_modifier)) + "%**");
					political_modifiers_array.push("Reform Desire Gain: **" + printNumber(usr.modifiers.reform_desire_gain, "percentile") + "**");
					political_modifiers_array.push("Republicanism: **" + printNumber(usr.modifiers.republicanism, "percentile") + "**");
					political_modifiers_array.push("Ruling Party Support Gain: **" + printNumber(usr.modifiers.ruling_party_support/100, "percentile") + "**");
					political_modifiers_array.push("Political Capital Gain: **" + printNumber(usr.modifiers.political_capital_gain) + "**");
					political_modifiers_array.push("Prestige Gain: **" + printNumber(usr.modifiers.prestige_gain) + "**");
					
					//Economy
					economic_modifiers_array.push("Building Cost: **" + printNumber(usr.modifiers.building_cost, "inverse") + "**");
					economic_modifiers_array.push("Construction Speed: **" + printNumber(usr.modifiers.construction_speed, "inverse") + "**");
					economic_modifiers_array.push("Extra Building Slots: **" + printNumber(usr.modifiers.extra_building_slots) + "**");
					economic_modifiers_array.push("Isolation: **" + printNumber(usr.modifiers.isolation, "percentile") + "**");
					economic_modifiers_array.push("Production Efficiency: **" + printNumber(usr.modifiers.production_efficiency, "percentile regular") + "**");
					economic_modifiers_array.push("Research Efficiency: **" + printNumber(usr.modifiers.research_efficiency, "percentile") + "**");
					economic_modifiers_array.push("Research Slots: **" + printNumber(usr.modifiers.research_slots) + "**");
					economic_modifiers_array.push("RGO Throughput: **" + printNumber(usr.modifiers.rgo_throughput, "percentile") + "**");
					economic_modifiers_array.push("Shipment Capacity: **" + printNumber(usr.modifiers.shipment_capacity) + "**");
					economic_modifiers_array.push("Shipment Time: **" + printNumber(usr.modifiers.shipment_time, "inverse") + "**");
					economic_modifiers_array.push("Tax Efficiency: **" + printNumber(usr.modifiers.tax_efficiency, "percentile") + "**");
					economic_modifiers_array.push("---");
					economic_modifiers_array.push("");
					for (var i = 0; i < config.building_categories.length; i++) {
						economic_modifiers_array.push(config.building_categories[i].split("_").join(" ").replace(/(^\w{1})|(\s{1}\w{1})/g, match => match.toUpperCase()) + " Building Slots: **" + printNumber(usr.modifiers[config.building_categories[i] + "_building_slots"], "percentile regular") + "**");
					}
					for (var i = 0; i < config.materials.length; i++) {
						economic_modifiers_array.push(config.materials[i].split("_").join(" ").replace(/(^\w{1})|(\s{1}\w{1})/g, match => match.toUpperCase()) + " Gain: **" + printNumber(usr.modifiers[config.materials[i] + "_gain"], "percentile regular") + "**");
					}
					for (var i = 0; i < config.pop_array.length; i++) {
						economic_modifiers_array.push(config.pops[config.pop_array[i]].name + " Growth Rate: **" + printNumber(usr.modifiers[config.pop_array[i] + "_growth_modifier"], "percentile regular") + "**");
					}
					
					//Military
					military_modifiers_array.push("Attrition Rate: **" + printNumber(usr.modifiers.attrition_rate, "inverse") + "**");
					military_modifiers_array.push("Army Professionalism: **" + printNumber(usr.modifiers.army_professionalism, "percentile regular") + "**");
					military_modifiers_array.push("Army Travel Speed: **" + printNumber(usr.modifiers.army_travel_speed, "inverse") + "**");
					military_modifiers_array.push("Army Upkeep: **" + printNumber(usr.modifiers.army_upkeep, "percentile regular") + "**");
					military_modifiers_array.push("Blockade Efficiency: **" + printNumber(usr.modifiers.blockade_efficiency, "percentile regular") + "**");
					military_modifiers_array.push("Casualty Reduction: **" + printNumber(usr.modifiers.casualty_reduction, "inverse") + "**");
					military_modifiers_array.push("Colonial Immigration Rate: **" + printNumber(usr.modifiers.colonial_immigration_rate, "percentile regular") + "**");
					military_modifiers_array.push("Colonial Maintenance: **" + printNumber(usr.modifiers.colonial_immigration_rate, "inverse") + "**");
					military_modifiers_array.push("Colonial Power Gain: **" + printNumber(usr.modifiers.colonial_power_gain, "percentile regular") + "**");
					military_modifiers_array.push("Colonial Power Cap: **" + printNumber(usr.modifiers.colonial_power_cap) + "**");
					military_modifiers_array.push("Colonist Travel Speed: **" + printNumber(usr.modifiers.colonist_travel_speed, "inverse") + "**");
					military_modifiers_array.push("Command Power Gain: **" + printNumber(usr.modifiers.command_power_gain) + "**");
					military_modifiers_array.push("National Manpower: **" + printNumber(usr.modifiers.national_manpower, "percentile regular") + "**");
					military_modifiers_array.push("Naval Professionalism: **" + printNumber(usr.modifiers.navy_professionalism, "percentile regular") + "**");
					military_modifiers_array.push("Non-Core Manpower: **" + printNumber(usr.modifiers.non_core_manpower, "percentile") + "**");
					military_modifiers_array.push("Maximum Expeditions: **" + printNumber(usr.modifiers.maximum_expeditions) + "**");
					military_modifiers_array.push("Mobilisation Size: **" + printNumber(usr.modifiers.mobilisation_size, "percentile regular") + "**");
					military_modifiers_array.push("Supply Consumption: **" + printNumber(usr.modifiers.supply_consumption, "inverse") + "**");
					military_modifiers_array.push("Training Cost: **" + printNumber(usr.modifiers.training_cost, "inverse") + "**");
					military_modifiers_array.push("War Exhaustion Rate: **" + printNumber(usr.modifiers.war_exhaustion_rate, "percentile regular") + "**");
					military_modifiers_array.push("---");
					military_modifiers_array.push("");
					military_modifiers_array.push("Air AP: **" + printNumber(usr.modifiers.aeroplanes_ap, "percentile regular") + "**");
					military_modifiers_array.push("Air DP: **" + printNumber(usr.modifiers.aeroplanes_dp, "percentile regular") + "**");
					military_modifiers_array.push("Armour AP: **" + printNumber(usr.modifiers.ground_vehicles_ap, "percentile regular") + "**");
					military_modifiers_array.push("Armour DP: **" + printNumber(usr.modifiers.ground_vehicles_dp, "percentile regular") + "**");
					military_modifiers_array.push("Artillery AP: **" + printNumber(usr.modifiers.ground_artillery_ap, "percentile regular") + "**");
					military_modifiers_array.push("Artillery DP: **" + printNumber(usr.modifiers.ground_artillery_dp, "percentile regular") + "**");
					military_modifiers_array.push("Infantry AP: **" + printNumber(usr.modifiers.ground_units_ap, "percentile regular") + "**");
					military_modifiers_array.push("Infantry DP: **" + printNumber(usr.modifiers.ground_units_dp, "percentile regular") + "**");
					military_modifiers_array.push("Naval AP: **" + printNumber(usr.modifiers.naval_units_ap, "percentile regular") + "**");
					military_modifiers_array.push("Naval DP: **" + printNumber(usr.modifiers.naval_units_dp, "percentile regular") + "**");
					
					const embed_political_modifiers = new Discord.MessageEmbed()
						.setColor('#a98ac7')
						.setAuthor('Triumph & Tragedy:', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
						.setTitle('**Political Modifiers:\n------------------**')
						.setThumbnail('https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
						.setDescription(political_modifiers_array.join("\n"))
						.setTimestamp()
						.setFooter('To access this menu again, type ' + bot_prefix + 'modifiers.', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png');
						
					const embed_economic_modifiers = new Discord.MessageEmbed()
						.setColor('#a98ac7')
						.setAuthor('Triumph & Tragedy:', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
						.setTitle('**Economic Modifiers:\n------------------**')
						.setThumbnail('https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
						.setDescription(economic_modifiers_array.join("\n"))
						.setTimestamp()
						.setFooter('To access this menu again, type ' + bot_prefix + 'modifiers.', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png');
						
					const embed_military_modifiers = new Discord.MessageEmbed()
						.setColor('#a98ac7')
						.setAuthor('Triumph & Tragedy:', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
						.setTitle('**Military Modifiers:\n------------------**')
						.setThumbnail('https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
						.setDescription(military_modifiers_array.join("\n"))
						.setTimestamp()
						.setFooter('To access this menu again, type ' + bot_prefix + 'modifiers.', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png');
						
					scrollMessage(msg, [embed_political_modifiers, embed_economic_modifiers, embed_military_modifiers], 0);
				} else {
					msg.channel.send("You need to have a nation first before being able to view your active modifiers!");
				}
			}
			
			function printAllNationalSpirits (arg0_user, arg1_msg, arg2_page) {
				var msg = arg1_msg;
				var current_page = 0;
				
				if (arg2_page != undefined) {
					if (isNaN(arg2_page) == false) {
						current_page = parseInt(arg2_page);
					}
				}
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					var has_national_spirits = false;
					var all_national_spirits = Object.keys(usr.national_spirits);
					var all_embeds = [];
					
					var toc_string = [];
					
					if (all_national_spirits.length > 0) {
						has_national_spirits = true;
					}
					
					if (has_national_spirits) {
						toc_string.push("This is a table of contents of all current **National Modifiers** for the **" + usr.name + "**. You can jump to a specific National Modifier by typing `" + bot_prefix + "view-national-modifiers <ID>`. The ID is printed in bold to the left of the modifier name.");
						toc_string.push("---");
						toc_string.push("");
						for (var i = 0; i < all_national_spirits.length; i++) {
							var local_obj = usr.national_spirits[all_national_spirits[i]];
							
							var local_icon = "";
							var local_name = "";
							
							if (local_obj.icon != undefined) {
								local_icon = local_obj.icon;
							}
							if (local_obj.name != undefined) {
								local_name = local_obj.name;
							} else {
								local_name = all_national_spirits[i];
							}
							
							toc_string.push("**" + (i+1) + ".** " + local_icon + " " + local_name);
						}
						
						const embed_toc = new Discord.MessageEmbed()
							.setColor('#a98ac7')
							.setAuthor('Triumph & Tragedy:', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
							.setTitle('**National Modifiers - Table of Contents:\n------------------**')
							.setThumbnail('https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
							.setDescription(toc_string.join("\n"))
							.setTimestamp()
							.setFooter('To access this menu again, type ' + bot_prefix + 'view-national-modifiers.', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png');
						
						//Push for each different National Modifier
						for (var i = 0; i < all_national_spirits.length; i++) {
							var local_obj = usr.national_spirits[all_national_spirits[i]];
							
							var local_image = "https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png";
							var local_description = "This modifier currently has no effect. Events in the world may change this at a later date.";
							var local_name = "";
							
							if (local_obj.name != undefined) {
								local_name = local_obj.name;
							} else {
								local_name = all_national_spirits[i];
							}
							
							if (local_obj.description != undefined) {
								local_description = local_obj.description;
							}
							
							if (local_obj.img != undefined) {
								local_image = local_obj.img;
							}
							
							const embed_spirit = new Discord.MessageEmbed()
								.setColor('#a98ac7')
								.setAuthor('Triumph & Tragedy:', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
								.setTitle('**' + local_name + '\n------------------**')
								.setThumbnail(local_image)
								.setDescription(local_description)
								.setTimestamp()
								.setFooter('To access this menu again, type ' + bot_prefix + 'view-national-modifiers.', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png');
								
							all_embeds.push(embed_spirit);
						}
					} else {
						toc_string.push("You currently have no active **National Modifiers**! National Modifiers can affect other modifiers in your country until said modifiers are removed, and can be caused by events and player actions.");
					}
						
					const embed_toc = new Discord.MessageEmbed()
						.setColor('#a98ac7')
						.setAuthor('Triumph & Tragedy:', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
						.setTitle('**National Modifiers - Table of Contents:\n------------------**')
						.setThumbnail('https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
						.setDescription(toc_string.join("\n"))
						.setTimestamp()
						.setFooter('To access this menu again, type ' + bot_prefix + 'view-national-modifiers.', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png');
							
					all_embeds.unshift(embed_toc);
					
					scrollMessage(msg, all_embeds, current_page);
				} else {
					msg.channel.send("You need to have a nation first in order to have any national spirits!");
				}
			}
			
			function printBudget (arg0_user, arg1_msg) {
				var msg = arg1_msg;
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					var budget_string = [];
					var minimum = 0;
					var maximum = 0;
					
					minimum = minimum + config.starting_actions;
					maximum = maximum + config.starting_actions;
					
					for (var i = 0; i < main.users[arg0_user].cities.city_array.length; i++) {
						var local_city = usr.cities[usr.cities.city_array[i]];
						for (var x = 0; x < config.buildings.length; x++) {
							if (config.building_stats[config.buildings[x]].produces != undefined) {
								for (var y = 0; y < config.building_stats[config.buildings[x]].produces.length; y++) {
									if (config.building_stats[config.buildings[x]].produces[y][1] == "actions") {
										if (Array.isArray(config.building_stats[config.buildings[x]].produces[y][0])) {
											minimum = minimum + config.building_stats[config.buildings[x]].produces[y][0][0]*local_city.buildings[config.buildings[x]];
											maximum = maximum + config.building_stats[config.buildings[x]].produces[y][0][1]*local_city.buildings[config.buildings[x]];
										} else {
											minimum = minimum + config.building_stats[config.buildings[x]].produces[y][0]*local_city.buildings[config.buildings[x]];
											maximum = maximum + config.building_stats[config.buildings[x]].produces[y][0]*local_city.buildings[config.buildings[x]];
										}
									}
								}
							}
						}
					}
					//user_id.money = user_id.money + Math.ceil((user_id.actions*config.money_per_action)*user_id.tax_rate*user_id.modifiers.tax_efficiency);
					
					var civ_actions = 0;
					if (config.governments[usr.government].civilian_actions != undefined) {
						civ_actions = Math.ceil(usr.actions*config.governments[usr.government].civilian_actions);
					} else {
						civ_actions = Math.ceil(usr.actions*usr.civilian_actions_percentage);
					}
					
					var minimum_income = parseNumber(Math.ceil((((usr.actions-civ_actions)+minimum)*config.money_per_action)*usr.tax_rate*usr.modifiers.tax_efficiency));
					var maximum_income = parseNumber(Math.ceil((((usr.actions-civ_actions)+maximum)*config.money_per_action)*usr.tax_rate*usr.modifiers.tax_efficiency));
					
					//Calculate Building Upkeep
					var building_upkeep = 0;
					for (var i = 0; i < usr.cities.city_array.length; i++) {
						var local_city = usr.cities[usr.cities.city_array[i]];
						for (var x = 0; x < config.buildings.length; x++) {
							if (config.building_stats[config.buildings[x]].cost_per_turn != undefined) {
								for (var y = 0; y < config.building_stats[config.buildings[x]].cost_per_turn.length; y++) {
									if (config.building_stats[config.buildings[x]].cost_per_turn[y][1] == "money") {
										building_upkeep = building_upkeep + (config.building_stats[config.buildings[x]].cost_per_turn[y][0]*local_city.buildings[config.buildings[x]]);
									}
								}
							}
						}
					}
					
					budget_string.push("**Economic Statistics:**\n");
					budget_string.push("<:government:716817688693047306> Tax Efficiency: **" + Math.ceil(usr.modifiers.tax_efficiency*100) + "%**");
					budget_string.push("- <:aristocrats:732730754643132457> Aristocracy Modifier: **+" + Math.ceil((usr.aristocrats/100000)*config.pops.aristocrats.tax_efficiency_per_100k) + "%**");
					
					var tax_eff_from_temporary_modifiers = 0;
					for (var i = 0; i < usr.temporary_modifiers.length; i++) {
						if (usr.temporary_modifiers[i][0] == "tax_efficiency") {
							tax_eff_from_temporary_modifiers = tax_eff_from_temporary_modifiers + usr.temporary_modifiers[i][1];
						}
					}
					
					if (tax_eff_from_temporary_modifiers > 0) {
						budget_string.push("- <:building:716827579650408538> Tax Efficiency from temporary modifiers: **+" + tax_eff_from_temporary_modifiers + "%**");
					} else if (tax_eff_from_temporary_modifiers < 0) {
						budget_string.push("- <:cb:716828676855169107> Tax Efficiency from temporary modifiers: **-" + tax_eff_from_temporary_modifiers + "%**");
					}
					
					budget_string.push("");
					budget_string.push("<:actions:716817688244256770> **" + parseNumber(usr.actions) + "** Actions (**+" + parseNumber(minimum) + "**-**" + parseNumber(maximum) + "** per turn)");
					budget_string.push("**" + usr.civilian_actions_percentage*100 + "%** of your actions will be used up as <:trade:716828677115084812> **Civilian Goods** next turn.");
					budget_string.push("Your economic advisor estimates that you will gain <:money:716817688718213192> **" + minimum_income + "**-**" + maximum_income + "** in tax income next turn.");
					budget_string.push("");
					var total_soldiers = usr.used_soldiers + usr.mobilised_manpower[0];
					if (total_soldiers > 0) {
						budget_string.push("**£" + new Intl.NumberFormat('de', {style: 'decimal'}).format(Math.ceil((total_soldiers/100)*usr.modifiers.army_upkeep)) + "** will be spent on the military each turn.");
					}
					if (building_upkeep > 0) {
						budget_string.push("**£" + new Intl.NumberFormat('de', {style: 'decimal'}).format(Math.ceil(building_upkeep)) + "** will be spent on building maintenance each turn.");
					}
					
					budget_string.push("------------------ \n**Economic Policy:**\n");
					budget_string.push("Current tax rate: (**" + Math.round(usr.tax_rate*100) + "%**/**" + usr.max_tax*100 + "%**) - Type `" + bot_prefix + "set-tax [number]` to adjust your tax rate.");
					if (usr.blockaded == false) {
						budget_string.push("");
						budget_string.push("<:blockade:716817688592252979> Blockade status: you are currently not blockaded.");
					} else {
						budget_string.push("<:blockade:716817688592252979> Blockade status: **You are currently under a blockade!**");
					}
					
					const embed_budget = new Discord.MessageEmbed()
						.setColor('#a98ac7')
						.setAuthor('Triumph & Tragedy:', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
						.setTitle('**Budget:\n------------------**')
						.setThumbnail(usr.flag)
						.setDescription(budget_string.join("\n"))
						.setTimestamp()
						.setFooter('To access this menu again, type ' + bot_prefix + 'budget.', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png');
						
					return embed_budget;
				} else {
					msg.channel.send("The user you have specified did not have a nation!");
				}
			}
			
			function printBuildings (arg0_user, arg1_username, arg2_msg) {
				var building_string = [];
				var msg = arg2_msg;
				
				if (main.users[arg0_user] == undefined) {
					arg2_msg.channel.send("The person you are looking for is stateless!");
				} else {
					var usr = main.users[arg0_user];
					building_string.push("The stats below do not include negative/positive modifiers related to production, only the base amount. Check `$economy` for a more accurate total assessment.");
					building_string.push("");
					
					var building_count = 0;
					var building_cap = 0;
					var building_counts = {
					};
					
					for (var i = 0; i < main.users[arg0_user].cities.city_array.length; i++) {
						for (var x = 0; x < config.buildings.length; x++) {
							building_count = building_count + main.users[arg0_user].cities[main.users[arg0_user].cities.city_array[i]].buildings[config.buildings[x]];
							if (building_counts[config.buildings[x]] != undefined) {
								building_counts[config.buildings[x]] = building_counts[config.buildings[x]] + main.users[arg0_user].cities[main.users[arg0_user].cities.city_array[i]].buildings[config.buildings[x]];
							} else {
								building_counts[config.buildings[x]] = main.users[arg0_user].cities[main.users[arg0_user].cities.city_array[i]].buildings[config.buildings[x]];
							}
						}
						building_cap = building_cap + main.users[arg0_user].cities[main.users[arg0_user].cities.city_array[i]].building_cap;
					}
					
					var minimum = config.starting_actions;
					var maximum = config.starting_actions;
					
					for (var i = 0; i < config.buildings.length; i++) {
						if (building_counts[config.buildings[i]] != undefined && building_counts[config.buildings[i]] > 0) {
							var building_localisation_string = "";
							if (config.building_stats[config.buildings[i]].produces != undefined) {
								building_localisation_string = building_localisation_string + ", providing you with ";
								building_production_array = [];
								for (var x = 0; x < config.building_stats[config.buildings[i]].produces.length; x++) {
									var multiplier = 1;
									if (usr.modifiers[config.building_stats[config.buildings[i]].produces[x][1]] != undefined) {
										multiplier = usr.modifiers[config.building_stats[config.buildings[i]].produces[x][1]];
									}
									
									if (Array.isArray(config.building_stats[config.buildings[i]].produces[x][0])) {
										building_production_array.push(parseNumber(building_counts[config.buildings[i]]*config.building_stats[config.buildings[i]].produces[x][0][0]) + " - " + parseNumber(building_counts[config.buildings[i]]*config.building_stats[config.buildings[i]].produces[x][0][1]) + " " + config.building_stats[config.buildings[i]].produces[x][1]);
										
										if (config.building_stats[config.buildings[i]].produces[x][1] == "actions") {
											minimum = minimum + building_counts[config.buildings[i]]*config.building_stats[config.buildings[i]].produces[x][0][0]*multiplier;
											maximum = maximum + building_counts[config.buildings[i]]*config.building_stats[config.buildings[i]].produces[x][0][1]*multiplier;
										}
									} else {
										building_production_array.push(parseNumber(building_counts[config.buildings[i]]*config.building_stats[config.buildings[i]].produces[x][0]*multiplier) + " " + config.building_stats[config.buildings[i]].produces[x][1]);
										
										if (config.building_stats[config.buildings[i]].produces[x][1] == "actions") {
											minimum = minimum + building_counts[config.buildings[i]]*config.building_stats[config.buildings[i]].produces[x][0];
											maximum = maximum + building_counts[config.buildings[i]]*config.building_stats[config.buildings[i]].produces[x][0];
										}
									}
								}
								building_localisation_string = building_localisation_string + building_production_array.join(", ") + " every round.";
							} else if (config.building_stats[config.buildings[i]].cost_per_turn != undefined) {
								building_localisation_string = building_localisation_string + " These buildings also cost ";
								building_maintenance_array = [];
								for (var x = 0; x < config.building_stats[config.buildings[i]].cost_per_turn.length; x++) {
									var multiplier = 1;
									if (usr.modifiers[config.building_stats[config.buildings[i]].cost_per_turn[x][1]] != undefined) {
										multiplier = usr.modifiers[config.building_stats[config.buildings[i]].cost_per_turn[x][1]];
									}
									
									if (Array.isArray(config.building_stats[config.buildings[i]].cost_per_turn[x][0])) {
										building_maintenance_array.push(parseNumber(building_counts[config.buildings[i]]*config.building_stats[config.buildings[i]].cost_per_turn[x][0] + " - " + parseNumber(building_counts[config.buildings[i]]*config.building_stats[config.buildings[i]].cost_per_turn[x][1]) + " " + config.building_stats[config.buildings[i]].cost_per_turn[x][1]));
									} else {
										building_maintenance_array.push(parseNumber(building_counts[config.buildings[i]]*config.building_stats[config.buildings[i]].cost_per_turn[x][0] + " " + config.building_stats[config.buildings[i]].cost_per_turn[x][1]));
									}
								}
								building_localisation_string = building_localisation_string + " " + building_maintenance_array.join(", ") + " each turn.";
							}
							if (building_localisation_string != "") {
								building_string.push("You have **" + building_counts[config.buildings[i]] + "** " + config.buildings[i] + building_localisation_string);
							} else {
								building_string.push("You have **" + building_counts[config.buildings[i]] + "** " + config.buildings[i] + ".");
							}
						}
					}
					
					if (building_count == 0) {
						building_string.push("_You don't have any buildings in your cities producing resources._");
					}
					
					building_string.push("\n<:actions:716817688244256770> **Total Actions** per turn: " + minimum + "-" + maximum + " actions per round.");
					building_string.push("<:development:716811992421367869> **Building Cap:** (**" + building_count + "**/" + building_cap + ")\nThe building cap can be expanded by expanding your territory.");
					
					var building_embeds = [];
					var local_building_string = [];
					
					if (building_string.length > 0) {
						for (var i = 0; i < building_string.length; i++) {
							local_building_string.push(building_string[i]);
							if (i != 0 || building_string.length == 1) {
								if (i % 20 == 0 || i == building_string.length-1) {
									const embed_building = new Discord.MessageEmbed()
										.setColor('#a98ac7')
										.setAuthor('Triumph & Tragedy:', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
										.setTitle('**Building Production (' + usr.name + '):\n------------------**')
										.setThumbnail('https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
										.setDescription(local_building_string.join("\n"))
										.setTimestamp()
										.setFooter('To access this menu again, type ' + bot_prefix + 'industry.', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png');
											
									building_embeds.push(embed_building);
									local_building_string = [];
								}
							}
						}
					}
					
					scrollMessage(msg, building_embeds, 0);
				}
			}
			
			function printColonisation (arg0_user, arg1_msg) {
				var msg = arg1_msg;
				var colonisation_string = [];
				
				//["conquistadors", turn_amount, [province_ids]]
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					var user_id = main.users[arg0_user];
					
					colonisation_string.push("<:provinces:716809229603700737> **Capital Province:** " + main.users[arg0_user].capital_id);
					colonisation_string.push("<:colonisation:716821194891853826> **Maximum Expedition Limit:** " + user_id.modifiers.maximum_expeditions);
					colonisation_string.push("<:taxes:716817688781127810> **Colonisation Speed:** Your colonists can move at a rate of **" + parseNumber(config.colonisation_speed*user_id.modifiers.colonist_travel_speed) + "** provinces per turn.");
					colonisation_string.push("------------------\n**Available Colonial Units**:\n");
					var colonising_units = [];
					var total_units = 0;
					var provinces_can_colonise = 0;
					for (var i = 0; i < config.units.length; i++) {
						if (config.unit_stats[config.units[i]].colonise_provinces != undefined) {
							colonising_units.push(config.units[i]);
						}
					}
					
					for (var i = 0; i < colonising_units.length; i++) {
						total_units = total_units + user_id.military[colonising_units[i]];
						provinces_can_colonise = provinces_can_colonise + user_id.military[colonising_units[i]]*config.unit_stats[colonising_units[i]].colonise_provinces;
					}
					if (provinces_can_colonise == 0) {
						colonisation_string.push("_You don't have any units capable of colonising!_");
					} else {
						colonisation_string.push("You have **" + total_units + "** total units capable of colonising **" + provinces_can_colonise + "** province(s).");
						colonisation_string.push("Type `" + bot_prefix + "settle <prov 1> <prov 2> <...>` to use your colonisation units.");
						colonisation_string.push("");
						colonisation_string.push("Type `" + bot_prefix + "reserves` to view these units.");
					}
					
					colonisation_string.push("------------------\n**Expeditions**:\n");
					if (user_id.expeditions.length == 0) {
						colonisation_string.push("_You have no ongoing expeditions._");
					} else {
						var extra_expeditions = 0;
						for (var i = 0; i < user_id.expeditions.length; i++) {
							if (i < 10) {
								colonisation_string.push("<:old_map:716821884867444746> Charter #" + i + " - **" + user_id.expeditions[i][0] + "**:");
								//[["conquistadors",6,["194"]]]
								if (user_id.expeditions[i][1] > 2) {
									colonisation_string.push(" - The **" + user_id.expeditions[i][0] + "** will arrive in **" + (user_id.expeditions[i][1]-2) + "** turns. `" + bot_prefix + "cancel-charter " + i + "`");
								} else {
									colonisation_string.push(" - The **" + user_id.expeditions[i][0] + "** have arrived! They have begun setting up a colony, and your advisor estimates that it will take them **" + user_id.expeditions[i][1] + "** more turn(s).");
								}
								colonisation_string.push(" - They hope to colonise the province(s) of **" + user_id.expeditions[i][2].join(", ") + "**.");
							} else {
								extra_expeditions++;
							}
						}
						if (extra_expeditions > 0) {
							colonisation_string.push("+" + extra_expeditions + " more ...");
						}
					}
					
					const colonisation_embed = new Discord.MessageEmbed()
						.setColor('#a98ac7')
						.setAuthor('Triumph & Tragedy:', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
						.setTitle('**Colonisation:\n------------------**')
						.setThumbnail(usr.flag)
						.setDescription(colonisation_string.join("\n"))
						.setTimestamp()
						.setFooter('To access this menu again, type ' + bot_prefix + 'expeditions or ' + bot_prefix + 'colonisation.', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png');
						
					return colonisation_embed;
				} else {
					msg.channel.send("You don't even have a country yet!");
				}
			}
			
			function printConstructions (arg0_user, arg1_msg, arg2_page) {
				//Convert from parameters
				var user_id = arg0_user;
				var usr = (main.users[arg0_user]) ? main.users[arg0_user] : undefined;
				var msg = arg1_msg;
				var page = (arg2_page) ? arg2_page : 0;
				
				//Declare local instance variables
				var construction_obj = {};
				var construction_string = [];
				
				if (usr) {
					//Push all constructions to construction_string as a formatted array, initialise all construction_obj fields first
					for (var i = 0; i < usr.under_construction.length; i++) if (!construction_obj[usr.under_construction[i][2]]) construction_obj[usr.under_construction[i][2]] = [];
					for (var i = 0; i < usr.under_construction.length; i++) construction_obj[usr.under_construction[i][2]].push(usr.under_construction[i]);
					
					//Fetch cities alphabetically
					var all_cities = Object.keys(construction_obj).sort();
					var raw_city_names = [];
					for (var i = 0; i < all_cities.length; i++) raw_city_names.push(`${usr.cities[all_cities[i]].name},${all_cities[i]}`);
					raw_city_names = raw_city_names.sort();
					all_cities = [];
					for (var i = 0; i < raw_city_names.length; i++) all_cities.push(raw_city_names[i].split(",")[1]);
					
					for (var i = 0; i < all_cities.length; i++) {
						var local_constructions = construction_obj[all_cities[i]];
						
						//Only display city if constructions are currently ongoing there
						if (local_constructions.length > 0) {
							construction_string.push(`**${usr.cities[all_cities[i]].name}**:`);
							for (var x = 0; x < local_constructions.length; x++) construction_string.push(`Currently constructing ${local_constructions[x][0]} ${local_constructions[x][1]} in this city. They will finish in **${local_constructions[x][3]}** turn(s).`);
							construction_string.push("");
						}
					}
					
					if (construction_string.length == 0) construction_string.push("_You do not have any constructions currently ongoing within your territory._\n\nCancellation of building constructions can be caused by enemy occupations during wars. Type `" + bot_prefix + "build` to start a new construction.");
					
					//Display embeds
					var construction_embeds = [];
					var local_construction_string = [];
					var current_character_count = 0;
					
					if (construction_string.length > 0) {
						for (var i = 0; i < construction_string.length; i++) {
							local_construction_string.push(construction_string[i]);
							current_character_count += construction_string[i].length;
							if (i != 0 || construction_string.length == 1) {
								if (current_character_count > 2800 || i == construction_string.length-1) {
									const embed_constructions = new Discord.MessageEmbed()
										.setColor('#a98ac7')
										.setAuthor('Triumph & Tragedy:', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
										.setTitle('**Building Construction List (' + usr.name + '):\n------------------**')
										.setThumbnail('https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
										.setDescription(local_construction_string.join("\n"))
										.setTimestamp()
										.setFooter('To access this menu again, type ' + bot_prefix + 'constructions.', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png');
										
									construction_embeds.push(embed_constructions);
									current_character_count = 0;
									local_construction_string = [];
								}
							}
						}
					}
					
					scrollMessage(msg, construction_embeds, page);
				} else {
					msg.channel.send("You can't view the constructions of a nonexistent nation!");
				}
			}
			
			function printDiplomacy (arg0_user, arg1_msg) {
				var msg = arg1_msg;
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					var diplomacy_string = [];
					var pc_gain = Math.floor(usr.modifiers.political_capital_gain);
					var pc_gain_suffix = "";
					var culture_cost = 0;
					var acc_cultures = 0;
					if (usr.vassals.length > 0) {
						pc_gain = pc_gain - (usr.modifiers.political_capital_gain*(0.2*usr.vassals.length));
					}
					for (var i = 0; i < usr.accepted_cultures.length; i++) {
						if (usr.accepted_cultures[i] != usr.culture) {
							pc_gain = pc_gain - config.accepted_culture_maintenance_cost;
							culture_cost = culture_cost + config.accepted_culture_maintenance_cost;
							acc_cultures++;
						}
					}
					pc_gain = Math.floor(usr.modifiers.political_capital_gain);
					if (pc_gain > 0) {
						pc_gain_suffix = "+";
					}
					
					diplomacy_string.push("<:political_capital:716817688525275257> Political Capital: **" + parseNumber(usr.political_capital) + "** (" + pc_gain_suffix + parseNumber(pc_gain) + " per turn)");
					
					if (usr.vassals.length > 0) {
						diplomacy_string.push("Our **" + parseNumber(usr.vassals.length) + "** vassals are costing us **" + parseNumber(usr.modifiers.political_capital_gain*(0.2*usr.vassals.length)) + "** Political Capital per turn.");
					}
					if (culture_cost > 0) {
						diplomacy_string.push("Our **" + parseNumber(acc_cultures) + "** accepted cultures are costing us **" + parseNumber(culture_cost) + "** Political Capital per turn.");
					}
					
					var infamy_prefix = "";
					if (usr.modifiers.infamy_loss > 0) {
						infamy_prefix = "+";
					}
					diplomacy_string.push("<:infamy:716817688453709905> Infamy: **" + parseNumber(usr.infamy) + "** (" + infamy_prefix + Math.round(usr.modifiers.infamy_loss*100)/100 + " per turn)");
					
					//Check if user is at war
					if (usr.at_war.length > 0) {
						diplomacy_string.push("<:land_vehicles:716821195215077406> You are currently **at war** with " + usr.at_war.join(", ") + ".");
						diplomacy_string.push("Type `" + bot_prefix + "view-war <name>` to view statistics on a current conflict.");
					} else {
						diplomacy_string.push("<:diplomacy:716827579323121666> _You are currently at peace._");
					}
					diplomacy_string.push("");
					diplomacy_string.push("Type `" + bot_prefix + "war-list` for a list of current conflicts.");
					
					//Print ledger
					diplomacy_string.push("------------------\n**Diplomatic Overview:** For a full list, type `" + bot_prefix + "ledger`.");
					diplomacy_string.push("Type `" + bot_prefix + "diplomacy-view` to conduct diplomacy with another nation.");
					diplomacy_string.push("Type `" + bot_prefix + "cede-province` to cede one of your provinces to another nation.");
					diplomacy_string.push("- `" + bot_prefix + "allow-ceding` ¦ `" + bot_prefix + "deny-ceding`");
					
					var allow_cede_names = [];
					for (var i = 0; i < usr.allow_cede.length; i++) allow_cede_names.push("**" + main.users[usr.allow_cede[i]].name + "**");
					
					if (usr.allow_cede.length == 0) {
						diplomacy_string.push("_You are currently not allowing anyone to cede their provinces to you._");
					} else {
						diplomacy_string.push("You currently allow " + allow_cede_names.join(", ") + " to cede their provinces to you.");
					}
					
					diplomacy_string.push("");
					diplomacy_string.push("`Name ¦ User ID ¦ Provinces ¦ Population`");
					diplomacy_string.push("");
					
					for (var i = 0; i < main.user_array.length; i++) { //Max. 10 list
						if (i < 10) {
							diplomacy_string.push("**" + main.users[main.user_array[i]].name + "** ¦ " + main.user_array[i] + " ¦ " + main.users[main.user_array[i]].provinces + " ¦ " + parseNumber(main.users[main.user_array[i]].population));
						}
					}
					if (main.user_array.length >= 10) {
						diplomacy_string.push("+" + (main.user_array.length-10) + " more ...");
					}
					
					const embed_diplomacy = new Discord.MessageEmbed()
						.setColor('#a98ac7')
						.setAuthor('Triumph & Tragedy:', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
						.setTitle('**Diplomatic Overview:\n------------------**')
						.setThumbnail(usr.flag)
						.setDescription(diplomacy_string.join("\n"))
						.setTimestamp()
						.setFooter('To access this menu again, type ' + bot_prefix + 'diplomacy.', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png');
					
					return embed_diplomacy;
				} else {
					msg.channel.send("The user you have specified did not have a country!");
				}
			}
			
			function printEconomy (arg0_user, arg1_msg) {
				var msg = arg1_msg;
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					var economy_string = [];
					
					economy_string.push("**Population:**\n");
					economy_string.push("<:workers:732730754735276124> Available Workers: **" + parseNumber(usr.workers-usr.used_workers) + "**");
					economy_string.push("- <:population:716817688810356826> Population Growth Rate: **" + parseNumber((usr.pop_growth_modifier-1)*100) + "%**");
					economy_string.push("You have **" + usr.cities.city_array.length + "** cities. Type `" + bot_prefix + "city-list` to view all your cities.\nType `" + bot_prefix + "city <name>` to view a specific city.");
					
					economy_string.push("------------------ \n**Production Modifiers:**\n");
					var local_resource_modifiers = {};
					var building_cost_prefix = (usr.modifiers.building_cost > 1) ? "+" : "";
					
					for (var i = 0; i < config.materials.length; i++) local_resource_modifiers[config.materials[i]] = {
						count: 0,
						cities: []
					};
					for (var i = 0; i < usr.cities.city_array.length; i++) {
						var city_obj = getCity(usr.cities[usr.cities.city_array[i]].name);
						var local_element = local_resource_modifiers[city_obj[2].resource];
						var local_throughput = getCityRGOThroughput(city_obj[2].name)-(usr.modifiers.rgo_throughput-1);
						
						local_element.count++;
						local_element.cities.push(`${city_obj[2].name}` + (
						(!isNaN(city_obj[3].supply_limit)) ?
							` (**${(local_throughput >= 0) ? "+" : ""}${parseNumber(Math.ceil((local_throughput-1)*100))}%**)`
							: ``
						));
					} 
					
					((usr.modifiers.building_cost-1)*100 != 0) ?
						economy_string.push("<:building:716827579650408538> Building Cost Modifier: **" + building_cost_prefix + parseNumber(((usr.modifiers.building_cost-1)*100)) + "%**") :
						economy_string.push("<:building:716827579650408538> No building cost modifiers active.");
					
					for (var i = 0; i < config.materials.length; i++) {
						var processed_resource_name = config.materials[i].charAt(0).toUpperCase() + config.materials[i].slice(1);
						var resource_modifier_prefix = ((usr.modifiers.rgo_throughput-1) >= 0) ? "+" : "";
						
						if (local_resource_modifiers[config.materials[i]].count != 0) {
							economy_string.push(`${config.resource_icons[i]} Base **${resource_modifier_prefix + parseNumber(Math.ceil((usr.modifiers.rgo_throughput-1)*100))}%** ${processed_resource_name} Gain in **${local_resource_modifiers[config.materials[i]].count}** citie(s):`);
							economy_string.push(`- ${local_resource_modifiers[config.materials[i]].cities.join(", ")}.`);
						}
						
					}
					economy_string.push("------------------ \n**Resource Production (per turn):**\n");
					economy_string.push("Type `" + bot_prefix + "build list` in order to access a full list of buildings available for construction.");
					economy_string.push("Type `" + bot_prefix + "build [amount] <name> <city>` in order to construct buildings.");
					economy_string.push("");
					
					//Get production values per turn
					var local_production_array = {};
					for (var i = 0; i < config.materials.length; i++) {
						local_production_array[config.materials[i] + "_results"] = [];
						local_production_array[config.materials[i] + "_minimum"] = 0;
						local_production_array[config.materials[i] + "_maximum"] = 0;
					}
					
					var temp_usr_obj = JSON.parse(JSON.stringify(usr));
					var local_production = nextTurn(temp_usr_obj, true);
					
					for (var x = 0; x < config.materials.length; x++) {
						local_production_array[config.materials[x] + "_results"].push(local_production.inventory[config.materials[x]]-usr.inventory[config.materials[x]]);
					}
					for (var i = 0; i < config.materials.length; i++) {
						var total_length = local_production_array[config.materials[i] + "_results"].length;
						local_production_array[config.materials[i] + "_results"].sort(function(a, b) { return b-a });
						local_production_array[config.materials[i] + "_minimum"] = local_production_array[config.materials[i] + "_results"][0];
						local_production_array[config.materials[i] + "_maximum"] = local_production_array[config.materials[i] + "_results"][total_length-1];
					}
					
					var pop_knowledge_gain = 0;
						
					for (var i = 0; i < config.pop_array.length; i++) {
						if (config.pops[config.pop_array[i]].knowledge_per_100k != undefined) {
							pop_knowledge_gain = pop_knowledge_gain + Math.ceil(((usr[config.pop_array[i]]/100000)*config.pops[config.pop_array[i]].knowledge_per_100k));
						}
					}
							
					for (var i = 0; i < config.materials.length; i++) {
						var current_material = config.materials[i];
						
						if (current_material == "knowledge") {
							local_production_array[current_material + "_minimum"] = local_production_array[current_material + "_minimum"]*usr.modifiers.research_efficiency;
							local_production_array[current_material + "_maximum"] = local_production_array[current_material + "_maximum"]*usr.modifiers.research_efficiency;
						}
					}
					
					local_production_array["knowledge_minimum"] = local_production.knowledge_per_turn;
					local_production_array["knowledge_maximum"] = local_production.knowledge_per_turn;
					
					//Add resource production to string
					for (var i = 0; i < config.materials.length; i++) {
						var local_resource_name = config.materials[i].split("_").join(" ").replace(/(^\w{1})|(\s{1}\w{1})/g, match => match.toUpperCase());
						if (local_production_array[config.materials[i] + "_minimum"] == local_production_array[config.materials[i] + "_maximum"]) {
							economy_string.push("- **" + parseNumber(local_production_array[config.materials[i] + "_minimum"]) + "** " + local_resource_name + ".");
						} else if (local_production_array[config.materials[i] + "_maximum"] != local_production_array[config.materials[i] + "_minimum"]) {
							economy_string.push("- **" + parseNumber(local_production_array[config.materials[i] + "_minimum"]) + "** - **" + parseNumber(local_production_array[config.materials[i] + "_maximum"]) + "** " + local_resource_name + " per turn.");
						}
					}
					economy_string.push("");
					economy_string.push("For a complete list of current constructions, type `" + bot_prefix + "constructions`.");
					economy_string.push("For a complete list of resource production and buildings, type `" + bot_prefix + "industry`.");
					economy_string.push("To view your **current resources**, type `" + bot_prefix + "inventory`.");
					
					const embed_economy = new Discord.MessageEmbed()
						.setColor('#a98ac7')
						.setAuthor('Triumph & Tragedy:', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
						.setTitle('**Economy:\n------------------**')
						.setThumbnail(usr.flag)
						.setDescription(economy_string.join("\n"))
						.setTimestamp()
						.setFooter("Note that actual resource production is likely to vary if any one of the above categories is in the negative, and it may take a turn or two for a factory to begin producing material.\n\n" + 'To access this menu again, type ' + bot_prefix + 'economy.', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png');
					
					return embed_economy;
				} else {
					msg.channel.send("The user you have specified needs to have a country in order for this command to operate properly!");
				}
			}
			
			function printExports (arg0_user, arg1_msg) {
				var msg = arg1_msg;
				
				//Fetch export list
				var export_list = [];
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					if (usr.trade_array.length > 0) {
						for (var i = 0; i < usr.trade_array.length; i++) {
							if (usr.trade_array[i][1] != arg0_user) {
								var export_amount = usr.trade_array[i][0][0];
								var export_type = usr.trade_array[i][0][1];
								var importer_name = main.users[usr.trade_array[i][1]].name;
								var time_remaining = usr.trade_array[i][2];
									
								var export_icon = "";
									
								for (var x = 0; x < config.materials.length; x++) {
									if (config.materials[x] == export_type) {
										export_icon = config.resource_icons[x];
									}
								}
								
								if (export_type == "money") {
									export_icon = "<:money:716817688718213192>";
								}
									
								export_list.push("Exporting " + export_icon + " " + parseNumber(export_amount) + " " + export_type + " to **" + importer_name + "**. The shipment will arrive in **" + time_remaining + "** turn(s).");
							}
						}
					}
						
					var export_embeds = [];
					var local_export_string = [];
						
					if (export_list.length > 0) {
						for (var i = 0; i < export_list.length; i++) {
							local_export_string.push(export_list[i]);
							if (i != 0 || export_list.length == 1) {
								if (i % 10 == 0 || i == export_list.length-1) {
									const embed_exports = new Discord.MessageEmbed()
										.setColor('#a98ac7')
										.setAuthor('Triumph & Tragedy:', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
										.setTitle('**Exports (' + usr.name + '):\n------------------**')
										.setThumbnail('https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
										.setDescription(local_export_string.join("\n"))
										.setTimestamp()
										.setFooter('To access this menu again, type ' + bot_prefix + 'exports.', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png');
										
									export_embeds.push(embed_exports);
									local_export_string = [];
								}
							}
						}
					} else {
						const embed_exports = new Discord.MessageEmbed()
							.setColor('#a98ac7')
							.setAuthor('Triumph & Tragedy:', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
							.setTitle('**Exports (' + usr.name + '):\n------------------**')
							.setThumbnail('https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
							.setDescription("_You have no outgoing exports._")
							.setTimestamp()
							.setFooter('To access this menu again, type ' + bot_prefix + 'exports.', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png');
							
						export_embeds.push(embed_exports);
					}
						
					scrollMessage(msg, export_embeds, 0);
				} else {
					msg.channel.send("You must have a nation in order to be receiving exports!");
				}
			}
			
			function printImports (arg0_user, arg1_msg) {
				var msg = arg1_msg;
				var import_list = [];
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					for (var i = 0; i < main.user_array.length; i++) {
						if (main.users[main.user_array[i]].trade_array.length > 0 && main.user_array[i] != arg0_user) {
							for (var x = 0; x < main.users[main.user_array[i]].trade_array.length; x++) {
								var import_amount = main.users[main.user_array[i]].trade_array[x][0][0];
								var import_type = main.users[main.user_array[i]].trade_array[x][0][1];
								var exporter_name = main.users[main.user_array[i]].name;
								var time_remaining = main.users[main.user_array[i]].trade_array[x][2];
									
								var import_icon = "";
									
								//Get import icon
								for (var y = 0; y < config.materials.length; y++) {
									if (config.materials[y] == import_type) {
										import_icon = config.resource_icons[y];
									}
								}
								
								if (import_type == "money") {
									import_icon = "<:money:716817688718213192>";
								}
									
								//Check if user is exporting items to selected user
								if (main.users[main.user_array[i]].trade_array[x][1] == arg0_user) {
									//Add to string array
									import_list.push("Importing " + import_icon + " " + parseNumber(import_amount) + " " + import_type + " from " + "**" + exporter_name + "**.\nThe shipment will arrive in **" + time_remaining + "** turn(s).");
								}
							}
						}
					}
					
					var import_embeds = [];
					var local_import_string = [];
					
					if (import_list.length > 0) {
						for (var i = 0; i < import_list.length; i++) {
							local_import_string.push(import_list[i]);
							if (i != 0 || import_list.length == 1) {
								if (i % 10 == 0 || i == import_list.length-1) {
									const embed_imports = new Discord.MessageEmbed()
										.setColor('#a98ac7')
										.setAuthor('Triumph & Tragedy:', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
										.setTitle('**Imports (' + usr.name + '):\n------------------**')
										.setThumbnail('https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
										.setDescription(local_import_string.join("\n"))
										.setTimestamp()
										.setFooter('To access this menu again, type ' + bot_prefix + 'imports.', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png');
											
										import_embeds.push(embed_imports);
										local_import_string = [];
								}
							}
						}
					} else {
						const embed_imports = new Discord.MessageEmbed()
							.setColor('#a98ac7')
							.setAuthor('Triumph & Tragedy:', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
							.setTitle('**Imports (' + usr.name + '):\n------------------**')
							.setThumbnail('https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
							.setDescription("_You have no incoming imports._")
							.setTimestamp()
							.setFooter('To access this menu again, type ' + bot_prefix + 'imports.', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png');
								
							import_embeds.push(embed_imports);
					}
						
					scrollMessage(msg, import_embeds, 0);
				} else {
					msg.channel.send("You must have a nation in order to receive imports!");
				}
			}
			
			function printInterface (arg0_user, arg1_msg, arg2_position) {
				var user_id = arg0_user;
				var msg = arg1_msg;
				
				if (main.users[user_id]) {
					if (!main.users[user_id].eliminated) {
						var usr = user_id;
						var embed_array = [printStats(usr, msg), printBudget(usr, msg), printEconomy(usr, msg), printTechnology(usr, msg), printPolitics(usr, msg), printPopulation(usr, msg), printTrade(usr, msg), printDiplomacy(usr, msg), printColonisation(usr, msg), printMilitaryInterface(usr, msg)];
						
						//scrollMessage (arg0_msg, arg1_embeds, arg2_starting_page)
						
						if (arg2_position != undefined) {
							scrollMessage(msg, embed_array, arg2_position);
						} else {
							scrollMessage(msg, embed_array, 0);
						}
					} else {
						msg.channel.send("The user you have specified does not exist!");
					}
				} else {
					msg.channel.send("The user you have specified does not exist!");
				}
			}
			
			function printInv (arg0_user, arg1_username, arg2_msg) {
				var inv_string = [];
				var raw_materials_string = [];
				var processed_materials_string = [];
				var crafting_points_string = [];
				
				if (main.users[arg0_user] == undefined) {
					arg2_msg.channel.send("The person you are looking for has no inventory!");
				} else {
					var usr = main.users[arg0_user];
					inv_string.push("<:trade:716828677115084812> **Current Goods:**\n------------------ \n");
					inv_string.push("<:money:716817688718213192> **Money**: " + parseNumber(main.users[arg0_user].money));
					inv_string.push("");
					for (var i = 0; i < config.materials.length; i++) {
						if (main.users[arg0_user].inventory[config.materials[i]] != undefined) {
							if (config.materials[i] != "knowledge") {
								var is_raw_material = false;
								var is_processed_material = false;
								
								for (var x = 0; x < config.raw_resources.length; x++) {
									if (config.raw_resources[x] == config.materials[i]) {
										is_raw_material = true;
									}
								}
								for (var x = 0; x < config.processed_resources.length; x++) {
									if (config.processed_resources[x] == config.materials[i]) {
										is_processed_material = true;
									}
								}
								
								if (is_raw_material) {
									raw_materials_string.push(config.resource_icons[i] + " **" + config.materials[i] + "**: " + parseNumber(main.users[arg0_user].inventory[config.materials[i]]));
								} else if (is_processed_material) {
									processed_materials_string.push(config.resource_icons[i] + " **" + config.materials[i] + "**: " + parseNumber(main.users[arg0_user].inventory[config.materials[i]]));
								}
							}
						}
					}
					
					crafting_points_string.push("<:active_personnel:716820390474940426> Army CP: **" + usr.ground_units_cp + "**");
					crafting_points_string.push("<:artillery:716821195055431681> Artillery CP: **" + usr.ground_artillery_cp + "**");
					crafting_points_string.push("<:land_vehicles:716821195215077406> Armour CP: **" + usr.ground_vehicles_cp + "**");
					crafting_points_string.push("<:naval_units:716821195277729832> Naval CP: **" + usr.naval_units_cp + "**");
					crafting_points_string.push("<:aeroplanes:716821195407884358>Air CP: **" + usr.aeroplanes_cp + "**");
					
					const inventory_embed = new Discord.MessageEmbed()
						.setColor('#a98ac7')
						.setAuthor('Triumph & Tragedy:', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
						.setTitle('**Inventory:\n------------------**')
						.setThumbnail('https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
						.setDescription(inv_string.join("\n"))
						.addFields(
							{ name: "<:workers:732730754735276124> __**Raw Materials:**__\n---\n", value: raw_materials_string.join("\n"), inline: true },
							{ name: "<:government:716817688693047306> __**Processed Materials:**__\n---\n", value: processed_materials_string.join("\n"), inline: true },
							{ name: "<:building:716827579650408538> __**Crafting Points:**__\n---\n", value: crafting_points_string.join("\n"), inline: true }
						)
						.setTimestamp()
						.setFooter('To access this menu again, type ' + bot_prefix + 'inventory.', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png');
						
					arg2_msg.channel.send(inventory_embed);
				}
			}
			
			function printMilitary (arg0_user, arg1_username, arg2_msg) {
				var military_string = [];
				
				if (main.users[arg0_user] == undefined) {	
					arg2_msg.channel.send("The person you are looking for has no country!");
				} else {
					var usr = main.users[arg0_user];
					var ap = 0;
					var dp = 0;
					
					military_string.push("<:globe:716811246556545035> Country: **" + main.users[arg0_user].name + "**");
					military_string.push("Type `" + bot_prefix + "create-army <name>` to create a new army.");
					military_string.push("Type `" + bot_prefix + "disband` to disband units in your reserves.");
					military_string.push("------------------ \n<:manpower:716817688705499177> **Reserves:**");
					military_string.push("------------------ \n<:active_personnel:716820390474940426> **Ground Infantry:**\n");
					for (var i = 0; i < config.units.length; i++) {
						ap = ap + main.users[arg0_user].military[config.units[i]]*config.unit_stats[config.units[i]].ap;
						dp = dp + main.users[arg0_user].military[config.units[i]]*config.unit_stats[config.units[i]].dp;
					}
					var has_ground_units = false;
					for (var i = 0; i < config.ground_units.length; i++) {
						if (usr.military[config.ground_units[i]] > 0) {
							military_string.push("**" + config.ground_units[i] + "**: " + parseNumber(main.users[arg0_user].military[config.ground_units[i]]));
							has_ground_units = true;
						}
					}
					if (has_ground_units == false) {
						military_string.push("_No units in this category could be found._");
					}
					var has_artillery = false;
					military_string.push("------------------ \n<:artillery:716821195055431681> **Artillery:**\n");
					for (var i = 0; i < config.ground_artillery.length; i++) {
						if (usr.military[config.ground_artillery[i]] > 0) {
							military_string.push("**" + config.ground_artillery[i] + "**: " + parseNumber(main.users[arg0_user].military[config.ground_artillery[i]]));
							has_artillery = true;
						}
					}
					if (has_artillery == false) {
						military_string.push("_No units in this category could be found._");
					}
					var has_vehicles = false;
					military_string.push("------------------ \n<:land_vehicles:716821195215077406> **Land Vehicles:**\n");
					for (var i = 0; i < config.ground_vehicles.length; i++) {
						if (usr.military[config.ground_vehicles[i]] > 0) {
							military_string.push("**" + config.ground_vehicles[i] + "**: " + parseNumber(main.users[arg0_user].military[config.ground_vehicles[i]]));
							has_vehicles = true;
						}
					}
					if (has_vehicles == false) {
						military_string.push("_No units in this category could be found._");
					}
					var has_aeroplanes = false;
					military_string.push("------------------ \n<:aeroplanes:716821195407884358> **Aeroplanes:**\n");
					for (var i = 0; i < config.aeroplanes.length; i++) {
						if (usr.military[config.aeroplanes[i]] > 0) {
							military_string.push("**" + config.aeroplanes[i] + "**: " + parseNumber(main.users[arg0_user].military[config.aeroplanes[i]]));
							has_aeroplanes = true;
						}
					}
					if (has_aeroplanes == false) {
						military_string.push("_No units in this category could be found._");
					}
					var has_naval_units = false;
					military_string.push("------------------ \n<:naval_units:716821195277729832> **Naval Units:**\n");
					for (var i = 0; i < config.naval_units.length; i++) {
						if (usr.military[config.naval_units[i]] > 0) {
							military_string.push("**" + config.naval_units[i] + "**: " + parseNumber(main.users[arg0_user].military[config.naval_units[i]]));
							has_naval_units = true;
						}
					}
					if (has_naval_units == false) {
						military_string.push("_No units in this category could be found._");
					}
					var has_colonists = false;
					military_string.push("------------------ \n<:colonisation:716821194891853826> **Colonists:**\n");
					for (var i = 0; i < config.colonists.length; i++) {
						if (usr.military[config.colonists[i]] > 0) {
							military_string.push("**" + config.colonists[i] + "**: " + parseNumber(main.users[arg0_user].military[config.colonists[i]]));
							has_colonists = true;
						}
					}
					if (has_colonists == false) {
						military_string.push("_No units in this category could be found._");
					}
					military_string.push("------------------ \n<:money:716817688718213192> **Upkeep:**\n");
					var total_soldiers = usr.used_soldiers + usr.mobilised_manpower[0];
					military_string.push("**£" + new Intl.NumberFormat('de', {style: 'decimal'}).format(Math.ceil((total_soldiers/100)*usr.modifiers.army_upkeep)) + "** will be spent on the military each turn.");
					military_string.push("");
					military_string.push("Total AP: `" + parseNumber(ap) + "` ¦ Total DP: `" + parseNumber(dp) + "`.");
					
					const military_embed = new Discord.MessageEmbed()
						.setColor('#a98ac7')
						.setAuthor('Triumph & Tragedy:', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
						.setTitle('**Reserves:\n------------------**')
						.setThumbnail('https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
						.setDescription(military_string.join("\n"))
						.setTimestamp()
						.setFooter('To access this menu again, type ' + bot_prefix + 'reserves.', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png');
					
					arg2_msg.channel.send(military_embed);
				}
			}
			
			function printMilitaryHQ (arg0_user, arg1_msg) {
				//Convert from parameters
				var user_id = arg0_user;
				var usr = (main.users[arg0_user]) ? main.users[arg0_user] : undefined;
				var msg = arg1_msg;
				
				//Check to see whether user is defined or not
				if (usr != undefined) {
					logicCheck(user_id);
					
					var total_active_personnel = JSON.parse(usr.soldiers);
					var occupied_provinces = 0;
					
					var total_reserves_ap = 0;
					var total_reserves_dp = 0;
					var total_ap = 0;
					var total_dp = 0;
					
					//main.users.global.occupations.push([army_obj.province.toString(), is_city, hostile_owner, usr.id]);
					
					//Get ocupations
					for (var i = 0; i < main.users.global.occupations.length; i++) {
						var local_occupied_province = main.users.global.occupations[i];
						
						if (local_occupied_province[2] == usr.id) {
							occupied_provinces++;
						}
					}
					
					//Work way through unit list
					for (var i = 0; i < config.units.length; i++) {
						var local_category = "";
						var total_units = 0;
						var total_reserve_units = usr.military[config.units[i]];
						
						for (var x = 0; x < config.unit_categories.length; x++) {
							if (config[config.unit_categories[x]].includes(config.units[i])) {
								local_category = config.unit_categories[x];
							}
						}
						
						//Get total number of these troops across all armies
						for (var x = 0; x < usr.armies.army_array.length; x++) {
							var local_army = usr.armies[usr.armies.army_array[x]];
							
							total_units += local_army[config.units[i]];
						}
						
						//Apply to total_reserves_ap, total_reserves_dp, total_ap, and total_dp
						total_reserves_ap += Math.ceil(total_reserve_units*config.unit_stats[config.units[i]].ap*returnSafeNumber(usr[local_category + "_ap"], 1));
						total_reserves_dp += Math.ceil(total_reserve_units*config.unit_stats[config.units[i]].dp*returnSafeNumber(usr[local_category + "_dp"], 1));
						
						total_ap += Math.ceil(total_units*config.unit_stats[config.units[i]].ap*returnSafeNumber(usr[local_category + "_ap"], 1));
						total_dp += Math.ceil(total_units*config.unit_stats[config.units[i]].dp*returnSafeNumber(usr[local_category + "_dp"], 1));
					}
					
					//Compile army report - how many total armies are currently occupied, how many are moving, blockading, stationed, etc.
					var total_armies = 0;
					var total_navies = 0;
					var total_air_wings = 0;
						
					var total_empty_armies = 0;
						
					var army_orders = {
						stationed: 0,
						moving: 0,
						blockading: 0,
						in_harbour: 0,
						
						in_battle: 0,
						in_blockade_cooldown: 0,
						in_submarine_cooldown: 0
					};
					
					//Begin compiling a proper list
					for (var i = 0; i < usr.armies.army_array.length; i++) {
						var local_army = usr.armies[usr.armies.army_array[i]];
						var empty_army = true;
						
						//Increment status if found to have a valid order
						try {
							army_orders[local_army.order]++;
						} catch {}
						
						army_orders.in_battle = (local_army.in_battle) ? army_orders.in_battle += 1 : army_orders.in_battle;
						army_orders.in_blockade_cooldown = (local_army.blockade_recovery_turns > 0) ? army_orders.in_blockade_cooldown += 1 : army_orders.in_blockade_cooldown;
						army_orders.in_submarine_cooldown = (local_army.submarine_cooldown) ? army_orders.in_submarine_cooldown += 1 : army_orders.in_submarine_cooldown;
						
						for (var x = 0; x < config.units.length; x++) {
							empty_army = (local_army[config.units[x]] > 0) ? false : empty_army;
						}
						
						total_empty_armies = (empty_army) ? total_empty_armies += 1 : total_empty_armies;
						total_active_personnel -= local_army.army_size;
						
						if (local_army.type == "army") {
							total_armies++;
						} else if (local_army.type == "navy") {
							total_navies++;
						} else if (local_army.type == "air force") {
							total_air_wings++;
						}
					}
					
					//Description - involved wars and belligerent parties, war exhaustion and infamy, as well as allies that can be called in. Total number of reserves and active personnel, as well as any potentially occupied territories
					var military_hq_description = [];
					if (usr.at_war.length > 0) {
						var all_wars = Object.keys(main.users.global.wars);
						var defending_wars = 0;
						var attacking_wars = 0;
						
						for (var i = 0; i < all_wars.length; i++) {
							var local_war = main.users.global.wars[all_wars[i]];
							
							defending_wars = (local_war.defenders.includes(usr.id)) ? defending_wars + 1 : defending_wars;
							attacking_wars = (local_war.attackers.includes(usr.id)) ? attacking_wars + 1 : attacking_wars;
						}
						
						military_hq_description.push("<:cb:716828676855169107> We are currently involved in a **state of war** with **" + parseNumber(usr.at_war.length) + "** countries, including " + parseArray(usr.at_war) + ".");
						military_hq_description.push("This entails a grand total of **" + parseNumber(defending_wars+attacking_wars) + "** wars, **" + parseNumber(defending_wars) + "** defensive, and **" + parseNumber(attacking_wars) + "** offensive.");
						military_hq_description.push("");
					}
					
					//Print War Exhaustion
					var war_exhaustion_string = "";
					if (usr.at_war.length == 0 && usr.blockaded == false) {
						var war_exhaustion_prefix = "";
						var war_exhaustion_rate = config.war_exhaustion_tickdown_rate;
						if (usr.mobilised_manpower[1] != "") {
							war_exhaustion_rate = war_exhaustion_rate - config.war_exhaustion_mobilisation_rate;
						}
						
						if (config.war_exhaustion_tickdown_rate < 0) {
							war_exhaustion_prefix = "+";
						} else {
							war_exhaustion_prefix = "-";
						}
						
						war_exhaustion_string = "(" + war_exhaustion_prefix + Math.abs(war_exhaustion_rate) + "% per turn)";
					}
					
					if (usr.modifiers.war_exhastion == 100 && usr.at_war.length > 0) {
						military_hq_description.push("<:retreat:798368936671576124> We have hit **100%** War Exhaustion, and our enemies may now force us to come to an unconditional surrender!");
					} else {
						military_hq_description.push("<:infamy:716817688453709905> War Exhaustion: **" + (Math.round(usr.modifiers.war_exhaustion*100)/100) + "%** " + war_exhaustion_string);
					}
					
					if (user_id.blockaded_war_exhaustion > 0) {
						military_hq_description.push("- +" + parseNumber(user_id.blockaded_war_exhaustion) + "% war exhaustion from the ongoing blockade.");
					}
					
					//Print Infamy
					var infamy_suffix = (usr.modifiers.infamy_loss < 0) ? "" : "+";
					military_hq_description.push("<:infamy:716817688453709905> Infamy: **" + usr.infamy + "** (" + infamy_suffix + (Math.round(usr.modifiers.infamy_loss*100)/100) + " per turn)");
					
					//3 inline fields; total number of armies/navies/air wings and AP/DP - military and civilian casualties over the last 10 turns - list of options
					//1st Field - Total number of Armies/Navies/Air Wings, as well as AP/DP
					var military_status_array = [];
					
					if (usr.armies.army_array.length > 0) {
						military_status_array.push("We have **" + parseNumber(usr.armies.army_array.length) + "** military units currently in the field. Of these:");
						military_status_array.push("- **" + parseNumber(total_armies) + "** are land armies,");
						military_status_array.push("- **" + parseNumber(total_navies) + "** are navies,");
						military_status_array.push("- and **" + parseNumber(total_air_wings) + "** are air wings.");
						
						if (total_empty_armies > 0) {
							military_status_array.push("");
							military_status_array.push("The rest, some **" + parseNumber(total_empty_armies) + "** armies, are currently sitting empty.");
						}
						
						military_status_array.push("");
						military_status_array.push("We currently have `" + parseNumber(total_ap) + "` AP and `" + parseNumber(total_dp) + "` DP deployed in the field.");
						military_status_array.push("The rest, some `" + parseNumber(total_reserves_ap) + "` AP and `" + parseNumber(total_reserves_dp) + "` are currently in our reserves.");
						military_status_array.push("---");
						//usr.mobilised_manpower = [manpower_mobilised, mobilised_unit, mobilisation_speed, 0, mobilisation_speed];
						var total_troop_count_status = (usr.mobilised_manpower[0] > 0) ? "<:soldiers:732730754592669702> **" + parseNumber(usr.used_soldiers) + "** soldiers, and <:workers:732730754735276124> **" + parseNumber(usr.mobilised_manpower[0]) + "** mobilised workers." : "<:soldiers:732730754592669702> **" + parseNumber(usr.used_soldiers) + "** soldiers.";
						
						military_status_array.push("This makes for a combined grand total of `" + parseNumber(total_ap+total_reserves_ap) + "` AP and `" + parseNumber(total_dp+total_reserves_dp) + "` DP; for a total army strength of " + total_troop_count_status);
					} else {
						military_status_array.push("_We currently have no armies in active service._");
					}
					
					military_status_array.push("");
					military_status_array.push("Type `" + bot_prefix + "army-list` to view a complete list of all your armies.");
					
					//2nd Field - Casualties Counter
					var military_civilian_casualties = [],
						total_civilian_casualties = 0,
						total_military_casualites = 0;
					
					military_civilian_casualties.push("Casualties measured in total taken by attrition, combat and other causes per turn.");
					military_civilian_casualties.push("");
					
					for (var i = 0; i < usr.recent_military_casualties.length; i++) {
						total_military_casualites += usr.recent_military_casualties[i];
					}
					for (var i = 0; i < usr.recent_civilian_casualties.length; i++) {
						total_civilian_casualties += usr.recent_civilian_casualties[i];
					}
					
					military_civilian_casualties.push("**Military:**");
					military_civilian_casualties.push("---");
					
					if (total_military_casualites > 0) {
						for (var i = 0; i < usr.recent_military_casualties.length; i++) {
							military_civilian_casualties.push(parseNumber(usr.recent_military_casualties[i]));
						}
						military_civilian_casualties.push("<:death:798009877469462530> Total Military Casualties: **" + parseNumber(total_military_casualites) + "**");
					} else {
						military_civilian_casualties.push("_We have incurred no military casualties as of late._");
					}
					
					military_civilian_casualties.push("");
					
					military_civilian_casualties.push("**Civilian:**");
					military_civilian_casualties.push("---");
					
					if (total_civilian_casualties > 0) {
						for (var i = 0; i < usr.recent_civilian_casualties.length; i++) {
							military_civilian_casualties.push(parseNumber(usr.recent_civilian_casualties[i]));
						}
						military_civilian_casualties.push("<:death:798009877469462530> Total Civilian Casualties: **" + parseNumber(total_civilian_casualties) + "**");
					} else {
						military_civilian_casualties.push("_We have incurred no civilian casualties as of late._");
					}
					
					military_civilian_casualties.push("");	
					
					//3rd Field - List of options
					var options_array = [];
					var reference_string = {
						"always": "Always",
						"if possible": "If Possible",
						"never": "Never",
						
						true: "Yes",
						false: "No"
					};
					
					options_array.push("We currently have our policy on **Attrition Avoidance** set to **" + reference_string[usr.avoid_attrition] + "**.");
					if (usr.avoid_attrition == "always") {
						options_array.push("Our troops will always avoid attrition, and will refuse to move if ordered into a province that will result in deaths from attrition.");
					} else if (usr.avoid_attrition == "if possible") {
						options_array.push("Our troops will attempt to avoid attrition whenever possible, but will move into zones of attrition if strictly necessary.");
					} else {
						options_array.push("Our troops will always take the shortest route to a target province, regardless of attrition.");
					}
					options_array.push("- Type `" + bot_prefix + "avoid-attrition` in order to change this policy.");
					options_array.push("");
					options_array.push("We currently have our policy on **Territorial Violation** set to **" + reference_string[usr.avoid_territorial_violation] + "**.");
					if (usr.avoid_territorial_violation == "always") {
						options_array.push("Our troops will always avoid violating the sovereign territory of other countries, and will automatically refuse to move if ordered to pass through one.");
					} else if (usr.avoid_territorial_violation == "if possible") {
						options_array.push("Our troops will avoid violating the territory of other countries whenever possible, but may pass through them unprovoked if no alternative routes can be found.");
					} else {
						options_array.push("Our soldiers will march straight from point A to point B, regardless of any country standing in their paths!");
					}
					options_array.push("- Type `" + bot_prefix + "avoid-territorial-violation` in order to change this policy.");
					options_array.push("");
					options_array.push("We currently have our policy on **Ignore Orders When Carpet Sieging** set to **" + reference_string[usr.ignore_orders_when_carpet_sieging] + "**.");
					if (usr.ignore_orders_when_carpet_sieging == "yes") {
						options_array.push("Orders given out by you to carpet siege will always override existing orders of armies if no available armies can be found.");
					} else {
						options_array.push("Only armies without orders or currently stationed will be requistioned for carpet sieging when ordered to.");
					}
					options_array.push("- Type `" + bot_prefix + "ignore-orders-when-carpet-sieging` in order to change this policy.");
					
					//1 non-inline field; list of QOL commands
					var command_list_array = [];
					var global_orders_array = [];
					var army_creation_array = [];
					var army_management_array = [];
					
					command_list_array.push("Military organisation commands act as power commands allowing you to quickly manage, equip, and deploy your armies, thereby reducing the need for micromanagement, and giving additional tools to players.");
					command_list_array.push("");
					command_list_array.push("---");
					
					global_orders_array.push("- `" + bot_prefix + "carpet-siege` - Order your troops to siege down an entire nation.");
					global_orders_array.push("- `" + bot_prefix + "garrison-cities` - Guard all the cities within your country.");
					global_orders_array.push("- `" + bot_prefix + "garrison-provinces` - Guard all the provinces within your country.");
					global_orders_array.push("- `" + bot_prefix + "delete-all-armies` - Delete all your armies and return all troops and materiel to your reserves.");
					global_orders_array.push("- `" + bot_prefix + "move-all` - Moves all your armies into a single province.");
					
					army_creation_array.push("- `" + bot_prefix + "create-armies` - Create multiple armies.");
					army_creation_array.push("- `" + bot_prefix + "delete-armies` - Delete multiple armies.");
					army_creation_array.push("- `" + bot_prefix + "split-armies` - Splits off empty armies from an existing one.");
					army_creation_array.push("- `" + bot_prefix + "merge-armies` - Power merges several armies into an existing one.");
					
					army_management_array.push("- `" + bot_prefix + "mass-deploy` - For deploying troops to armies en masse.");
					army_management_array.push("- `" + bot_prefix + "mass-relieve` - Relieves units from several armies, placing them back in reserves.");
					army_management_array.push("- `" + bot_prefix + "move-armies` - Moves several armies to a single province.");
					
					//Create embed object
					const embed_military_hq = new Discord.MessageEmbed()
						.setColor('#a98ac7')
						.setAuthor('Triumph & Tragedy:', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
						.setTitle('**Military HQ:\n------------------**')
						.setThumbnail(usr.flag)
						.setDescription(military_hq_description.join("\n"))
						.addFields(
							{ name: "**Military Statistics:**", value: military_status_array.join("\n"), inline: true },
							{ name: "**Recent Casualties:**", value: military_civilian_casualties.join("\n"), inline: true },
							{ name: "**Military Options:**", value: options_array.join("\n") },
							{ name: "**Military Organisation Commands:**", value: command_list_array.join("\n") },
							{ name: "**Global Orders:**", value: global_orders_array.join("\n") },
							{ name: "**Army Creation:**", value: army_creation_array.join("\n") },
							{ name: "**Army Management:**", value: army_management_array.join("\n") }
						)
						.setTimestamp()
						.setFooter('To access this menu again, type ' + bot_prefix + 'military-hq.', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png');
						
					msg.channel.send({ embed: embed_military_hq });
				} else {
					msg.channel.send("You must have a nation first before being able to consult with your military headquarters!");
				}
			}
			
			function printMilitaryInterface (arg0_user, arg1_msg, arg2_confidential) {
				var msg = arg1_msg;
				var is_confidential = arg2_confidential;
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					var military_interface_string = [];
					var war_exhaustion_string = "";
					
					military_interface_string.push("**Wartime Status:**\n");
					if (usr.at_war.length > 0) {
						military_interface_string.push("We are engaged in a state of **war** with " + usr.at_war.join(", ") + ".");
					} else {
						military_interface_string.push("_We are currently at peace._");
					}
					
					if (usr.at_war.length == 0 && usr.blockaded == false) {
						var war_exhaustion_prefix = "";
						var war_exhaustion_rate = config.war_exhaustion_tickdown_rate;
						if (usr.mobilised_manpower[1] != "") {
							war_exhaustion_rate = war_exhaustion_rate - config.war_exhaustion_mobilisation_rate;
						}
						
						if (config.war_exhaustion_tickdown_rate < 0) {
							war_exhaustion_prefix = "+";
						} else {
							war_exhaustion_prefix = "-";
						}
						
						war_exhaustion_string = "(" + war_exhaustion_prefix + Math.abs(war_exhaustion_rate) + "% per turn)";
					}
					
					military_interface_string.push("<:infamy:716817688453709905> War Exhaustion: **" + (Math.round(usr.modifiers.war_exhaustion*100)/100) + "%** " + war_exhaustion_string);
					if (user_id.blockaded_war_exhaustion > 0) {
						military_interface_string.push("- +" + parseNumber(user_id.blockaded_war_exhaustion) + "% war exhaustion from the ongoing blockade.");
					}
					military_interface_string.push("");
					military_interface_string.push("<:active_personnel:716820390474940426> Army CP: **" + usr.ground_units_cp + "**");
					military_interface_string.push("<:artillery:716821195055431681> Artillery CP: **" + usr.ground_artillery_cp + "**");
					military_interface_string.push("<:land_vehicles:716821195215077406> Armour CP: **" + usr.ground_vehicles_cp + "**");
					military_interface_string.push("<:naval_units:716821195277729832> Naval CP: **" + usr.naval_units_cp + "**");
					military_interface_string.push("<:aeroplanes:716821195407884358> Air CP: **" + usr.aeroplanes_cp + "**");
					military_interface_string.push("");
					military_interface_string.push("------------------\n**Reserves:** For a full overview, type `" + bot_prefix + "reserves`.\n");
					military_interface_string.push("To begin training units, type `" + bot_prefix + "craft list`.");
					
					var reserves_ap = 0;
					var reserves_dp = 0;
					
					for (var i = 0; i < config.units.length; i++) {
						reserves_ap = reserves_ap + config.unit_stats[config.units[i]].ap*usr.military[config.units[i]];
						reserves_dp = reserves_dp + config.unit_stats[config.units[i]].dp*usr.military[config.units[i]];
					}
					
					military_interface_string.push("Reserves AP: `" + parseNumber(reserves_ap) + "` ¦ DP: `" + parseNumber(reserves_dp) + "`.");
					military_interface_string.push("");
					military_interface_string.push("To access more military options and commands, type `" + bot_prefix + "military-headquarters`.");
					military_interface_string.push("------------------\n**Army List:** `" + bot_prefix + "army-list`");
					
					var armies_string = [];
					var current_character_count = 0;
					for (var i = 0; i < usr.armies.army_array.length; i++) {
						if (current_character_count < 2600) {
							if (usr.armies[usr.armies.army_array[i]].name != "deleted_army") {
								var icon = "";
								if (usr.armies[usr.armies.army_array[i]].type == "army") {
									icon = "<:active_personnel:716820390474940426> ";
								} else if (usr.armies[usr.armies.army_array[i]].type == "navy") {
									icon = "<:naval_units:716821195277729832> ";
								} else if (usr.armies[usr.armies.army_array[i]].type == "air force") {
									con = "<:aeroplanes:716821195407884358> ";
								}
							}
							var local_push_line = " - " + icon + "**" + usr.armies[usr.armies.army_array[i]].name + "** (" + usr.armies[usr.armies.army_array[i]].state + ", Province #**" + usr.armies[usr.armies.army_array[i]].province + "**).";
							current_character_count = current_character_count + local_push_line.length;
							armies_string.push(local_push_line);
						}
					}
					
					if (armies_string.length > 0) {
						if (armies_string.length < usr.armies.army_array.length) {
							armies_string.push(" - +" + (usr.armies.army_array.length-armies_string.length) + " more ...");
						}
						military_interface_string.push(armies_string.join("\n"));
					} else {
						military_interface_string.push("_You currently have no armies in active service._");
					}
					military_interface_string.push("------------------\n**Mobilisation:**\n");
					
					if (usr.enable_mobilisation) {
						if (usr.mobilised_manpower[0] == 0) {
							if (main.roundCount-usr.last_mobilised > config.mobilisation_cooldown) {
								var manpower_mobilised = Math.ceil((usr.workers-usr.used_workers)*config.base_mobilisation_size*usr.modifiers.mobilisation_size);
								
								if (manpower_mobilised > 0) {
									military_interface_string.push("You can mobilise! Type `" + bot_prefix + "mobilise` in order to call upon your people to take up arms.");
									military_interface_string.push("**" + parseNumber(manpower_mobilised) + "** " + usr.mobilise_unit + " will be placed in your reserves.");
								} else {
									military_interface_string.push("Due to critical manpower shortages on the civilian front, mobilisation isn't available. Try freeing up more workers first!");
								}
							} else {
								military_interface_string.push("Your people have demobilised too recently to be willing to be called up for war again. Wait for **" + parseNumber((config.mobilisation_cooldown-(main.roundCount-usr.last_mobilised))+1) + "** more turn(s).");
							}
						} else {
							if (usr.mobilised_manpower[2] > 0) {
								military_interface_string.push("You are currently mobilising, and your advisors estimate that mobilisation will be complete within **" + parseNumber(usr.mobilised_manpower[2]) + "** turn(s). So far, **" + parseNumber(usr.mobilised_manpower[3]) + "** men out of **" + parseNumber(usr.mobilised_manpower[0]) + "** available reservists have been mobilised.");
								military_interface_string.push("");
								military_interface_string.push("Type `" + bot_prefix + "demobilise` in order to lay down your arms.");
							} else {
								military_interface_string.push("You are currently mobilised. Type `" + bot_prefix + "demobilise` in order to lay down your arms.");
							}
						}
					} else {
						military_interface_string.push("Military mobilisation is currently locked, as your people haven't heard of the concept yet.");
					}
					
					const embed_military = new Discord.MessageEmbed()
						.setColor('#a98ac7')
						.setAuthor('Triumph & Tragedy:', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
						.setTitle('**Military:\n------------------**')
						.setThumbnail(usr.flag)
						.setDescription(military_interface_string.join("\n"))
						.setTimestamp()
						.setFooter('To access this menu again, type ' + bot_prefix + 'military.', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png');
						
					return embed_military;
				} else {
					msg.channel.send("You don't even have a nation!");
				}
			}
			
			function printLedger (arg0_user, arg1_msg) {
				var msg = arg1_msg;
				var ledger_array = [];
				
				if (main.users[arg0_user] != undefined) {
					var user_id = main.users[arg0_user];
					var ledger_embeds = [];
					
					for (var i = 0; i < main.user_array.length; i++) {
						ledger_array.push("**" + main.users[main.user_array[i]].name + "**: (ID: " + main.user_array[i] + ")");
						//ledger_array.push(" - **Technological Level:** " + main.users[main.user_array[i]].technology_level);
						ledger_array.push(" - **Government:** " + main.users[main.user_array[i]].government);
						ledger_array.push(" - **Population:** " + parseNumber(main.users[main.user_array[i]].population));
						ledger_array.push(" - **Army Size:** " + parseNumber(main.users[main.user_array[i]].used_soldiers));
						ledger_array.push(" - **Cities:** (" + main.users[main.user_array[i]].city_count + "/" + main.users[main.user_array[i]].city_cap + ")");
						ledger_array.push(" - **Provinces:** " + main.users[main.user_array[i]].provinces);
					}
					
					if (ledger_array.length > 42) {
						var temp_ledger_string = [];
						for (var i = 0; i < ledger_array.length; i++) {
							if (temp_ledger_string.length < 42) {
								temp_ledger_string.push(ledger_array[i]);
							} else {
								const ledger_embed = new Discord.MessageEmbed()
									.setColor('#a98ac7')
									.setAuthor('Triumph & Tragedy:', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
									.setTitle('**World Ledger:\n------------------**')
									.setThumbnail('https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
									.setDescription(temp_ledger_string.join("\n"))
									.setTimestamp()
									.setFooter('To access this menu again, type ' + bot_prefix + 'ledger.', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png');
								ledger_embeds.push(ledger_embed);
								temp_ledger_string = [];
								temp_ledger_string.push(ledger_array[i]);
							}
										
							if (ledger_array.length > 42) {
								if (i == ledger_array.length-1) {
									const ledger_embed = new Discord.MessageEmbed()
										.setColor('#a98ac7')
										.setAuthor('Triumph & Tragedy:', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
										.setTitle('**World Ledger:\n------------------**')
										.setThumbnail('https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
										.setDescription(temp_ledger_string.join("\n"))
										.setTimestamp()
										.setFooter('To access this menu again, type ' + bot_prefix + 'ledger.', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png');
									ledger_embeds.push(ledger_embed);
									temp_ledger_string = [];
								}
							}
						}
					} else {
						const ledger_embed = new Discord.MessageEmbed()
							.setColor('#a98ac7')
							.setAuthor('Triumph & Tragedy:', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
							.setTitle('**World Ledger:\n------------------**')
							.setThumbnail('https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
							.setDescription(ledger_array.join("\n"))
							.setTimestamp()
							.setFooter('To access this menu again, type ' + bot_prefix + 'ledger.', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png');
						ledger_embeds.push(ledger_embed);
					}
					
					scrollMessage(msg, ledger_embeds, 0);
				} else {
					arg1_msg.channel.send("You don't have a nation yet!");
				}
			}
			
			function printStats (arg0_user, arg2_msg) {
				var stats_string = [];
				
				if (main.users[arg0_user] == undefined) {
					arg2_msg.channel.send("The person you are looking for has no country!");
				} else {
					if (main.users[arg0_user].eliminated) {
						arg2_msg.channel.send("The person you are looking for has no country!");
					} else {
						var usr = main.users[arg0_user];
						
						for (var i = 0; i < main.user_array.length; i++) {
							logicCheck(main.user_array[i]);
						}
						var percentage_manpower = Math.round((usr.manpower_percentage+(usr.modifiers.national_manpower-1))*100);
						
						var minimum = 0;
						var maximum = 0;
					
						minimum = minimum + config.starting_actions;
						maximum = maximum + config.starting_actions;
						
						//Remove duplicates
						main.users[arg0_user].available_governments = unique(main.users[arg0_user].available_governments);
						main.users[arg0_user].available_buildings = unique(main.users[arg0_user].available_buildings);
						main.users[arg0_user].available_units = unique(main.users[arg0_user].available_units);
						
						for (var i = 0; i < main.users[arg0_user].cities.city_array.length; i++) {
							var local_city = usr.cities[usr.cities.city_array[i]];
							for (var x = 0; x < config.buildings.length; x++) {
								if (config.building_stats[config.buildings[x]].produces != undefined) {
									for (var y = 0; y < config.building_stats[config.buildings[x]].produces.length; y++) {
										if (config.building_stats[config.buildings[x]].produces[y][1] == "actions") {
											if (Array.isArray(config.building_stats[config.buildings[x]].produces[y][0])) {
												minimum = minimum + config.building_stats[config.buildings[x]].produces[y][0][0]*local_city.buildings[config.buildings[x]];
												maximum = maximum + config.building_stats[config.buildings[x]].produces[y][0][1]*local_city.buildings[config.buildings[x]];
											} else {
												minimum = minimum + config.building_stats[config.buildings[x]].produces[y][0]*local_city.buildings[config.buildings[x]];
												maximum = maximum + config.building_stats[config.buildings[x]].produces[y][0]*local_city.buildings[config.buildings[x]];
											}
										}
									}
								}
							}
						}
						//user_id.money = user_id.money + Math.ceil((user_id.actions*config.money_per_action)*user_id.tax_rate*user_id.modifiers.tax_efficiency);
						
						var civ_actions = 0;
						if (config.governments[usr.government].civilian_actions != undefined) {
							civ_actions = Math.ceil(usr.actions*config.governments[usr.government].civilian_actions);
						} else {
							civ_actions = Math.ceil(usr.actions*usr.civilian_actions_percentage);
						}
						var minimum_income = Math.ceil((((usr.actions-civ_actions)+minimum)*config.money_per_action)*usr.tax_rate*usr.modifiers.tax_efficiency);
						var maximum_income = Math.ceil((((usr.actions-civ_actions)+maximum)*config.money_per_action)*usr.tax_rate*usr.modifiers.tax_efficiency);
						
						//Calculate Building Upkeep
						for (var i = 0; i < usr.cities.city_array.length; i++) {
							var local_city = usr.cities[usr.cities.city_array[i]];
							for (var x = 0; x < config.buildings.length; x++) {
								if (config.building_stats[config.buildings[x]].cost_per_turn != undefined) {
									for (var y = 0; y < config.building_stats[config.buildings[x]].cost_per_turn.length; y++) {
										if (config.building_stats[config.buildings[x]].cost_per_turn[y][1] == "money") {
											minimum_income = minimum_income - (config.building_stats[config.buildings[x]].cost_per_turn[y][0]*local_city.buildings[config.buildings[x]]);
											maximum_income = maximum_income - (config.building_stats[config.buildings[x]].cost_per_turn[y][0]*local_city.buildings[config.buildings[x]]);
										}
									}
								}
							}
						}
						
						//Calculate Army Upkeep
						var total_soldiers = usr.used_soldiers + usr.mobilised_manpower[0];
						minimum_income = minimum_income - Math.ceil((total_soldiers/100)*usr.modifiers.army_upkeep);
						maximum_income = maximum_income - Math.ceil((total_soldiers/100)*usr.modifiers.army_upkeep);
						
						stats_string.push("<:globe:716811246556545035> Country: **" + usr.name + "**");
						stats_string.push("<@" + usr.id + "> ¦ _" + usr.motto + "_");
						stats_string.push("");
						var prestige_prefix = "";
						if (usr.modifiers.prestige_gain >= 0) {
							prestige_prefix = "+";
						}
						stats_string.push("<:prestige:762428452636721202> Prestige: **" + parseNumber(usr.prestige) + "** (+" + usr.modifiers.prestige_gain + " per turn)");
						stats_string.push("<:provinces:716809229603700737> Provinces: **" + parseNumber(usr.provinces) + "**");
						stats_string.push("");
						stats_string.push("Type `" + bot_prefix + "customisation` to view nation customisation options.");
						var all_national_spirits = Object.keys(usr.national_spirits);
						
						if (all_national_spirits.length > 0) {
							stats_string.push("");
							stats_string.push("You currently have **" + parseNumber(all_national_spirits.length) + "** National Modifier(s) active. Type `" + bot_prefix + "view-national-modifiers` to view them.");
						}
						stats_string.push("------------------ \n**Population:**\n");
						
						//Get city list
						var name_array = [];
						var name_string = "";
						var ending_string = "";
						var cities = [];
						for (var i = 0; i < usr.cities.city_array.length; i++) {
							var local_city = usr.cities[usr.cities.city_array[i]];
							cities.push([local_city.name, local_city.population, local_city.type]);
						}
						
						//Sort cities by population
						cities.sort(function (a, b) {
							return b[1] - a[1];
						});
						
						var capital_included = false;
						for (var i = 0; i < cities.length; i++) {
							if (i < 15) {
								if (cities[i][2] == "capital") {
									name_array.push("**" + cities[i][0] + "**");
									capital_included = true;
								} else {
									name_array.push(cities[i][0]);
								}
							}
						}
						//Make sure capital is always included, even if it has to be stuck onto the end
						if (!capital_included) {
							for (var i = 0; i < cities.length; i++) {
								if (cities[i][2] == "capital") {
									name_array.push("**" + cities[i][0] + "**");
								}
							}
						}
						
						if (name_array.length > 2) {
							name_array[name_array.length-1] = "and " + name_array[name_array.length-1];
							name_string = name_array.join(", ");
						} else if (name_array.length == 2) {
							name_array[name_array.length-1] = "and " + name_array[name_array.length-1];
							name_string = name_array.join(" ");
						} else if (name_array.length == 1) {
							name_string = name_array[0];
						}
						
						if (usr.cities.city_array.length > name_array.length) {
							ending_string = ", (+" + (usr.cities.city_array.length-name_array.length) + " more)";
						}
						stats_string.push("<:development:716811992421367869> Cities: (**" + usr.city_count + "**/**" + main.users[arg0_user].city_cap + "**): " + name_string + ending_string);
						stats_string.push("<:population:716817688810356826> Population: **" + parseNumber(usr.population) + "** (Requires <:food:716797746715033602> **" + Math.ceil(usr.population/1000000) + "** food per turn)");
						stats_string.push("<:workers:732730754735276124> Workers: (**" + parseNumber(Math.ceil(usr.used_workers)) + "**/**" + parseNumber(usr.workers) + "**) ");
						stats_string.push("<:soldiers:732730754592669702> Soldiers: (**" + parseNumber(usr.used_soldiers) + "**/**" + parseNumber(usr.soldiers*usr.manpower_percentage*usr.modifiers.national_manpower) + "**) ¦ (**" + percentage_manpower + "%** Recruitable Population)");
						stats_string.push("------------------ \n**Economy:**\n");
						stats_string.push("<:technology:716812861514711040> Techs Researched: (**" + usr.techs_researched + "**/**" + config.valid_technologies.length + "**)");
						var last_turn_income_prefix = "";
						if (last_turn_income_prefix > 0) {
							last_turn_income_prefix = "+";
						}
						if (minimum_income != maximum_income) {
							stats_string.push("<:money:716817688718213192> Money: **" + parseNumber(usr.money) + "**" + " (<:money:716817688718213192> **" + last_turn_income_prefix + parseNumber(minimum_income) + " - " + parseNumber(maximum_income) + "** per turn).");
						} else {
							stats_string.push("<:money:716817688718213192> Money: **" + parseNumber(usr.money) + "**" + " (<:money:716817688718213192> **" + last_turn_income_prefix + parseNumber(minimum_income) + "** per turn).");
						}
						stats_string.push("------------------ \n**Internal Politics:**\n");
						stats_string.push("<:government:716817688693047306> Government Type: **" + config.governments[usr.government].name[0].toLowerCase() + "**");
						stats_string.push("<:political_capital:716817688525275257> Political Capital: **" + usr.political_capital + "**");
						stats_string.push("");
						var infamy_suffix = (usr.modifiers.infamy_loss < 0) ? "" : "+";
						stats_string.push("<:infamy:716817688453709905> Infamy: **" + usr.infamy + "** (" + infamy_suffix + (Math.round(usr.modifiers.infamy_loss*100)/100) + " per turn)");
						if (usr.infamy > config.infamy_limit) {
							stats_string.push(" - Our current level of infamy is costing us **" + Math.round(usr.infamy_rgo_throughput*100) + "%** RGO Throughput and **" + Math.round(usr.infamy_production_efficiency*100) + "%** Production Eff.");
						}
						var civ_actions_string = "";
						if (usr.civilian_actions_percentage != 0) {
							civ_actions_string = "**" + usr.civilian_actions_percentage*100 + "%** of your actions will be used up by civilians next turn.";
						}
						stats_string.push("------------------ \n**Actions:**\nActions can be used to `" + bot_prefix + "mine`, `" + bot_prefix + "quarry` or `" + bot_prefix + "chop`, which give you raw resources. " + civ_actions_string);
						stats_string.push("<:actions:716817688244256770> Actions: **" + usr.actions + "**");
						
						const embed_stats = new Discord.MessageEmbed()
							.setColor('#a98ac7')
							.setAuthor('Triumph & Tragedy:', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
							.setTitle('**Nation Overview:\n------------------**')
							.setThumbnail(usr.flag)
							.setDescription(stats_string.join("\n"))
							.setTimestamp()
							.setFooter('To access this menu again, type ' + bot_prefix + 'overview.', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png');
						
						return embed_stats;
					}
				}
			}
			
			function printPolitics (arg0_user, arg2_msg) {
				var politics_string = [];
				
				if (main.users[arg0_user] == undefined) {	
					arg2_msg.channel.send("The person you are looking for has no country!");
				} else {
					var usr = main.users[arg0_user];
					
					var temp_usr_obj = JSON.parse(JSON.stringify(usr));
					var local_user = nextTurn(temp_usr_obj, true);
					politics_string.push("**Ruling Government:**");
					politics_string.push("");
					politics_string.push("<:government:716817688693047306> Government Type: **" + main.users[arg0_user].government + "**");
					politics_string.push("<:political_capital:716817688525275257> Political Capital: **" + main.users[arg0_user].political_capital + "** (" + ((usr.modifiers.political_capital_gain >= 0) ? "+" : "") + parseNumber(usr.modifiers.political_capital_gain) + " per turn)");
					politics_string.push("");
					politics_string.push("`" + bot_prefix + "coup` - Coup your government to a chosen ideology for **150** <:political_capital:716817688525275257> Political Capital.");
					politics_string.push("------------------ \n**Political Parties:**\n`" + bot_prefix + "politics support` - Raise a party's popularity by **10%** for **50** <:political_capital:716817688525275257> Political Capital.");
					if (usr.available_reforms.length > 0) {
						politics_string.push("`" + bot_prefix + "reforms` - View available reforms that you can enact for **" + config.reform_cost + "** <:political_capital:716817688525275257> Political Capital.");
					} else {
						politics_string.push("Reforms are currently locked until additional related technologies are researched.");
					}
					politics_string.push("`" + bot_prefix + "culture` - View the cultural fabric of your nation.\n");
					var total_reform_desire_gain = usr.modifiers.reform_desire_gain;
					
					for (var i = 0; i < config.government_list.length; i++) {
						if (usr.politics[config.government_list[i]] > 0) {
							if (config.governments[config.government_list[i]].reform_desire != undefined) {
								total_reform_desire_gain = total_reform_desire_gain + config.governments[config.government_list[i]].reform_desire*(usr.politics[config.government_list[i]]/100);
							}
						}
					}
					
					if (total_reform_desire_gain > 0.15) {
						total_reform_desire_gain = 0.15;
					}
					
					var reform_desire_suffix = "";
					if (total_reform_desire_gain > 0) {
						reform_desire_suffix = "+";
					}
					
					if (usr.available_reforms.length > 0) {
						politics_string.push("<:consciousness:758424911852470293> Reform Desire: **" + (Math.round(usr.modifiers.reform_desire*100*100)/100) + "%** (" + reform_desire_suffix + (Math.round(total_reform_desire_gain*100*100)/100) + "% per turn). Pass reforms to lower **Reform Desire.**");
						politics_string.push("");
					}
					
					for (var i = 0; i < config.government_list.length; i++) {
						var discontented_stage = "";
						
						if (usr.modifiers[config.government_list[i] + "_discontent"] < 0) {
							discontented_stage = "pleased";
						} else if (usr.modifiers[config.government_list[i] + "_discontent"] >= 0 && usr.modifiers[config.government_list[i] + "_discontent"] < 13) {
							discontented_stage = "satisfied";
						} else if (usr.modifiers[config.government_list[i] + "_discontent"] >= 13 && usr.modifiers[config.government_list[i] + "_discontent"] < 25) {
							discontented_stage = "dissatisfied";
						} else if (usr.modifiers[config.government_list[i] + "_discontent"] >= 25 && usr.modifiers[config.government_list[i] + "_discontent"] < 38) {
							discontented_stage = "discontented";
						} else if (usr.modifiers[config.government_list[i] + "_discontent"] >= 38 && usr.modifiers[config.government_list[i] + "_discontent"] < 50) {
							discontented_stage = "unhappy";
						} else if (usr.modifiers[config.government_list[i] + "_discontent"] >= 50 && usr.modifiers[config.government_list[i] + "_discontent"] < 75) {
							discontented_stage = "outraged";
						} else if (usr.modifiers[config.government_list[i] + "_discontent"] >= 75 && usr.modifiers[config.government_list[i] + "_discontent"] < 88) {
							discontented_stage = "repulsed";
						} else if (usr.modifiers[config.government_list[i] + "_discontent"] >= 88 && usr.modifiers[config.government_list[i] + "_discontent"] < 100) {
							discontented_stage = "disgusted";
						} else if (usr.modifiers[config.government_list[i] + "_discontent"] >= 100) {
							discontented_stage = "ready to revolt";
						}
						
						if (usr.politics[config.government_list[i]] > 0) {
							politics_string.push(usr.politics[config.government_list[i]] + "% of your pop. are " + config.governments[config.government_list[i]].name[1].toLowerCase() + ". They are **" + discontented_stage + "** (" + Math.floor(usr.modifiers[config.government_list[i] + "_discontent"]) + ") with the state of our nation.");
						}
					}
					
					politics_string.push("------------------ \n**Stability:**\n`" + bot_prefix + "stability raise` - Raise stability by **10%** for **75** <:political_capital:716817688525275257> Political Capital.\n");
					
					var tax_rate = usr.tax_rate;
					var ruling_party_popularity = usr.politics[usr.government];
					
					var stab_government_modifier = 0;
					var stab_government_text = "";
					var stab_government_prefix = "";
					
					var age_modifier = 0;
					
					if (config.governments[usr.government].stability != undefined) {
						if (main.year < 1815 && config.governments[usr.government].early_game_stability != undefined) {
							stab_government_modifier = config.governments[usr.government].early_game_stability;
						} else {
							stab_government_modifier = config.governments[usr.government].stability;
						}
					}
					if (stab_government_modifier > 0) {
						stab_government_text = "due to the current government being " + usr.government + ".";
					} else {
						stab_government_text = "due to " + usr.government + " being in power.";
					}
					
					var calculated_stability = Math.floor(local_user.stability);
					
					//Modifiers
					if (usr.modifiers.stability_modifier != 0) {
						var stab_modifier_prefix = "";
						if (usr.modifiers.stability_modifier > 0) {
							stab_modifier_prefix = "+";
						}
						politics_string.push("**" + stab_modifier_prefix + Math.round(usr.modifiers.stability_modifier) + "%** base stability modifier.");
					}
					
					politics_string.push("**+" + Math.ceil(ruling_party_popularity*0.75) + "%** from ruling party popularity.");
					
					//Tax rate
					if (tax_rate > 0) {
						politics_string.push("**-" + Math.round(Math.ceil(tax_rate*100)) + "%** from current tax rate.");
					}
					
					//Government type
					if (stab_government_modifier > 0) {
						stab_government_prefix = "+";
					}
					if (stab_government_modifier != 0) {
						politics_string.push("**" + stab_government_prefix + stab_government_modifier + "%** " + stab_government_text);
					}
					
					//Artificially boosted stability
					if (usr.stability_decay > 0) {
						politics_string.push("**+" + usr.stability_decay + "%** from boosted stability. (**-1%** per turn).");
					}
					
					//Province stability
					politics_string.push("**-" + returnSafeNumber(Math.ceil(usr.overextension)) + "%** from overextension.");
					
					politics_string.push("------------------ \n**Calculated Stability:**\n");
					politics_string.push("<:stability:716817688722407424> Calculated Stability: **" + Math.ceil(calculated_stability) + "%**");
					politics_string.push("<:stability:716817688722407424> Current Stability: **" + Math.ceil(usr.stability) + "%**");
					
					if (calculated_stability < config.revolt_threshold && usr.country_age > 10) {
						var low_party_pop = false;
						for (var i = 0; i < config.government_list.length; i++) {
							if (usr.politics[config.government_list[i]] >= 30) {
								low_party_pop = true;
							}
						}
						
						if (low_party_pop) {
							politics_string.push("------------------");
							politics_string.push("You have a <:revolt:716819535964930149> **revolt risk** of **" + (40-calculated_stability) + "%**!");
						}
					}
					
					const embed_politics = new Discord.MessageEmbed()
						.setColor('#a98ac7')
						.setAuthor('Triumph & Tragedy:', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
						.setTitle('**Political Overview:\n------------------**')
						.setThumbnail(usr.flag)
						.setDescription(politics_string.join("\n"))
						.setTimestamp()
						.setFooter('To access this menu again, type ' + bot_prefix + 'politics view.', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png');
					
					return embed_politics;
				}
			}
			
			function printPopulation (arg0_user, arg1_msg) { //Improve in future for better moddability
				var msg = arg1_msg;
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					var population_string = [];
					var urban_pops = {};
					var rural_pops = {};
					var urban_pop_total = 0;
					var rural_pop_total = 0;
					var urban_pop_percentile = 0;
					var rural_pop_percentile = 0;
					
					var pop_tax_efficiency = 0;
					var pop_research_efficiency = 0;
					var pop_stability_gain = 0;
					var pop_knowledge_gain = 0;
					
					for (var i = 0; i < config.pop_array.length; i++) {
						urban_pops[config.pop_array[i]] = 0;
						rural_pops[config.pop_array[i]] = 0;
					}
					//Add pops from all cities
					for (var i = 0; i < usr.cities.city_array.length; i++) {
						if (usr.pops[usr.cities[usr.cities.city_array[i]].province] != undefined) {
							for (var x = 0; x < config.pop_array.length; x++) {
								urban_pops[config.pop_array[x]] = urban_pops[config.pop_array[x]] + usr.pops[usr.cities[usr.cities.city_array[i]].province][config.pop_array[x]];
							}
						}
					}
					for (var i = 0; i < usr.pops.pop_array.length; i++) {
						if (usr.pops[usr.pops.pop_array[i]] != undefined) {
							var is_city = false;
							for (var x = 0; x < usr.cities.city_array.length; x++) {
								if (usr.cities[usr.cities.city_array[x]].province == usr.pops.pop_array[i]) {
									is_city = true;
								}
							}
							
							if (is_city == false) {
								for (var x = 0; x < config.pop_array.length; x++) {
									rural_pops[config.pop_array[x]] = rural_pops[config.pop_array[x]] + usr.pops[usr.pops.pop_array[i]][config.pop_array[x]];
								}
							}
						}
					}
					
					//Get percentile and total of rural and urban population
					for (var i = 0; i < config.pop_array.length; i++) {
						urban_pop_total = urban_pop_total + urban_pops[config.pop_array[i]];
						rural_pop_total = rural_pop_total + rural_pops[config.pop_array[i]];
					}
					
					usr.population = urban_pop_total + rural_pop_total;
					
					urban_pop_percentile = Math.floor((urban_pop_total/usr.population)*100);
					rural_pop_percentile = Math.floor((rural_pop_total/usr.population)*100);
					
					//Get population bonuses
					for (var i = 0; i < config.pop_array.length; i++) {
						if (config.pops[config.pop_array[i]].tax_efficiency_per_100k != undefined) {
							pop_tax_efficiency = pop_tax_efficiency + Math.ceil(((usr[config.pop_array[i]]/100000)*config.pops[config.pop_array[i]].tax_efficiency_per_100k)*100);
						}
						if (config.pops[config.pop_array[i]].stability_per_100k != undefined) {
							pop_stability_gain = pop_stability_gain + Math.ceil(((usr[config.pop_array[i]]/100000)*config.pops[config.pop_array[i]].stability_per_100k)*100);
						}
						if (config.pops[config.pop_array[i]].research_efficiency_per_100k != undefined) {
							pop_research_efficiency = pop_research_efficiency + Math.ceil(((usr[config.pop_array[i]]/100000)*config.pops[config.pop_array[i]].research_efficiency_per_100k)*100);
						}
						if (config.pops[config.pop_array[i]].knowledge_per_100k != undefined) {
							pop_knowledge_gain = pop_knowledge_gain + Math.ceil(((usr[config.pop_array[i]]/100000)*config.pops[config.pop_array[i]].knowledge_per_100k));
						}
					}
					if (pop_knowledge_gain > 500) {
						pop_knowledge_gain = 500;
					}
					if (pop_research_efficiency > 50) {
						pop_research_efficiency = 50;
					}
					if (pop_tax_efficiency > 60) {
						pop_tax_efficiency = 60;
					}
					if (pop_stability_gain > 50) {
						pop_stability_gain = 50;
					}
					
					//Begin adding to string
					population_string.push("**Cultural Fabric:** `" + bot_prefix + "culture`");
					population_string.push("**Urban Population:** `" + bot_prefix + "pops view`");
					population_string.push("");
					population_string.push("<:development:716811992421367869> Urban Population: **" + urban_pop_percentile + "%**");
					population_string.push("- <:aristocrats:732730754643132457> Aristocrats: **" + parseNumber(urban_pops.aristocrats) + "**");
					population_string.push("- <:faculty:732730754911436830> Faculty: **" + parseNumber(urban_pops.faculty) + "**");
					population_string.push("- <:soldiers:732730754592669702> Soldiers: **" + parseNumber(urban_pops.soldiers) + "**");
					population_string.push("- <:workers:732730754735276124> Workers: **" + parseNumber(urban_pops.workers) + "**");
					population_string.push("");
					if (usr.city_count < usr.city_cap) {
						population_string.push("You can found up to **" + (usr.city_cap-usr.city_count) + "** more cities for more pops!");
						population_string.push("Type `" + bot_prefix + "city-new` to found a new city.");
					}
					population_string.push("------------------ \n**Rural Population:**\n");
					population_string.push("<:provinces:716809229603700737> Rural Population: **" + rural_pop_percentile + "%**");
					population_string.push("- <:aristocrats:732730754643132457> Aristocrats: **" + parseNumber(rural_pops.aristocrats) + "**");
					population_string.push("- <:faculty:732730754911436830> Faculty: **" + parseNumber(rural_pops.faculty) + "**");
					population_string.push("- <:soldiers:732730754592669702> Soldiers: **" + parseNumber(rural_pops.soldiers) + "**");
					population_string.push("- <:workers:732730754735276124> Workers: **" + parseNumber(rural_pops.workers) + "**");
					population_string.push("------------------ \n**Total Population:**\n");
					population_string.push("- <:aristocrats:732730754643132457> Total Aristocrats: **" + parseNumber(usr.aristocrats) + "**");
					population_string.push("- <:faculty:732730754911436830> Total Faculty: **" + parseNumber(usr.faculty) + "**");
					population_string.push("- <:soldiers:732730754592669702> Available Soldiers: **" + parseNumber((usr.soldiers*usr.modifiers.national_manpower*usr.manpower_percentage)-usr.used_soldiers) + "**");
					population_string.push("- <:workers:732730754735276124> Available Workers: **" + parseNumber(usr.workers-usr.used_workers) + "**");
					population_string.push("------------------ \n**Population Modifiers:**\n");
					if (pop_tax_efficiency > 0) {
						population_string.push("- **" + pop_tax_efficiency + "%** tax efficiency from **" + parseNumber(usr.aristocrats) + "** aristocrats.");
					}
					if (pop_stability_gain > 0) {
						population_string.push("- **" + pop_stability_gain + "%** base stability from **" + parseNumber(usr.aristocrats) + "** aristocrats.");
					}
					if (pop_research_efficiency > 0) {
						population_string.push("- **" + pop_research_efficiency + "%** research efficiency from **" + parseNumber(usr.faculty) + "** scientists and faculty.");
					}
					if (pop_knowledge_gain > 0) {
						population_string.push("- **+" + pop_knowledge_gain + "** knowledge each turn from **" + parseNumber(usr.faculty) + "** scientists and faculty.");
					}
					population_string.push("");
					var current_population = usr.population;
					var pop_growth_modifiers = (usr.pop_growth_modifier-1);
					var usr_obj = JSON.parse(JSON.stringify(usr));
					var future_obj = nextTurn(usr_obj, true);
					console.log("Current population: " + usr.population);
					console.log("Future population: " + future_obj.population);
					
					var potential_pop_growth = future_obj.population-current_population;
					var local_pop_growth_prefix = "";
					for (var i = 0; i < usr.temporary_modifiers.length; i++) {
						if (usr.temporary_modifiers[i][0] == "pop_growth_modifier") {
							pop_growth_modifiers = pop_growth_modifiers + usr.temporary_modifiers[i][1];
						}
					}
					if (potential_pop_growth > 0) {
						local_pop_growth_prefix = "+";
					}
					
					population_string.push("<:development:716811992421367869> Pop. Growth Modifier: **" + Math.ceil(pop_growth_modifiers*100) + "%**");
					population_string.push("<:population:716817688810356826> Pop. Growth Next Turn: **" + local_pop_growth_prefix + parseNumber(Math.ceil(potential_pop_growth)) + "**.");
					
					const embed_pops = new Discord.MessageEmbed()
						.setColor('#a98ac7')
						.setAuthor('Triumph & Tragedy:', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
						.setTitle('**Population:\n------------------**')
						.setThumbnail(usr.flag)
						.setDescription(population_string.join("\n"))
						.setTimestamp()
						.setFooter('To access this menu again, type ' + bot_prefix + 'pops.', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png');
						
					return embed_pops;
				} else {
					msg.channel.send("The user you have specified did not have a country!");
				}
			}
			
			function printTechnology (arg0_user, arg1_msg) {
				var msg = arg1_msg;
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					var technology_string = [];
					
					technology_string.push("**Technological Advancement:**\n");
					technology_string.push("<:government:716817688693047306> Current Tech Count: (**" + usr.techs_researched + "**/" + parseNumber(config.valid_technologies.length) + ")");
					for (var i = 0; i < config.tech_categories.length; i++) {
						var category_research_progress = usr[config.tech_categories[i] + "_researched"];
						//Get tech count for category
						var category_tech_count = 0;
						for (var x = 0; x < config.valid_technologies.length; x++) {
							if (config.technology[config.valid_technologies[x]].category == config.tech_categories[i]) {
								category_tech_count++;
							}
						}
						
						technology_string.push(" - <:technology:716812861514711040> " + config.tech_categories[i].replace(/_/g, " ").replace(/(^\w{1})|(\s{1}\w{1})/g, match => match.toUpperCase()) + " Research Progress: (**" + category_research_progress + "**/" + category_tech_count + ")");
					}
					technology_string.push("");
					technology_string.push("<:knowledge:716797747193446441> Knowledge gain last turn: +**" + parseNumber(usr.knowledge_per_turn) + "**");
					
					var tech_array_dump = [];
					for (var i = 0; i < config.valid_technologies.length; i++) {
						var tech_available = false;
						
						if (config.technology[config.valid_technologies[i]].prerequisite_techs != undefined) {
							var prerequisite_checks = 0;
							for (var y = 0; y < config.technology[config.valid_technologies[i]].prerequisite_techs.length; y++) {
								for (var z = 0; z < usr.researched_technologies.length; z++) {
									if (config.technology[config.valid_technologies[i]].prerequisite_techs[y] == usr.researched_technologies[z]) {
										prerequisite_checks++;
									}
								}
							}
							
							if (prerequisite_checks == config.technology[config.valid_technologies[i]].prerequisite_techs.length) {
								tech_available = true;
							}
						} else { //No prerequisite checks found, so must be a starting tech
							tech_available = true;
						}
						
						//Check if user has already researched tech
						for (var y = 0; y < usr.researched_technologies.length; y++) {
							if (usr.researched_technologies[y] == config.valid_technologies[i]) {
								tech_available = false;
							}
						}
						
						//Append to valid tech dump for later categorisation
						if (tech_available) {
							tech_array_dump.push(config.valid_technologies[i]);
						}
					}
					
					technology_string.push("------------------ \n**Research Possibilities:** Type `" + bot_prefix + "research list` for a full list.\n");
					if (tech_array_dump.length > 0) {
						for (var i = 0; i < tech_array_dump.length; i++) {
							if (i <= 5) {
								var local_tech = config.technology[tech_array_dump[i]];
								var local_icon = "";
								var research_string = "";
								if (config.technology[tech_array_dump[i]].icon != undefined) {
									local_icon = config.technology[tech_array_dump[i]].icon + " ";
								}
								if (usr.researching.length < usr.modifiers.research_slots) {
									research_string = "\n`" + bot_prefix + "research " + tech_array_dump[i] + "`";
								}
								
								//Ahead of time penalty calculations
								var aot_penalty = 0;
								var final_aot_penalty = 1;
								var has_aot_penalty = false;
								for (var x = 0; x < config.ahead_of_time.length; x++) {
									if (main.year >= config.ahead_of_time[x][0] && main.year < config.ahead_of_time[x][1]) {
										aot_penalty = 2/config.ahead_of_time[x][2];
									}
								}
								
								if (local_tech.year != undefined) {
									var aot_years = 0;
									
									if (main.year < local_tech.year) {
										has_aot_penalty = true;
										aot_years = local_tech.year-main.year;
										final_aot_penalty = (aot_years*aot_penalty)+1;
									}
								}
								
								var total_research_cost = Math.round(local_tech.research_cost*final_aot_penalty);
								
								technology_string.push("- " + local_icon + "" + tech_array_dump[i].replace(/_/g, " ").replace(/(^\w{1})|(\s{1}\w{1})/g, match => match.toUpperCase()) + " (<:knowledge:716797747193446441> **" + parseNumber(total_research_cost) + "**)" + research_string);
							}
						}
						if (tech_array_dump.length > 5) {
							technology_string.push("+" + parseNumber(tech_array_dump.length-5) + " more ...");
						}
					} else {
						technology_string.push("_No available techs could be found._");
					}
					technology_string.push("");
					technology_string.push("**Current Research:** `" + bot_prefix + "research`");
					technology_string.push("Type `" + bot_prefix + "research-queue` to queue up research.");
					technology_string.push("---");
					
					if (usr.researching.length > 0) {
						for (var i = 0; i < usr.researching.length; i++) {
							if (config.technology[usr.researching[i][1]].icon != undefined) {
								icon = config.technology[usr.researching[i][1]].icon + " ";
							}
							technology_string.push("`" + bot_prefix + "cancel-research " + i + "`");
							technology_string.push("Currently researching " + icon + "**" + usr.researching[i][1].replace(/_/g, " ").replace(/(^\w{1})|(\s{1}\w{1})/g, match => match.toUpperCase()) + "**.");
							technology_string.push("- Research Progress: **" + parseNumber(usr.researching[i][0]) + "/" + parseNumber(usr.researching[i][2]) + "** <:government:716817688693047306>.");
							technology_string.push("");
						}
					} else {
						technology_string.push("_You currently aren't researching anything!_");
					}
					
					const technology_embed = new Discord.MessageEmbed()
						.setColor('#a98ac7')
						.setAuthor('Triumph & Tragedy:', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
						.setTitle('**Technology:\n------------------**')
						.setThumbnail(usr.flag)
						.setDescription(technology_string.join("\n"))
						.setTimestamp()
						.setFooter('To access this menu again, type ' + bot_prefix + 'technology.', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png');
						
					return technology_embed;
				} else {
					msg.channel.send("The user you have specified did not have a valid country!");
				}
			}
			
			function printTrade (arg0_user, arg1_msg) {
				var msg = arg1_msg;
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					var trade_string = [];
					var number_of_exports = 0;
					
					for (var i = 0; i < usr.trade_array.length; i++) {
						if (usr.trade_array[i][0][1] != "money") {
							number_of_exports = number_of_exports + usr.trade_array[i][0][0];
						}
					}
					
					trade_string.push("**Travel Modifiers:**");
					trade_string.push("");
					if (usr.blockaded) {
						trade_string.push("<:blockade:716817688592252979> **You are currently blockaded!**");
						trade_string.push("Being blockaded means you won't be able to ship or receive goods anymore. You can challenge this blockade by building up a naval fleet.");
						trade_string.push("");
					}
					trade_string.push("Base travel time: **" + parseNumber(Math.ceil(config.base_transfer_time*usr.modifiers.shipment_time)) + "** turns.");
					trade_string.push("Current travel speed: **" + parseNumber(Math.ceil(config.shipment_time/usr.modifiers.shipment_time)) + "** provinces a turn.");
					trade_string.push("Shipment capacity: **" + parseNumber(Math.ceil(number_of_exports)) + "** out of **" + parseNumber(usr.modifiers.shipment_capacity) + "** currently in use.");
					var local_static_prefix = "";
					if (usr.modifiers.shipment_time > 1) {
						local_static_prefix = "+";
					}
					if (usr.modifiers.shipment_time != 1) {
						trade_string.push("- Shipment Time Modifier: **" + local_static_prefix + Math.ceil((usr.modifiers.shipment_time-1)*100) + "%**.");
					}
					var local_dynamic_prefix = "";
					var local_temp_modifiers = 0;
					
					for (var i = 0; i < usr.temporary_modifiers.length; i++) {
						if (usr.temporary_modifiers[i][0] == "shipment_time") {
							local_temp_modifiers = local_temp_modifiers + usr.temporary_modifiers[i][1];
						}
					}
					
					if (local_temp_modifiers > 0) {
						local_dynamic_prefix = "+";
					}
					
					if (local_temp_modifiers != 0) {
						trade_string.push("- Shipment Time from temporary modifiers: **" + local_dynamic_prefix + Math.ceil((local_temp_modifiers)*100) + "%**.");
					}
					
					//Import/Export list
					trade_string.push("------------------ \n**Imports/Exports:**");
					trade_string.push("");
					if (usr.auto_trades.length > 0) {
						trade_string.push("You currently have **" + usr.auto_trades.length + "** ongoing auto-trades. In order to access them, type `" + bot_prefix + "auto-trades`.");
					} else {
						trade_string.push("_You currently have no ongoing auto-trades._ In order to access the Auto Trade UI, type `" + bot_prefix + "auto-trades`.");
					}
					trade_string.push("");
					//[[3, "iron"], "213287117017710593", 3]
					trade_string.push("<:taxes:716817688781127810> **Import List:** `" + bot_prefix + "list-imports`");
					
					var import_list = [];
					//Fetch import list, only print up to 10 imports
					for (var i = 0; i < main.user_array.length; i++) {
						if (main.users[main.user_array[i]].trade_array.length > 0 && main.user_array[i] != arg0_user) {
							for (var x = 0; x < main.users[main.user_array[i]].trade_array.length; x++) {
								var import_amount = main.users[main.user_array[i]].trade_array[x][0][0];
								var import_type = main.users[main.user_array[i]].trade_array[x][0][1];
								var exporter_name = main.users[main.user_array[i]].name;
								var time_remaining = main.users[main.user_array[i]].trade_array[x][2];
								
								var import_icon = "";
								
								//Get import icon
								for (var y = 0; y < config.materials.length; y++) {
									if (config.materials[y] == import_type) {
										import_icon = config.resource_icons[y];
									}
								}
								
								//Check if user is exporting items to selected user
								if (main.users[main.user_array[i]].trade_array[x][1] == arg0_user) {
									//Add to string array
									import_list.push("Importing " + import_icon + " " + parseNumber(import_amount) + " " + import_type + " from " + "**" + exporter_name + "**.\nThe shipment will arrive in **" + time_remaining + "** turn(s).");
								}
							}
						}
					}
					
					if (import_list.length > 0) {
						trade_string.push("You currently have **" + import_list.length + "** imports in transfer.");
					} else {
						trade_string.push("_You have no incoming imports._");
					}
					
					trade_string.push("");
					trade_string.push("<:trade:716828677115084812> **Export List:** `" + bot_prefix + "list-exports` ¦ `" + bot_prefix + "give <@user> [number] <item>`");
					
					//Fetch export list
					var export_list = [];
					
					if (usr.trade_array.length > 0) {
						trade_string.push("You currently have **" + usr.trade_array.length + "** exports in transfer.");
					} else {
						trade_string.push("_You have no outgoing exports._");
					}
					
					//World Market
					trade_string.push("");
					trade_string.push("------------------\n**World Market:**");
					trade_string.push("For more complete information on the World Market, type `" + bot_prefix + "buy list`.");
					trade_string.push("");
					
					//Enter entries
					for (var i = 0; i < config.resource_list.length; i++) {
						if (i < 11) {
							var local_resource_icon = "";
							for (var x = 0; x < config.materials.length; x++) {
								if (config.materials[x] == config.resource_list[i][0]) {
									local_resource_icon = config.resource_icons[x];
								}
							}
							var resource_price = main.users.global[config.resource_list[i][0] + "_buy_price"];
							var resource_stock = main.users.global[config.resource_list[i][0] + "_stock"];
							trade_string.push(local_resource_icon + " - £" + parseNumber(resource_price) + " (**" + resource_stock + "**): `" + bot_prefix + "buy " + config.resource_list[i][0] + "` ¦ `" + bot_prefix + "sell " + config.resource_list[i][0] + "`.");
						}
					}
					if (i > 10) {
						trade_string.push("+ " + parseNumber(i-10) + " more ...");
					}
					
					const embed_trade = new Discord.MessageEmbed()
						.setColor('#a98ac7')
						.setAuthor('Triumph & Tragedy:', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
						.setTitle('**Trade:\n------------------**')
						.setThumbnail(usr.flag)
						.setDescription(trade_string.join("\n"))
						.setTimestamp()
						.setFooter('To access this menu again, type ' + bot_prefix + 'trade.', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png');
					
					return embed_trade;
				} else {
					msg.channel.send("The user you have specified did not have a country!");
				}
			}
			
			//Print lists
			{
				//Build List
				function printBuildList (arg0_user, arg1_msg) {
					var msg = arg1_msg;
					var build_list = [];
					
					if (main.users[arg0_user] != undefined) {
						var usr = main.users[arg0_user];
						var user_id = main.users[arg0_user];
						
						build_list.push("<:government_scroll:716828975175041054> **Building List:**");
						build_list.push("------------------");
						
						//Use building_categories as a variable
						for (var i = 0; i < config.building_categories.length; i++) {
							var valid_buildings = 0;
							var valid_building_array = [];
							
							//Parse through all available buildings of the category
							for (var x = 0; x < config[config.building_categories[i]].length; x++) {
								//Get technology argument
								var tech_argument_found = false;
								var tech_level_needed = 1;
								console.log("[Triumph & Tragedy]: " + config[config.building_categories[i]][x] + " costs:");
								console.log("[Triumph & Tragedy]: " + config.building_stats[config[config.building_categories[i]][x]].costs);
								for (var y = 0; y < usr.available_buildings.length; y++) {
									if (usr.available_buildings[y] == config[config.building_categories[i]][x]) {
										tech_argument_found = true;
										//Push valid items and valid item array
										valid_buildings++;
										valid_building_array.push(config[config.building_categories[i]][x]);
									}
								}
							}
							
							//Append category header
							if (valid_buildings > 0) {
								//Parse category name
								var regular_category_name = config.building_categories[i];
								regular_category_name = regular_category_name.replace(/_/gm, " ");
								var split_category_name = regular_category_name.split(" ");
								for (var x = 0; x < split_category_name.length; x++) {
									split_category_name[x] = split_category_name[x].charAt(0).toUpperCase() + split_category_name[x].substring(1);
								}										
								
								//Return regular category name
								regular_category_name = split_category_name.join(" ");
								build_list.push("**" + regular_category_name + ":**");
								build_list.push("------------------");
								build_list.push("");
								
								for (var x = 0; x < valid_building_array.length; x++) {
									//Get building costs
									var costs_array = [];
									var costs_string = "";
									
									var manpower_cost = 0;
									var manpower_string = "";
									
									var building_stat_valid = false;
									var building_stat_string = "";
									
									//Production stuff
									var production_array = [];
									var maintenance_array = [];
									var has_production = false;
									var has_maintenance = false;
									
									var production_string = "";
									
									//Display
									var building_icon = "";
									var manpower_type = "";
									
									//Run through costs array
									for (var y = 0; y < config.building_stats[valid_building_array[x]].costs.length; y++) {
										//Parse debug name
										var resource_name = config.building_stats[valid_building_array[x]].costs[y][1];
										
										if (resource_name != "money" && resource_name != "manpower" && resource_name != "tech") {
											resource_name = resource_name.replace(/_/gm, " ");
											var split_resource_name = resource_name.split(" ");
											for (var z = 0; z < split_resource_name.length; z++) {
												split_resource_name[z] = split_resource_name[z].charAt(0).toUpperCase() + split_resource_name[z].substring(1);
											}
											
											costs_array.push(Math.ceil(config.building_stats[valid_building_array[x]].costs[y][0]*usr.modifiers.building_cost) + " " + split_resource_name.join(" "));
										} else if (resource_name == "money") {
											costs_array.push("£" + parseNumber(Math.ceil(config.building_stats[valid_building_array[x]].costs[y][0]*usr.modifiers.building_cost)));
										}
										
										var pop_cost = false;
										for (var z = 0; z < config.pop_array.length; z++) {
											if (config.pop_array[z] == resource_name) {
												pop_cost = true;
												manpower_type = config.pop_array[z].charAt(0).toUpperCase() + config.pop_array[z].substring(1);
											}
										}
										if (pop_cost) {
											manpower_cost = manpower_cost + config.building_stats[valid_building_array[x]].costs[y][0];
											costs_array.pop();
										}
									}
									
									if (manpower_cost > 0) {
										manpower_string = " ¦ " + parseNumber(manpower_cost) + " " + manpower_type;
									}
									
									//Get production string
									if (config.building_stats[valid_building_array[x]].produces != undefined) {
										has_production = true;
										for (var y = 0; y < config.building_stats[valid_building_array[x]].produces.length; y++) {
											var production_eff = 1;
											
											if (config.building_stats[valid_building_array[x]].cost_per_turn != undefined) {
												production_eff = usr.modifiers.production_efficiency;
											}
											
											//See if the building produces a random value of goods
											console.log("[Triumph & Tragedy]: " + user_id.modifiers.production_efficiency);
											if (Array.isArray(config.building_stats[valid_building_array[x]].produces[y][0])) {
												var resource_name = config.building_stats[valid_building_array[x]].produces[y][1];
												if (resource_name != "money" && resource_name != "manpower" && resource_name != "actions" && resource_name != "knowledge") {
													resource_name = resource_name.replace(/_/gm, " ");
													var split_resource_name = resource_name.split(" ");
													for (var z = 0; z < split_resource_name.length; z++) {
														split_resource_name[z] = split_resource_name[z].charAt(0).toUpperCase() + split_resource_name[z].substring(1);
													}
													
													production_array.push(parseNumber(Math.ceil(config.building_stats[valid_building_array[x]].produces[y][0][0]*production_eff*user_id.modifiers[config.building_stats[valid_building_array[x]].produces[y][1]])) + "-" + parseNumber(Math.ceil(config.building_stats[valid_building_array[x]].produces[y][0][1]*production_eff*user_id.modifiers[config.building_stats[valid_building_array[x]].produces[y][1]])) + split_resource_name.join(" "));
												} else if (resource_name == "money") {
													production_array.push("£" + parseNumber(Math.ceil(config.building_stats[valid_building_array[x]].produces[y][0][0]*production_eff)) + " - £" + parseNumber(Math.ceil(config.building_stats[valid_building_array[x]].produces[y][0][1]*production_eff)));
												} else if (resource_name == "actions") {
													production_array.push(parseNumber(Math.ceil(config.building_stats[valid_building_array[x]].produces[y][0][0]*production_eff)) + "-" + parseNumber(Math.ceil(config.building_stats[valid_building_array[x]].produces[y][0][1]*production_eff)) + " Actions");
												} else if (resource_name == "knowledge") {
													production_array.push(parseNumber(Math.ceil(config.building_stats[valid_building_array[x]].produces[y][0][0]*user_id.modifiers.research_efficiency)) + "-" + parseNumber(Math.ceil(config.building_stats[valid_building_array[x]].produces[y][0][1]*user_id.modifiers.research_efficiency)) + " Knowledge");
												}
											} else {
												var resource_name = config.building_stats[valid_building_array[x]].produces[y][1];
												
												if (resource_name != "money" && resource_name != "manpower" && resource_name != "actions" && resource_name != "knowledge" && resource_name.indexOf("_cp") == -1) {
													resource_name = resource_name.replace(/_/gm, " ");
													var split_resource_name = resource_name.split(" ");
													for (var z = 0; z < split_resource_name.length; z++) {
														split_resource_name[z] = split_resource_name[z].charAt(0).toUpperCase() + split_resource_name[z].substring(1);
													}
													console.log("[Triumph & Tragedy]: " + Math.ceil(config.building_stats[valid_building_array[x]].produces[y][0]*user_id.modifiers[config.building_stats[valid_building_array[x]].produces[y][1]]*production_eff));
													production_array.push(parseNumber(Math.ceil(config.building_stats[valid_building_array[x]].produces[y][0]*user_id.modifiers[config.building_stats[valid_building_array[x]].produces[y][1]]*production_eff)) + " " + split_resource_name.join(" "));
												} else if (resource_name == "money") {
													production_array.push("£" + parseNumber(Math.ceil(config.building_stats[valid_building_array[x]].produces[y][0]*production_eff)));
												} else if (resource_name == "actions") {
													production_array.push(parseNumber(Math.ceil(config.building_stats[valid_building_array[x]].produces[y][0]*production_eff)) + " Actions");
												}  else if (resource_name == "knowledge") {
													production_array.push(parseNumber(Math.ceil(config.building_stats[valid_building_array[x]].produces[y][0]*user_id.modifiers.research_efficiency)) + " Knowledge");
												} else if (resource_name.indexOf("_cp") != -1) {
													if (resource_name == "ground_units_cp") {
														production_array.push(parseNumber(Math.ceil(config.building_stats[valid_building_array[x]].produces[y][0]*production_eff)) + " Army CP");
													} else if (resource_name == "ground_artillery_cp") {
														production_array.push(parseNumber(Math.ceil(config.building_stats[valid_building_array[x]].produces[y][0]*production_eff)) + " Artillery CP");
													} else if (resource_name == "ground_vehicles_cp") {
														production_array.push(parseNumber(Math.ceil(config.building_stats[valid_building_array[x]].produces[y][0]*production_eff)) + " Armour CP");
													} else if (resource_name == "naval_units_cp") {
														production_array.push(parseNumber(Math.ceil(config.building_stats[valid_building_array[x]].produces[y][0]*production_eff)) + " Naval CP");
													} else if (resource_name == "aeroplanes_cp") {
														production_array.push(parseNumber(Math.ceil(config.building_stats[valid_building_array[x]].produces[y][0]*production_eff)) + " Air CP");
													}
												}
											}
										}
									}
									
									//Get maintenance string
									if (config.building_stats[valid_building_array[x]].cost_per_turn != undefined) {
										has_maintenance = true;
										for (var y = 0; y < config.building_stats[valid_building_array[x]].cost_per_turn.length; y++) {
											
											//See if the building takes a random value of goods
											if (Array.isArray(config.building_stats[valid_building_array[x]].cost_per_turn[y][0])) {
												var resource_name = config.building_stats[valid_building_array[x]].cost_per_turn[y][1];
												
												if (resource_name != "money" && resource_name != "manpower" && resource_name != "actions") {
													resource_name = resource_name.replace(/_/gm, " ");
													var split_resource_name = resource_name.split(" ");
													for (var z = 0; z < split_resource_name.length; z++) {
														split_resource_name[z] = split_resource_name[z].charAt(0).toUpperCase() + split_resource_name[z].substring(1);
													}
													
													maintenance_array.push(config.building_stats[valid_building_array[x]].cost_per_turn[y][0][0] + "-" + config.building_stats[valid_building_array[x]].cost_per_turn[y][0][1] + split_resource_name.join(" "));
												} else if (resource_name == "money") {
													maintenance_array.push("£" + parseNumber(config.building_stats[valid_building_array[x]].cost_per_turn[y][0][0]) + " - £" + parseNumber(config.building_stats[valid_building_array[x]].cost_per_turn[y][0][1]));
												} else if (resource_name == "actions") {
													maintenance_array.push(parseNumber(config.building_stats[valid_building_array[x]].cost_per_turn[y][0][0]) + "-" + parseNumber(config.building_stats[valid_building_array[x]].cost_per_turn[y][0][1]) + " Actions");
												}
											} else {
												var resource_name = config.building_stats[valid_building_array[x]].cost_per_turn[y][1];
												
												if (resource_name != "money" && resource_name != "manpower" && resource_name != "actions") {
													resource_name = resource_name.replace(/_/gm, " ");
													var split_resource_name = resource_name.split(" ");
													for (var z = 0; z < split_resource_name.length; z++) {
														split_resource_name[z] = split_resource_name[z].charAt(0).toUpperCase() + split_resource_name[z].substring(1);
													}
													
													maintenance_array.push(config.building_stats[valid_building_array[x]].cost_per_turn[y][0] + " " + split_resource_name.join(" "));
												} else if (resource_name == "money") {
													maintenance_array.push("£" + parseNumber(config.building_stats[valid_building_array[x]].cost_per_turn[y][0]));
												} else if (resource_name == "actions") {
													maintenance_array.push(parseNumber(config.building_stats[valid_building_array[x]].cost_per_turn[y][0]) + " Actions");
												}
											}
										}
									}
									
									var construction_string = "";
									if (config.building_stats[valid_building_array[x]].construction_turns != undefined) {
										if (config.building_stats[valid_building_array[x]].construction_turns != 0) {
											construction_string = " ¦ Takes " + parseNumber(Math.ceil(config.building_stats[valid_building_array[x]].construction_turns*usr.modifiers.construction_speed)) + " Turns to construct";
										} else {
											construction_string = " ¦ Constructed instantly";
										}
									} else {
										construction_string = " ¦ Takes " + parseNumber(config.construction_turns*usr.modifiers.construction_speed) + " Turns to construct";
									}
									
									//Entry logic
									if (has_maintenance && has_production) {
										production_string = " ¦ Produces " + production_array.join(", ") + " from " + maintenance_array.join(", ");
									} else if (has_production) {
										production_string = " ¦ Produces " + production_array.join(", ") + " per turn";
									} else if (has_maintenance) {
										production_string = " ¦ Costs " + maintenance_array.join(", ") + " per turn";
									} else {
										//Custom localisation
										if (config.building_stats[valid_building_array[x]].description != undefined) {
											production_string = " ¦ " + config.building_stats[valid_building_array[x]].description;
										}
									}
									
									if (config.building_stats[valid_building_array[x]].icon != undefined) {
										building_icon = config.building_stats[valid_building_array[x]].icon + " ";
									}
									
									//Manpower string
									if (manpower_cost > 0) {
										manpower_string = " ¦ " + parseNumber(manpower_cost) + " " + manpower_type;
									}
									
									//Push items to array
									var entry_exists = false;
									var final_string = building_icon + "**" + valid_building_array[x] + "** - " + costs_array.join(", ") + manpower_string + production_string + construction_string;
									
									//Test for duplicates
									for (var y = 0; y < build_list.length; y++) {
										if (build_list[y] == final_string) {
											entry_exists = true;
										}
									}
									
									if (entry_exists == false) {
										build_list.push(final_string);
									}
								}
								//Insert margin	
								build_list.push("");
							}
						}
						
						//Split up build_list array into multiple sections
						longMessage(arg1_msg, build_list, 10);
					} else {
						msg.channel.send("You don't even have a country!");
					}
				}
				
				//Buy List
				function printBuyList (arg0_user, arg1_msg, arg2_page) {
					var msg = arg1_msg;
					var actual_page = 0;
					
					if (arg2_page != undefined) {
						actual_page = (arg2_page-1);
					}
					
					if (main.users[arg0_user] != undefined) {
						if (isNaN(actual_page) != true) {
							var usr = main.users[arg0_user];
							var market = main.users.global;
							var market_array = [];
							
							market_array.push("");
							for (var i = 0; i < config.resource_list.length; i++) {
								var local_resource_name = config.resource_list[i][0];
								var resource_icon = "";
								//Iterate through resource icon array
								for (var x = 0; x < config.materials.length; x++) {
									if (config.materials[x] == config.resource_list[i][0]) {
										resource_icon = config.resource_icons[x];
									}
								}
								
								//[Icon] - Steel (**9** in stock): Buy Price: £3.500 ¦ Sell Price: £2.000
								//`+buy steel` ¦ `+sell steel`
								
								market_array.push(resource_icon + " - " + local_resource_name + " (**" + parseNumber(market[local_resource_name + "_stock"]) + "** in stock): Buy Price: £" + parseNumber(market[local_resource_name + "_buy_price"]) + " ¦ Sell Price: £" + parseNumber(market[local_resource_name + "_sell_price"]) + "\n`" + bot_prefix + "buy [number] " + local_resource_name + "` ¦ `" + bot_prefix + "sell [number] " + local_resource_name + "`");
								market_array.push("");
							}
							
							var market_embeds = [];
							var local_buy_string = [];
							
							if (market_array.length > 0) {
								for (var i = 0; i < market_array.length; i++) {
									local_buy_string.push(market_array[i]);
									if (i != 0 || market_array.length == 1) {
										if (i % 20 == 0 || i == market_array.length-1) {
											const embed_market = new Discord.MessageEmbed()
												.setColor('#a98ac7')
												.setAuthor('Triumph & Tragedy:', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
												.setTitle('**World Market (Page ' + (Math.ceil(i/20)) + ' of ' + (Math.ceil(market_array.length/20)) + '):\n------------------**')
												.setThumbnail('https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
												.setDescription("You have **" + parseNumber(Math.ceil((usr.modifiers.shipment_capacity*usr.maximum_transaction_amount)-usr.total_transactions_this_turn)) + "** Market Capacity remaining for this turn.\n" + local_buy_string.join("\n") + "\n_Our deals are always steals!_")
												.setTimestamp()
												.setFooter('To access this menu again, type ' + bot_prefix + 'buy list.', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png');
											
											market_embeds.push(embed_market);
											local_buy_string = [];
										}
									}
								}
							}
							
							scrollMessage(msg, market_embeds, actual_page);
						} else {
							msg.channel.send("You must specify a valid page to scroll to!");
						}
					} else {
						msg.channel.send("You must found a nation in order to participate in the World Market!");
					}
				}
				
				function printCBList (arg0_user, arg1_msg) {
					var msg = arg1_msg;
					
					if (main.users[arg0_user] != undefined) {
						var usr = main.users[arg0_user];
						var cb_keys = Object.keys(config.casus_belli);
						var cb_list = [];
						
						//status_quo, install_government, cut_down_to_size, liberation, puppet, retake_cores, annexation
						
						cb_list.push("**Casus Belli:**");
						cb_list.push("------------------");
						cb_list.push("Notice: Status Quo includes war reparations.");
						cb_list.push("");
						
						for (var i = 0; i < cb_keys.length; i++) {
							var icon = "";
							var peace_demands = config.casus_belli[cb_keys[i]].peace_demands.join(", ");
							peace_demands = peace_demands.replace("status_quo", "Status Quo");
							peace_demands = peace_demands.replace("install_government", "Install Government");
							peace_demands = peace_demands.replace("cut_down_to_size", "Cut Down To Size");
							peace_demands = peace_demands.replace("liberation", "Liberation");
							peace_demands = peace_demands.replace("puppet", "Puppet");
							peace_demands = peace_demands.replace("retake_cores", "Retake Cores");
							peace_demands = peace_demands.replace("annexation", "Annexation");
							if (config.casus_belli[cb_keys[i]].icon != undefined) {
								icon = config.casus_belli[cb_keys[i]].icon + " ";
							}
							cb_list.push(icon + "**" + config.casus_belli[cb_keys[i]].name + ":**");
							cb_list.push("```css");
							cb_list.push("- Requirement: " + config.casus_belli[cb_keys[i]].description);
							cb_list.push("- Peace Demands: " + peace_demands + ".");
							cb_list.push("- Infamy: " + parseNumber(config.casus_belli[cb_keys[i]].infamy) + ".");
							cb_list.push("```");
						}
						
						longMessage(msg, cb_list, 35);
					} else {
						msg.channel.send("You must found a country with the `" + bot_prefix + "found` command in order to view this list!");
					}
				}
				
				//Craft List - oof size large
				function printCraftList (arg0_user, arg1_msg) {
					var msg = arg1_msg;
					var craft_recipe = [];
					
					if (main.users[arg0_user] != undefined) {
						//Only show the user crafting recipes relevant to his tech level.
						var usr = main.users[arg0_user];
						var user_id = usr;
						
						craft_recipe.push("<:building:716827579650408538>" + " **Crafting List:**");
						craft_recipe.push("------------------");
						for (var i = 0; i < config.unit_categories.length; i++) {
							var valid_items = 0;
							var valid_item_array = [];
							
							//Parse through all available unit categories
							for (var x = 0; x < config[config.unit_categories[i]].length; x++) {
								var valid_item = false;
								for (var y = 0; y < usr.available_units.length; y++) {
									if (usr.available_units[y] == config[config.unit_categories[i]][x]) {
										valid_item = true;
									}
								}
								if (usr.obsolete_units != undefined) {
									for (var y = 0; y < usr.obsolete_units.length; y++) {
										if (usr.obsolete_units[y] == config[config.unit_categories[i]][x]) {
											valid_item = false;
										}
									}
								}
								if (valid_item) {
									valid_items++;
									valid_item_array.push(config[config.unit_categories[i]][x]);
								}
							}
							
							console.log("[Triumph & Tragedy]: Valid Item Array (Craft List): " + valid_item_array);
							
							//Append category header
							if (valid_items > 0) {
								//Parse category name
								var regular_category_name = config.unit_categories[i];
								regular_category_name = regular_category_name.replace(/_/gm, " ");
								var split_category_name = regular_category_name.split(" ");
								for (var x = 0; x < split_category_name.length; x++) {
									split_category_name[x] = split_category_name[x].charAt(0).toUpperCase() + split_category_name[x].substring(1);
								}										
								
								//Return regular category name
								regular_category_name = split_category_name.join(" ");
								
								//Get quantities
								var quantity_array = [];
								
								for (var x = 0; x < config[config.unit_categories[i]].length; x++) {
									//Check if quantity already exists in array
									var quantity_exists = false;
									for (var y = 0; y < quantity_array.length; y++) {
										if (quantity_array[y] == parseNumber(config.unit_stats[config[config.unit_categories[i]][x]].quantity)) {
											quantity_exists = true;
										}
									}
									
									if (quantity_exists == false) {
										quantity_array.push(parseNumber(config.unit_stats[config[config.unit_categories[i]][x]].quantity));
									}
								}
								
								//Push results
								craft_recipe.push(config.unit_category_icons[i] + " **" + regular_category_name + ":** (x" + quantity_array.join(", ") + ")");
								craft_recipe.push("------------------");
								craft_recipe.push("");
							}
							
							//Append category items
							if (valid_items > 0) {
								//Loop through all category items
								for (var x = 0; x < valid_item_array.length; x++) {
									//Get item costs
									var costs_array = [];
									var costs_string = "";
									
									var manpower_cost = 0;
									var manpower_string = "";
									var cp_string = "";
									
									var unit_stat_valid = false;
									var unit_stat_string = "";
									
									for (var y = 0; y < config.unit_stats[valid_item_array[x]].costs.length; y++) {
										//Parse debug name
										var resource_name = config.unit_stats[valid_item_array[x]].costs[y][1];
										
										if (resource_name != "money" && resource_name != "manpower" && resource_name != "tech" && resource_name.indexOf("_cp") == -1) {
											resource_name = resource_name.replace(/_/gm, " ");
											var split_resource_name = resource_name.split(" ");
											for (var z = 0; z < split_resource_name.length; z++) {
												split_resource_name[z] = split_resource_name[z].charAt(0).toUpperCase() + split_resource_name[z].substring(1);
											}
											
											costs_array.push(Math.ceil(config.unit_stats[valid_item_array[x]].costs[y][0]*user_id.modifiers.unit_cost) + " " + split_resource_name.join(" "));
										} else if (resource_name == "money") {
											costs_array.push("£" + parseInteger(config.unit_stats[valid_item_array[x]].costs[y][0]*user_id.modifiers.unit_cost));
										} else if (resource_name.indexOf("_cp") != -1) {
											if (resource_name == "ground_units_cp") {
												cp_string = cp_string + (parseInteger(config.unit_stats[valid_item_array[x]].costs[y][0]*user_id.modifiers.training_cost) + " Army CP");
											} else if (resource_name == "ground_artillery_cp") {
												cp_string = cp_string + (parseInteger(config.unit_stats[valid_item_array[x]].costs[y][0]*user_id.modifiers.training_cost) + " Artillery CP");
											} else if (resource_name == "ground_vehicles_cp") {
												cp_string = cp_string + (parseInteger(config.unit_stats[valid_item_array[x]].costs[y][0]*user_id.modifiers.training_cost) + " Armour CP");
											} else if (resource_name == "naval_units_cp") {
												cp_string = cp_string + (parseInteger(config.unit_stats[valid_item_array[x]].costs[y][0]*user_id.modifiers.training_cost) + " Naval CP");
											} else if (resource_name == "aeroplanes_cp") {
												cp_string = cp_string + (parseInteger(config.unit_stats[valid_item_array[x]].costs[y][0]*user_id.modifiers.training_cost) + " Air CP");
											}
										}
										
										var pop_cost = false;
										for (var z = 0; z < config.pop_array.length; z++) {
											if (resource_name == config.pop_array[z]) {
												pop_cost = true;
												costs_array.pop();
											}
										}
										if (pop_cost) {
											manpower_cost = config.unit_stats[valid_item_array[x]].costs[y][0];
										}
									}
									
									
									if (manpower_cost > 0) {
										manpower_string = " ¦ " + parseInteger(manpower_cost) + " Manpower";
									}
									if (cp_string != "") {
										cp_string = " ¦ " + cp_string;
										manpower_string = manpower_string + cp_string;
									}
									if (config.unit_stats[valid_item_array[x]].colonise_provinces != undefined) {
										manpower_string = " ¦ " + parseInteger(manpower_cost) + " Manpower ¦ Settles " + parseInteger(config.unit_stats[valid_item_array[x]].colonise_provinces);
										if (config.unit_stats[valid_item_array[x]].colonise_provinces > 1) {
											manpower_string = manpower_string + " Provinces";
										} else {
											manpower_string = manpower_string + " Province";
										}
									}
									//Push item to array
									craft_recipe.push("**" + valid_item_array[x] + "** - " + costs_array.join(", ") + manpower_string);
									
									//See if user stats are valid
									if (config.unit_stats[valid_item_array[x]].ap > 0 || config.unit_stats[valid_item_array[x]].dp > 0 || config.unit_stats[valid_item_array[x]].mp > 0 || config.unit_stats[valid_item_array[x]].ip > 0) {
										unit_stat_valid = true;
										var ap_modifier = 0;
										var dp_modifier = 0;
										
										var unit_category = "";
										for (var y = 0; y < config.unit_categories.length; y++) {
											for (var z = 0; z < config[config.unit_categories[y]].length; z++) {
												if (config[config.unit_categories[y]][z] == valid_item_array[x]) {
													unit_category = config.unit_categories[y];
												}
											}
										}
										
										ap_modifier = usr.modifiers[unit_category + "_ap"];
										dp_modifier = usr.modifiers[unit_category + "_dp"];
										
										unit_stat_string = parseInteger(Math.round(config.unit_stats[valid_item_array[x]].ap*ap_modifier)) + " AP - " + parseInteger(Math.round(config.unit_stats[valid_item_array[x]].dp*dp_modifier)) + " DP - " + parseInteger(config.unit_stats[valid_item_array[x]].mp) + " MP - " + parseInteger(config.unit_stats[valid_item_array[x]].ip) + " IP";
									}
									
									if (unit_stat_valid) {
										craft_recipe.push("`" + unit_stat_string + "`");
									}
								}
								
								craft_recipe.push("");
							}
						}
						
						//Split up craft_recipe array into multiple sections
						longMessage(arg1_msg, craft_recipe, 20);
					} else {
						msg.channel.send("You don't even have a country yet!");
					}
				}
			
				function printGovernmentList (arg0_user, arg1_msg) {
					var msg = arg1_msg;
					
					if (main.users[arg0_user] != undefined) {
						var usr = main.users[arg0_user];
						var government_string = [];
						
						government_string.push("**Governments:**");
						government_string.push("------------------");
						government_string.push("Notice: Only governments relevant to you are being shown.");
						government_string.push("");
						
						for (var i = 0; i < usr.available_governments.length; i++) {
							var government = config.governments[usr.available_governments[i]];
							var icon = "";
							var description = "";
							var war_capability = "";
							var has_elections = "";
							if (config.governments[usr.available_governments[i]].icon != undefined) {
								icon = config.governments[usr.available_governments[i]].icon + " ";
							}
							if (config.governments[usr.available_governments[i]].description != undefined) {
								description = " ¦ " + config.governments[usr.available_governments[i]].description;
							}
							if (config.governments[usr.available_governments[i]].can_justify_wars != undefined) {
								if (config.governments[usr.available_governments[i]].can_justify_wars) {
									war_capability = "- Capability to declare wars: Yes.";
								} else {
									war_capability = "- Capability to declare wars by vote only.";
								}
							}
							if (config.governments[usr.available_governments[i]].has_elections != undefined) {
								if (config.governments[usr.available_governments[i]].has_elections) {
									has_elections = "- Has Elections: Yes.";
								} else {
									has_elections = "- Has Elections: No.";
								}
							}
							
							government_string.push(icon + "**" + config.governments[usr.available_governments[i]].name[0] + ":**" + description);
							government_string.push("Type `" + bot_prefix + "government " + usr.available_governments[i] + "` to adopt this system of government.");
							government_string.push("");
							government_string.push(war_capability);
							government_string.push(has_elections);
							government_string.push("- Maximum Manpower: " + parseNumber(government.maximum_manpower*100) + "%.");
							government_string.push("- Maximum Tax Rate: " + parseNumber(government.maximum_tax_rate*100) + "%.");
							government_string.push("- Civilian Actions: " + parseNumber(government.civilian_actions*100) + "%.");
							government_string.push("");
						}
						
						longMessage(msg, government_string, 20);
					} else {
						msg.channel.send("You must have a country in order to view this list!");
					}
				}
			}
		}
		
		//Technology commands
		{
			function addResearchQueue (arg0_user, arg1_name, arg2_message) {
				var msg = arg2_message;
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					var tech_exists = [false, ""];
					//Soft match first
					for (var i = 0; i < config.valid_technologies.length; i++) {
						if (config.valid_technologies[i].toLowerCase().indexOf(arg1_name.toLowerCase()) != -1) {
							tech_exists = [true, config.valid_technologies[i]];
						}
					}
					//Hard match later
					for (var i = 0; i < config.valid_technologies.length; i++) {
						if (config.valid_technologies[i].toLowerCase() == arg1_name.toLowerCase()) {
							tech_exists = [true, config.valid_technologies[i]];
						}
					}
					
					if (tech_exists[0]) {
						var item_already_in_queue = false;
						var item_already_in_research = false;
						
						if (usr.research_queue.length != 0) {
							for (var i = 0; i < usr.research_queue.length; i++) {
								if (usr.research_queue[i] == tech_exists[1]) {
									item_already_in_queue = true;
								}
							}
						}
						if (usr.researching.length > 0) {
							for (var i = 0; i < usr.researching.length; i++) {
								if (usr.researching[i][1] == tech_exists[1]) {
									item_already_in_research = true;
								}
							}
						}
						
						if (usr.research_queue.length < 20) {
							if (item_already_in_queue == false) {
								if (item_already_in_research == false) {
									usr.research_queue.push(tech_exists[1]);
									
									if (msg != "none") {
										msg.channel.send("You have successfully added **" + tech_exists[1].replace(/_/g, " ").replace(/(^\w{1})|(\s{1}\w{1})/g, match => match.toUpperCase()).toLowerCase() + "** to your research queue. Type `" + bot_prefix + "research-queue` to check your current queue.");
									}
								} else {
									if (msg != "none") {
										msg.channel.send("You are already researching this item! Therefore, this technology could not be added to your queue.");
									}
								}
							} else {
								if (msg != "none") {
									msg.channel.send("This item has already been added to your queue! Type `" + bot_prefix + "research-queue` to check your current queue.");
								}
							}
						} else {
							if (msg != "none") {
								msg.channel.send("You have already hit your maximum queue limit! Consider freeing up space by typing `" + bot_prefix + "research-queue`.");
							}
						}
					} else {
						if (msg != "none") {
							msg.channel.send("The tech you have specified proved as elusive as perpetual motion!");
						}
					}
				} else {
					if (msg != "none") {
						msg.channel.send("The person you have specified does not exist!");
					}
				}
			}
			
			function cancelResearch (arg0_user, arg1_slot, arg2_message) {
				var msg = arg2_message;
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					
					if (usr.researching[arg1_slot] != undefined) {
						usr.researching.splice(arg1_slot, 1);
						msg.channel.send("You cancelled your current research for slot **" + parseInt(arg1_slot) + "**. Type `" + bot_prefix + "research list` for a valid list of research options.");
					} else {
						msg.channel.send("This research slot is either already empty, or you haven't defined the slot as a valid number!");
					}
				} else {
					msg.channel.send("You must have a nation before you're able to even conduct research in the first place!");
				}
			}
			
			function printTechList (arg0_user, arg1_message) {
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					var msg = arg1_message;
					var tech_list_array = [];
					
					var tech_array_dump = [];
					var tech_category_techs_available = [];
					
					for (var i = 0; i < config.valid_technologies.length; i++) {
						var tech_available = false;
						
						if (config.technology[config.valid_technologies[i]].prerequisite_techs != undefined) {
							var prerequisite_checks = 0;
							for (var y = 0; y < config.technology[config.valid_technologies[i]].prerequisite_techs.length; y++) {
								if (config.technology[config.technology[config.valid_technologies[i]].prerequisite_techs[y]] == undefined) {
									console.log("[ERROR] " + config.valid_technologies[i] + " has inaccurate prerequisite techs!");
								}
								if (config.technology[config.valid_technologies[i]].prerequisite_techs[y] == config.valid_technologies[i]) {
									console.log("[ERROR] " + config.valid_technologies[i] + " has itself as a prerequisite! Bruh.");
								}
								for (var z = 0; z < usr.researched_technologies.length; z++) {
									if (config.technology[config.valid_technologies[i]].prerequisite_techs[y] == usr.researched_technologies[z]) {
										prerequisite_checks++;
									}
								}
							}
							
							if (prerequisite_checks == config.technology[config.valid_technologies[i]].prerequisite_techs.length) {
								tech_available = true;
							}
						} else { //No prerequisite checks found, so must be a starting tech
							tech_available = true;
						}
						
						//Check if user has already researched tech
						for (var y = 0; y < usr.researched_technologies.length; y++) {
							if (usr.researched_technologies[y] == config.valid_technologies[i]) {
								tech_available = false;
							}
						}
						
						//Append to valid tech dump for later categorisation
						if (tech_available) {
							tech_array_dump.push(config.valid_technologies[i]);
						}
					}
					
					//Eliminate technological categories with no techs in them
					for (var i = 0; i < config.tech_categories.length; i++) {
						tech_category_techs_available.push(0);
						for (var x = 0; x < tech_array_dump.length; x++) {
							if (config.technology[tech_array_dump[x]].category == config.tech_categories[i]) {
								tech_category_techs_available[i]++;
							}
						}
					}
					
					//Begin assembling the tech array by getting all valid tech categories
					
					console.log(tech_array_dump);
					for (var i = 0; i < config.tech_categories.length; i++) {
						var processed_name = config.tech_categories[i].replace(/_/g, " ").replace(/(^\w{1})|(\s{1}\w{1})/g, match => match.toUpperCase());
						if (tech_category_techs_available[i] > 0) {
							tech_list_array.push("<:technology:716812861514711040> **" + processed_name + "**:");
							tech_list_array.push("---");
							tech_list_array.push("");
						}
						
						for (var x = 0; x < tech_array_dump.length; x++) {
							if (config.technology[tech_array_dump[x]].category == config.tech_categories[i]) {
								console.log("Going through " + tech_array_dump[x] + " ...");
								var local_tech = config.technology[tech_array_dump[x]];
								var gfx_icon = "";
								var researching_status = "";
								
								if (usr.researching.length == 0) {
									researching_status = "`" + bot_prefix + "research " + tech_array_dump[x] + "`";
								}
								
								for (var y = 0; y < usr.researching.length; y++) {
									if (usr.researching[y][1] == tech_array_dump[x]) {
										researching_status = "__Researching__";
									}
									
									if (usr.research_queue.length > 0) {
										for (var z = 0; z < usr.research_queue.length; z++) {
											if (usr.research_queue[z] == tech_array_dump[x]) {
												researching_status = "__Queued (#" + (z+1) + ")__";
											}
										}
									}
								}
								
								if (researching_status == "") {
									researching_status = "`" + bot_prefix + "research " + tech_array_dump[x] + "`";
								}
								
								if (local_tech.icon != undefined) {
									gfx_icon = local_tech.icon + " ";
								}
								
								tech_list_array.push(gfx_icon + "**" + tech_array_dump[x].replace(/_/g, " ").replace(/(^\w{1})|(\s{1}\w{1})/g, match => match.toUpperCase()) + "**: " + researching_status);
								
								if (local_tech.description != undefined) {
									tech_list_array.push("");
									tech_list_array.push("_" + local_tech.description + "_");
									tech_list_array.push("");
								}
								
								//Ahead of time penalty calculations
								var aot_penalty = 0;
								var final_aot_penalty = 1;
								var has_aot_penalty = false;
								for (var y = 0; y < config.ahead_of_time.length; y++) {
									if (main.year >= config.ahead_of_time[y][0] && main.year < config.ahead_of_time[y][1]) {
										aot_penalty = 2/config.ahead_of_time[y][2];
									}
								}
								
								if (local_tech.year != undefined) {
									var aot_years = 0;
									
									if (main.year < local_tech.year) {
										has_aot_penalty = true;
										aot_years = local_tech.year-main.year;
										final_aot_penalty = (aot_years*aot_penalty)+1;
									}
									tech_list_array.push("- **Year:** <:time:800548280589221888> " + local_tech.year);
								}
								
								var total_research_cost = Math.round(local_tech.research_cost*final_aot_penalty);
								
								tech_list_array.push("- **Cost:** <:knowledge:716797747193446441> " + parseNumber(total_research_cost));
								
								tech_list_array.push("- **Effects:**");
								
								for (var y = 0; y < local_tech.modifiers.length; y++) {
									tech_list_array.push("      - " + local_tech.modifiers[y]);
								}
								
								//Leads to:
								var leads_to_array = [];
								for (var y = 0; y < config.valid_technologies.length; y++) {
									if (config.technology[config.valid_technologies[y]].prerequisite_techs != undefined) {
										if (config.technology[config.valid_technologies[y]].prerequisite_techs.indexOf(tech_array_dump[x]) != -1) {
											leads_to_array.push("_" + config.valid_technologies[y].replace(/_/g, " ").replace(/(^\w{1})|(\s{1}\w{1})/g, match => match.toUpperCase()) + "_");
										}
									}
								}
								
								if (leads_to_array.length > 0) {
									tech_list_array.push("- **Leads to: **" + leads_to_array.join(", "));
								}
								tech_list_array.push("");
							}
						}
						
						if (tech_category_techs_available[i] > 0) {
							tech_list_array.push("---");
							tech_list_array.push("");
						}
					}
					
					if (tech_list_array.length == 0) {
						tech_list_array.push("_You have researched all available technologies!_");
					}
					
					longMessage(msg, tech_list_array, 30);
				} else {
					arg1_message.channel.send("You need a country in order to be able to conduct research!");
				}
			}
			
			function printResearch (arg0_user, arg1_message) {
				var msg = arg1_message;
				var research_string = [];
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					if (usr.researching.length > 0) {
						var min_knowledge_per_turn = 0;
						var max_knowledge_per_turn = 0;
						var pop_knowledge_gain = 0;
						
						for (var i = 0; i < config.pop_array.length; i++) {
							if (config.pops[config.pop_array[i]].knowledge_per_100k != undefined) {
								pop_knowledge_gain = pop_knowledge_gain + Math.ceil(((usr[config.pop_array[i]]/100000)*config.pops[config.pop_array[i]].knowledge_per_100k));
							}
						}
						
						if (pop_knowledge_gain > 500) { 
							pop_knowledge_gain = 500;
						}
								
						for (var i = 0; i < usr.cities.city_array.length; i++) {
							for (var x = 0; x < config.buildings.length; x++) {
								if (usr.cities[usr.cities.city_array[i]].buildings[config.buildings[x]] > 0) {
									var produces_knowledge = false;
									if (config.building_stats[config.buildings[x]].produces != undefined) {
										for (var y = 0; y < config.building_stats[config.buildings[x]].produces.length; y++) {
											if (config.building_stats[config.buildings[x]].produces[y][1] == "knowledge") {
												if (Array.isArray(config.building_stats[config.buildings[x]].produces[y][0])) {
													min_knowledge_per_turn = min_knowledge_per_turn + config.building_stats[config.buildings[x]].produces[y][0][0]*usr.modifiers.research_efficiency*usr.cities[usr.cities.city_array[i]].buildings[config.buildings[x]];
													max_knowledge_per_turn = max_knowledge_per_turn + config.building_stats[config.buildings[x]].produces[y][0][1]*usr.modifiers.research_efficiency*usr.cities[usr.cities.city_array[i]].buildings[config.buildings[x]];
												} else {
													min_knowledge_per_turn = min_knowledge_per_turn + config.building_stats[config.buildings[x]].produces[y][0]*usr.modifiers.research_efficiency*usr.cities[usr.cities.city_array[i]].buildings[config.buildings[x]];
													max_knowledge_per_turn = max_knowledge_per_turn + config.building_stats[config.buildings[x]].produces[y][0]*usr.modifiers.research_efficiency*usr.cities[usr.cities.city_array[i]].buildings[config.buildings[x]];
												}
											}
										}
									}
								}
							}
						}
								
						min_knowledge_per_turn = Math.ceil(min_knowledge_per_turn) + pop_knowledge_gain;
						max_knowledge_per_turn = Math.ceil(max_knowledge_per_turn) + pop_knowledge_gain;
								
						console.log("Min Knowledge Per Turn: " + min_knowledge_per_turn);
						console.log("Max Knowledge Per Turn: " + max_knowledge_per_turn);
						
						research_string.push("<:technology:716812861514711040> Research Slots: (**" + usr.researching.length + "**/" + usr.modifiers.research_slots + "):");
						research_string.push("To view your research queue, type `" + bot_prefix + "research-queue`.");
						research_string.push("");
						research_string.push("---");
						
						for (var i = 0; i < usr.researching.length; i++) {
							local_min_knowledge_per_turn = Math.ceil(min_knowledge_per_turn/(usr.researching.length));
							local_max_knowledge_per_turn = Math.ceil(max_knowledge_per_turn/(usr.researching.length));
							
							var knowledge_investment = config.max_knowledge_investment*usr.modifiers.knowledge_investment_limit;
							
							if (usr.researching.length == 1) {
								knowledge_investment = 1;
							}
							
							
							if (local_min_knowledge_per_turn > usr.researching[i][2]*knowledge_investment) {
								local_max_knowledge_per_turn = Math.round(usr.researching[i][2]*knowledge_investment);
							}
							if (local_min_knowledge_per_turn > usr.researching[i][2]*knowledge_investment) {
								local_max_knowledge_per_turn = Math.round(usr.researching[i][2]*knowledge_investment);
							}
							
							var turn_string = "";
							var min_turn_string = parseNumber(Math.ceil((usr.researching[i][2]-usr.researching[i][0])/local_min_knowledge_per_turn));
							var max_turn_string = parseNumber(Math.ceil((usr.researching[i][2]-usr.researching[i][0])/local_max_knowledge_per_turn));
							
							if (local_min_knowledge_per_turn == 0 && local_max_knowledge_per_turn == 0) {
								turn_string = "infinite**";
							} else if (min_turn_string == max_turn_string) {
								turn_string = parseNumber(Math.ceil((usr.researching[i][2]-usr.researching[i][0])/local_min_knowledge_per_turn)) + "** ";
							} else {
								turn_string = parseNumber(Math.ceil((usr.researching[i][2]-usr.researching[i][0])/local_min_knowledge_per_turn)) + " - " + parseNumber(Math.ceil((usr.researching[i][2]-usr.researching[i][0])/local_max_knowledge_per_turn)) + "** ";
							}
							
							var icon = "";
							
							if (config.technology[usr.researching[i][1]].icon != undefined) {
								icon = config.technology[usr.researching[i][1]].icon + " ";
							}
							
							research_string.push(icon + "**" + usr.researching[i][1].replace(/_/g, " ").replace(/(^\w{1})|(\s{1}\w{1})/g, match => match.toUpperCase()) + "**: `" + bot_prefix + "cancel-research " + i + "`");
							
							if (config.technology[usr.researching[i][1]].modifiers != undefined) {
								research_string.push("");
								research_string.push("**Effects:**");
								for (var x = 0; x < config.technology[usr.researching[i][1]].modifiers.length; x++) {
									research_string.push("• " + config.technology[usr.researching[i][1]].modifiers[x]);
								}
							}
							
							research_string.push("");
							research_string.push("You have invested **" + parseNumber(usr.researching[i][0]) + "/" + parseNumber(usr.researching[i][2]) + "** <:government:716817688693047306> Knowledge into this technology.");
							research_string.push("Your advisors estimate that it will take **" + turn_string + " turn(s) to finish researching this technology.");
							research_string.push("");
						}
					} else {
						research_string.push("_Nothing is currently being researched._\nFor a valid list of technologies, type `" + bot_prefix + "research list`.");
					}
						
					const research_embed = new Discord.MessageEmbed()
						.setColor('#a98ac7')
						.setAuthor('Triumph & Tragedy:', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
						.setTitle('**Research:\n------------------**')
						.setThumbnail('https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
						.setDescription(research_string.join("\n"))
						.setTimestamp()
						.setFooter('To access this menu again, type ' + bot_prefix + 'research.', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png');
						
					msg.channel.send(research_embed);
				} else {
					msg.channel.send("The person you have specified doesn't even have a nation!");
				}
			}
			
			function printResearchQueue (arg0_user, arg1_message) {
				var msg = arg1_message;
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					var research_queue_string = [];
					
					research_queue_string.push("Your current <:building:716827579650408538> **Research Queue** allows for the consecutive research of multiple technologies, even whilst your asleep. As soon as a technology is researched, any valid technologies in the research queue will take its spot. You must have at least one active research slot for the Research Queue to work, and you may only queue up to **20** technologies.");
					research_queue_string.push("");
					research_queue_string.push("You currently have " + usr.research_queue.length + " items in your research queue.");
					
					if (usr.research_queue.length < 20) {
						research_queue_string.push("Type `" + bot_prefix + "add-research-queue` to add additional technologies to your queue.");
						research_queue_string.push("Type `" + bot_prefix + "cancel-research-queue` to remove technologies from your queue.");
					} else {
						research_queue_string.push("Your **Research Queue** is currently full up!");
					}
					
					research_queue_string.push("");
					research_queue_string.push("---");
					research_queue_string.push("");
					
					if (usr.researching.length > 0) {
						if (usr.research_queue.length != 0) {
							for (var i = 0; i < usr.research_queue.length; i++) {
								var icon = "";
								if (config.technology[usr.research_queue[i]].icon != undefined) {
									icon = config.technology[usr.research_queue[i]].icon + " ";
								}
								research_queue_string.push("**" + (i+1) + ".** " + icon + usr.research_queue[i].replace(/_/g, " ").replace(/(^\w{1})|(\s{1}\w{1})/g, match => match.toUpperCase()));
							}
						} else {
							research_queue_string.push("_You currently have nothing queued up._");
						}
					} else {
						research_queue_string.push("_You must have an active research slot in order for your research queue to become functional!_ Type `" + bot_prefix + "research` to begin researching a technology. Type `" + bot_prefix + "research list` for a list of available technologies.");
					}
					
					const research_queue_embed = new Discord.MessageEmbed()
						.setColor('#a98ac7')
						.setAuthor('Triumph & Tragedy:', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
						.setTitle('**Research Queue:\n------------------**')
						.setThumbnail('https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
						.setDescription(research_queue_string.join("\n"))
						.setTimestamp()
						.setFooter('To access this menu again, type ' + bot_prefix + 'research-queue.', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png');
						
					msg.channel.send(research_queue_embed);
				} else {
					msg.channel.send("Are you sure you're using this command correctly? Type `" + bot_prefix + "add-research-queue` if you wish to add a technology to your research queue, or type `" + bot_prefix + "remove-research-queue` if you wish to remove a technology from it.");
				}
			}
			
			function removeResearchQueue (arg0_user, arg1_id, arg2_message) {
				var msg = arg2_message;
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					if (isNaN(parseInt(arg1_id)-1) == false) {
						if (usr.research_queue[parseInt(arg1_id)-1] != undefined) {
							msg.channel.send("You have removed **" + usr.research_queue[parseInt(arg1_id)-1] + "** from your research queue. Type `" + bot_prefix + "research-queue` for a more updated list of your current technological requests.");
							usr.research_queue.splice((parseInt(arg1_id)-1), 1);
						} else {
							msg.channel.send("That slot was not a valid numeric ID! Type `" + bot_prefix + "research-queue` to check which research orders can be cancelled.");
						}
					} else {
						msg.channel.send("You must specify a valid numeric ID! Type `" + bot_prefix + "research-queue` to check which research orders can be cancelled.");
					}
				} else {
					msg.channel.send("You need to have a nation before you can edit your research queue!");
				}
			}
			
			function research (arg0_user, arg1_technology, arg2_message) {
				//Convert from parameters
				var user_id = arg0_user;
				var technology_name = arg1_technology;
				var msg = arg2_message;
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					var technology_exists = false;
					
					for (var i = 0; i < config.valid_technologies.length; i++) {
						if (config.valid_technologies[i] == technology_name) {
							technology_exists = true;
						}
					}
					
					if (technology_exists) {
						var tech_array_dump = [];
						var tech_category_techs_available = [];
						
						for (var i = 0; i < config.valid_technologies.length; i++) {
							var tech_available = false;
							
							if (config.technology[config.valid_technologies[i]].prerequisite_techs != undefined) {
								var prerequisite_checks = 0;
								for (var y = 0; y < config.technology[config.valid_technologies[i]].prerequisite_techs.length; y++) {
									for (var z = 0; z < usr.researched_technologies.length; z++) {
										if (config.technology[config.valid_technologies[i]].prerequisite_techs[y] == usr.researched_technologies[z]) {
											prerequisite_checks++;
										}
									}
								}
								
								if (prerequisite_checks == config.technology[config.valid_technologies[i]].prerequisite_techs.length) {
									tech_available = true;
								}
							} else { //No prerequisite checks found, so must be a starting tech
								tech_available = true;
							}
							
							//Check if user has already researched tech
							for (var y = 0; y < usr.researched_technologies.length; y++) {
								if (usr.researched_technologies[y] == config.valid_technologies[i]) {
									tech_available = false;
								}
							}
							
							//Append to valid tech dump for later categorisation
							if (tech_available) {
								tech_array_dump.push(config.valid_technologies[i]);
							}
						}
						
						//Execute research function
						
						var can_research = false;
						for (var i = 0; i < tech_array_dump.length; i++) {
							if (tech_array_dump[i] == technology_name) {
								can_research = true;
							}
						}
						
						//Check that technology is not already being researched
						for (var i = 0; i < usr.researching.length; i++) {
							if (usr.researching[i][1] == technology_name) {
								can_research = false;
							}
						}
						
						var found_in_queue = false;
						for (var i = 0; i < usr.research_queue.length; i++) {
							if (usr.research_queue[i] == technology_name) {
								found_in_queue = true;
							}
						}
						
						if (!found_in_queue) {
							if (can_research) {
								if (usr.researching.length < usr.modifiers.research_slots) {
									//Researching array: [[points_invested, technology, total_cost]], e.g. [[20, "fleet_in_being", 1500]]
									//usr.inventory.knowledge = usr.inventory.knowledge - config.technology[technology_name].research_cost;
									var min_knowledge_per_turn = 0;
									var max_knowledge_per_turn = 0;
									var pop_knowledge_gain = 0;
									
									for (var i = 0; i < config.pop_array.length; i++) {
										if (config.pops[config.pop_array[i]].knowledge_per_100k != undefined) {
											pop_knowledge_gain = pop_knowledge_gain + Math.ceil(((usr[config.pop_array[i]]/100000)*config.pops[config.pop_array[i]].knowledge_per_100k));
										}
									}
									
									if (pop_knowledge_gain > 500) {
										pop_knowledge_gain = 500;
									}
									
									for (var i = 0; i < usr.cities.city_array.length; i++) {
										for (var x = 0; x < config.buildings.length; x++) {
											if (usr.cities[usr.cities.city_array[i]].buildings[config.buildings[x]] > 0) {
												var produces_knowledge = false;
												if (config.building_stats[config.buildings[x]].produces != undefined) {
													for (var y = 0; y < config.building_stats[config.buildings[x]].produces.length; y++) {
														if (config.building_stats[config.buildings[x]].produces[y][1] == "knowledge") {
															if (Array.isArray(config.building_stats[config.buildings[x]].produces[y][0])) {
																min_knowledge_per_turn = min_knowledge_per_turn + config.building_stats[config.buildings[x]].produces[y][0][0]*usr.modifiers.research_efficiency*usr.cities[usr.cities.city_array[i]].buildings[config.buildings[x]];
																max_knowledge_per_turn = max_knowledge_per_turn + config.building_stats[config.buildings[x]].produces[y][0][1]*usr.modifiers.research_efficiency*usr.cities[usr.cities.city_array[i]].buildings[config.buildings[x]];
															} else {
																min_knowledge_per_turn = min_knowledge_per_turn + config.building_stats[config.buildings[x]].produces[y][0]*usr.modifiers.research_efficiency*usr.cities[usr.cities.city_array[i]].buildings[config.buildings[x]];
																max_knowledge_per_turn = max_knowledge_per_turn + config.building_stats[config.buildings[x]].produces[y][0]*usr.modifiers.research_efficiency*usr.cities[usr.cities.city_array[i]].buildings[config.buildings[x]];
															}
														}
													}
												}
											}
										}
									}
									
									console.log("Min Knowledge Per Turn: " + min_knowledge_per_turn);
									
									min_knowledge_per_turn = Math.ceil(min_knowledge_per_turn) + pop_knowledge_gain;
									max_knowledge_per_turn = Math.ceil(max_knowledge_per_turn) + pop_knowledge_gain;
									
									min_knowledge_per_turn = Math.ceil(min_knowledge_per_turn/(usr.researching.length+1));
									max_knowledge_per_turn = Math.ceil(max_knowledge_per_turn/(usr.researching.length+1));
								
									var knowledge_investment = config.max_knowledge_investment*usr.modifiers.knowledge_investment_limit;
									
									//Ahead of time penalty calculations
									var aot_penalty = 0;
									var final_aot_penalty = 1;
									var has_aot_penalty = false;
									for (var i = 0; i < config.ahead_of_time.length; i++) {
										if (main.year >= config.ahead_of_time[i][0] && main.year < config.ahead_of_time[i][1]) {
											aot_penalty = 2/config.ahead_of_time[i][2];
										}
									}
									
									if (config.technology[technology_name].year != undefined) {
										var aot_years = 0;
										
										if (main.year < config.technology[technology_name].year) {
											has_aot_penalty = true;
											aot_years = config.technology[technology_name].year-main.year;
											final_aot_penalty = (aot_years*aot_penalty)+1;
										}
									}
									
									var total_research_cost = Math.round(config.technology[technology_name].research_cost*final_aot_penalty);
									
									if (usr.researching.length == 0) {
										knowledge_investment = 1;
									}
									
									if (min_knowledge_per_turn > total_research_cost*knowledge_investment) {
										min_knowledge_per_turn = Math.round(total_research_cost*knowledge_investment);
									}
									if (max_knowledge_per_turn > total_research_cost*knowledge_investment) {
										max_knowledge_per_turn = Math.round(total_research_cost*knowledge_investment);
									}
									
									var turn_string = "";
									if (min_knowledge_per_turn == 0 && max_knowledge_per_turn == 0) {
										turn_string = "forever**";
									} else if (min_knowledge_per_turn == max_knowledge_per_turn) {
										turn_string = parseNumber(Math.ceil(total_research_cost/min_knowledge_per_turn)) + "** turn(s)";
									} else {
										turn_string = parseNumber(Math.ceil(total_research_cost/min_knowledge_per_turn)) + " - " + parseNumber(Math.ceil(total_research_cost/max_knowledge_per_turn)) + "** turn(s)";
									}
									
									if (msg != "none") {
										msg.channel.send("Your scientists have started research on **" + technology_name + "**. Your advisor estimates that it will take them **" + turn_string + " to complete researching this technology.");
									}
									
									usr.researching.push([0, technology_name, total_research_cost]);
								} else {
									if (msg != "none") {
										msg.channel.send("Your research slots are already full up! **" + technology_name + "** was added to your queue instead. Next time, consider typing `" + bot_prefix + "cancel-research <number>` to cancel your current research in one of your slots, or queue up technologies using `" + bot_prefix + "research-queue`.");
									
										//function addResearchQueue (arg0_user, arg1_name, arg2_message) {
										addResearchQueue(user_id, technology_name, "none");
									}
								}
							} else {
								if (msg != "none") {
									msg.channel.send("You don't have the necessary prerequisites to research **" + technology_name + "** yet!");
								}
							}
						} else {
							if (msg != "none") {
								msg.channel.send("You already have this technology active in your research queue! Consider removing it from your queue first before trying to research it.");
							}
							console.log("Found in queue!");
						}
					} else {
						if (msg != "none") {
							if (technology_name.toLowerCase() == "queue") {
								msg.channel.send("Try typing `" + bot_prefix + "research-queue` instead, with a dash in between.");
							} else {
								msg.channel.send("**" + technology_name + "** is not a valid technology that you can currently research!");
							}
						}
					}
				} else {
					if (msg != "none") {
						msg.channel.send("You need to have a nation in order to conduct research!");
					}
				}
			}
		}
		
		//Trade commands
		{
			function autoTrade (arg0_user, arg1_user, arg2_amount, arg3_item, arg4_message) {
				var msg = arg4_message;
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					
					if (main.users[arg1_user] != undefined) {
						if (arg0_user != arg1_user) {
							var ot_user = main.users[arg1_user];
							var item_exists = [false, ""];
							
							for (var i = 0; i < config.materials.length; i++) {
								if (config.materials[i].toLowerCase() == arg3_item.toLowerCase()) {
									item_exists = [true, arg3_item.toLowerCase()];
								}
							}
							if (arg3_item.toLowerCase() == "money") {
								item_exists = [true, "money"];
							}
							
							if (item_exists[0]) {
								if (item_exists[1] != "knowledge") {
									if (isNaN(parseInt(arg2_amount)) == false) {
										if (Math.ceil(arg2_amount) > 0) {
											if (ot_user.blockaded == false) {
												usr.auto_trades.push([ot_user.id, Math.ceil(arg2_amount), item_exists[1]]);
												msg.channel.send("You have begun shipping out **" + parseNumber(Math.ceil(arg2_amount)) + "** " + item_exists[1] + " per turn to the country of **" + ot_user.name + "**.\n\nTo view a list of all your auto-trades, type `" + bot_prefix + "auto-trades`. To see incoming imports, type `" + bot_prefix + "trade`.");
											} else {
												msg.channel.send("You can't send goods to blockaded users!");
											}
										} else if (Math.ceil(arg2_amount) == 0) {
											msg.channel.send("Why did you even try to set up an auto trade ...");
										} else if (Math.ceil(arg2_amount) < 0) {
											msg.channel.send("You can't steal items from other users like that!");
										}
									} else {
										msg.channel.send("You must specify a valid number!");
									}
								} else {
									msg.channel.send("You can't ship out knowledge from your country!");
								}
							} else {
								msg.channel.send("The item you have specified doesn't even exist!");
							}
						} else {
							msg.channel.send("You cannot trade with yourself!");
						}
					} else {
						msg.channel.send("The user you are trying to ship goods to doesn't even exist!");
					}
				} else {
					msg.channel.send("You must have a country before being able to ship out goods across the world!");
				}
			}
		
			function cancelAutoTrade (arg0_user, arg1_id, arg2_message) {
				var msg = arg2_message;
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					var trade_exists = false;
					var index = Math.abs(Math.round(parseInt(arg1_id)));
					
					if (usr.auto_trades.length > 0) {
						if (isNaN(index) == false) {
							if (index >= 0) {
								if (usr.auto_trades[index] != undefined) {
									msg.channel.send("You have cancelled the automatic shipment of **" + usr.auto_trades[index][1] + "** " + usr.auto_trades[index][2] + " to **" + main.users[usr.auto_trades[index][0]].name + "**.\n\nType `" + bot_prefix + "auto-trades` to see an updated list of all your automatic trading.");
									usr.auto_trades.splice(index, 1);
								} else {
									msg.channel.send("The Autotrade ID you have specified is nonexistent! Type `" + bot_prefix + "auto-trades` to see an updated list of all Autotrade IDs.");
								}
							} else {
								msg.channel.send("IDs less than zero do not exist!");
							}
						} else {
							msg.channel.send("You must type a valid number!");
						}
					} else {
						msg.channel.send("You currently have no ongoing auto-trades!");
					}
				} else {
					msg.channel.send("You can't cancel the trades of a nonexistent nation!");
				}
			}
			
			function printAutoTrades (arg0_user, arg1_message) {
				var msg = arg1_message;
				
				if (main.users[arg0_user] != undefined) {
					var usr = main.users[arg0_user];
					var auto_trade_prefix = [];
					var auto_trade_suffix = [];
					var auto_trade_string = [];
					
					auto_trade_prefix.push("<:taxes:716817688781127810> **Auto-Trades** are shipments of goods that occur automatically from your nation to another country. These goods are shipped out once per turn.\n\nTo cancel an auto-trade, type `" + bot_prefix + "cancel-auto-trade`.\nTo create a new auto-trade, type `" + bot_prefix + "auto-trade`.");
					auto_trade_prefix.push("---");
					auto_trade_prefix.push("");
					
					auto_trade_suffix.push("");
					auto_trade_suffix.push("To return to the trade menu, type `" + bot_prefix + "trade`.");
					
					var auto_trade_embeds = [];
					
					if (usr.auto_trades.length > 0) {
						for (var i = 0; i < usr.auto_trades.length; i++) {
							console.log("DEBUG LOG: " + usr.auto_trades[i]);
							var icon = "";
							for (var x = 0; x < config.materials.length; x++) {
								if (config.materials[x] == usr.auto_trades[i][2]) {
									icon = config.resource_icons[x];
								}
							}
							
							auto_trade_string.push("Exporting " + icon + " " + parseNumber(usr.auto_trades[i][1]) + " " + usr.auto_trades[i][2] + " to **" + main.users[usr.auto_trades[i][0]].name + "** each turn.");
							auto_trade_string.push("`" + bot_prefix + "cancel-auto-trade " + i + "`");
						}
						
						var local_auto_trade_string = [];
						
						if (auto_trade_string.length > 0) {
							for (var i = 0; i < auto_trade_string.length; i++) {
								local_auto_trade_string.push(auto_trade_string[i]);
								if (i != 0 || auto_trade_string.length == 1) {
									if (i % 20 == 0 || i == auto_trade_string.length-1) {
										const embed_trade = new Discord.MessageEmbed()
											.setColor('#a98ac7')
											.setAuthor('Triumph & Tragedy:', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
											.setTitle('**Auto-Trades:\n------------------**')
											.setThumbnail('https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
											.setDescription(auto_trade_prefix.join("\n") + local_auto_trade_string.join("\n") + "\n" + auto_trade_suffix.join("\n"))
											.setTimestamp()
											.setFooter('To access this menu again, type ' + bot_prefix + 'auto-trades.', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png');
											
										auto_trade_embeds.push(embed_trade);
										local_auto_trade_string = [];
									}
								}
							}
						}
						
						scrollMessage(msg, auto_trade_embeds, 0);
					} else {
						const embed_trade = new Discord.MessageEmbed()
							.setColor('#a98ac7')
							.setAuthor('Triumph & Tragedy:', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
							.setTitle('**Auto-Trades:\n------------------**')
							.setThumbnail('https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
							.setDescription(auto_trade_prefix.join("\n") + "_You currently have no ongoing auto-trades._" + "\n" + auto_trade_suffix.join("\n"))
							.setTimestamp()
							.setFooter('To access this menu again, type ' + bot_prefix + 'auto-trades.', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png');
							
						auto_trade_embeds.push(embed_trade);
						scrollMessage(msg, auto_trade_embeds, 0);
					}
				} else {
					msg.channel.send("You must have a nation in order to conduct automatic trading with other countries!");
				}
			}
		}
		
		function modifyItem (arg0_user, arg1_amount, arg2_item, arg3_mode) {
			var current_user = arg0_user.toString();
			
			if (arg3_mode == "add") {
				if (main.users[current_user] == undefined) {
					initUser(current_user);
					main.users[current_user].inventory[arg2_item] = main.users[current_user].inventory[arg2_item] + parseInt(arg1_amount);
				} else {
					main.users[current_user].inventory[arg2_item] = main.users[current_user].inventory[arg2_item] + parseInt(arg1_amount);
				}
			} else if (arg3_mode == "remove") {
				if (main.users[current_user] == undefined) {
					initUser(current_user);
					main.users[current_user].inventory[arg2_item] = main.users[current_user].inventory[arg2_item] - parseInt(arg1_amount);
				} else {
					main.users[current_user].inventory[arg2_item] = main.users[current_user].inventory[arg2_item] - parseInt(arg1_amount);
				}
			}
		}
		
		function give (arg0_user, arg1_user2, arg2_amount, arg3_item, arg4_mode, arg5_message) {
			var msg = arg5_message;
			
			if (main.users[arg0_user] != undefined) {
				var resource_name = arg3_item.toLowerCase();
				var usr = main.users[arg0_user];
				var other_usr_id = arg1_user2.replace(/(<)(@)(!)/g, "");
				var other_usr_id = arg1_user2.replace(/(<)(@)/g, "");
				var other_usr = main.users[other_usr_id];
				
				var inventory = main.users[arg0_user].inventory;
				console.log(other_usr_id);
				
				var ceiled_amount = Math.abs(Math.ceil(arg2_amount));
				if (arg0_user != arg1_user2) {
					if (ceiled_amount > 0) {
						if (arg4_mode == "item") {
							if (resource_name == "money") {
								if (usr.money >= ceiled_amount) {
									var distance = moveTo(usr.capital_id.toString(), other_usr.capital_id.toString()).length;
									var amount_of_turns = Math.ceil((config.base_transfer_time+(distance/config.shipment_time))*usr.modifiers.shipment_time);
									usr.trade_array.push([[parseInt(ceiled_amount), "money"], other_usr_id, amount_of_turns]);
									usr.money = usr.money - parseInt(ceiled_amount);
									//base_transfer_time + shipment_time
									if (arg5_message != "none") {
										arg5_message.channel.send("Your transports have begun to ship " + parseNumber(ceiled_amount) + " " + resource_name + " to <@" + other_usr_id + ">. They will arrive in **" + amount_of_turns + "** turns.");
									}
								} else {
									if (arg5_message != "none") {
										arg5_message.channel.send("You were unable to execute this command due to a shortage of money.");
									}
								}
							} else if (resource_name == "knowledge") {
								if (arg5_message != "none") {
									arg5_message.channel.send("You can't send knowledge as a resource!");
								}
							} else {
								var item_exists = false;
								for (var i = 0; i < config.materials.length; i++) {
									if (resource_name == config.materials[i]) {
										item_exists = true;
									}
								}
								if (item_exists) {
									if (inventory[resource_name] >= ceiled_amount) {
										var items_in_transfer = 0;
										
										for (var i = 0; i < usr.trade_array.length; i++) {
											var actual_resource = false;
											for (var x = 0; x < config.materials.length; x++) {
												if (config.materials[x] == usr.trade_array[i][0][1]) {
													actual_resource = true;
												}
											}
											
											if (actual_resource) {
												items_in_transfer = items_in_transfer + usr.trade_array[i][0][0];
											}
										}
										
										if ((ceiled_amount+items_in_transfer) <= usr.modifiers.shipment_capacity) {
											var distance = moveTo(usr.capital_id.toString(), other_usr.capital_id.toString()).length;
											var amount_of_turns = Math.ceil((config.base_transfer_time+(distance/config.shipment_time))*usr.modifiers.shipment_time);
											usr.inventory[resource_name] = usr.inventory[resource_name] - parseInt(ceiled_amount);
											usr.trade_array.push([[parseInt(ceiled_amount), resource_name], other_usr_id, amount_of_turns]);
											//base_transfer_time + shipment_time
											if (arg5_message != "none") {
												arg5_message.channel.send("Your transports have begun to ship " + ceiled_amount + " " + resource_name + " to <@" + other_usr_id + ">. They will arrive in **" + amount_of_turns + "** turns.");
											}
										} else {
											if (arg5_message != "none") {
												msg.channel.send("You don't have enough shipment capacity remaining to transport these goods! You currently have **" + parseNumber(items_in_transfer) + "** items in transfer, compared to your **" + parseNumber(usr.modifiers.shipment_capacity) + "** Shipment Capacity, allowing you to only ship up to **" + parseNumber(usr.modifiers.shipment_capacity-items_in_transfer) + "** more items.");
											}
										}
									} else {
										if (arg5_message != "none") {
											arg5_message.channel.send("You were unable to execute this command due to a shortage of items.");
										}
									}
								} else {
									if (arg5_message != "none") {
										arg5_message.channel.send("The item you are trying to send is nonexistent!");
									}
								}
							}
						} else if (arg4_mode == "industry") {
							var building_exists = false;
							for (var i = 0; i < config.buildings.length; i++) {
								if (resource_name == config.buildings[i]) {
									building_exists = true;
								}
							}
							if (building_exists) {
								if (usr.buildings[resource_name] >= ceiled_amount) {
									usr.buildings[resource_name] = parseInt(usr.buildings[resource_name]) - parseInt(ceiled_amount);
									other_usr.buildings[resource_name] = parseInt(other_usr.buildings[resource_name]) + parseInt(ceiled_amount);
									if (arg5_message != "none") {
										arg5_message.channel.send("You gave <@" + other_usr_id + "> " + ceiled_amount + " " + resource_name + ".");
									}
								} else {
									if (arg5_message != "none") {
										arg5_message.channel.send("You were unable to execute this command due to a shortage of buildings.");
									}
								}
							} else {
								if (arg5_message != "none") {
									arg5_message.channel.send("The item you are trying to send is nonexistent!");
								}
							}
						}
					} else if (ceiled_amount == 0) {
						if (arg5_message != "none") {
							msg.channel.send("You can't give zero units of something!");
						}
					} else {
						if (arg5_message != "none") {
							msg.channel.send("You can't steal from other users!");
						}
					}
				} else {
					if (arg5_message != "none") {
						msg.channel.send("You can't give stuff to yourself!");
					}
				}
			} else {
				if (arg5_message != "none") {
					arg5_message.channel.send("The person you are trying to give items to doesn't even have a country!");
				}
			}
		}
	}
	
	//Logic
	{
		function writeSave () {
			//ABRS - Automated Backup and Restoration System
			{
				var d = new Date();
				var current_year = d.getFullYear();
				var current_month = d.getMonth()+1;
				var current_day = d.getDate();
				
				if (current_month < 10) {
					current_month = "0" + current_month;
				}
				if (current_day < 10) {
					current_day = "0" + current_day;
				}
				
				var current_hours = d.getHours();
				var current_minutes = d.getMinutes();
				var current_seconds = d.getSeconds();
								
				if (current_hours < 10) {
					current_hours = "0" + current_hours;
				}
				if (current_minutes < 10) {
					current_minutes = "0" + current_minutes;
				}
				if (current_seconds < 10) {
					current_seconds = "0" + current_seconds;
				}
									
				if (JSON.stringify(main).length != 0) {
					var create_backup = fs.createWriteStream("./backups/" + current_day + "." + current_month + "." + current_year + " " + current_hours + "." + current_minutes + "." + current_seconds + ".txt");
					create_backup.end();
						
					fs.writeFile("./backups/" + current_day + "." + current_month + "." + current_year + " " + current_hours + "." + current_minutes + "." + current_seconds + ".txt", JSON.stringify(main), function (err,data) {
						if (err) {
							return console.log(err);
						}
						//console.log(data);
					});
				} else {
					loadMostRecentSave();
				}
			}
		}
		
		function destroyBlockades () {
			//Destroy blockades that have no existant fleets remaining
			var all_blockades = Object.keys(main.users.global.blockades);
			console.log("Blockade object keys: " + all_blockades);
			console.log("Blockade arrays object: ");
			console.log(main.users.global.blockade_arrays);
			for (var i = 0; i < all_blockades.length; i++) {
				//Remove all nonexistent fleets from the main blockade array first
				console.log("Fleets: " + main.users.global.blockades[all_blockades[i]]);
				for (var x = 0; x < main.users.global.blockades[all_blockades[i]].length; x++) {
					var fleet_exists = false;
					var fleet_name = main.users.global.blockades[all_blockades[i]][x];

					for (var y = 0; y < main.user_array.length; y++) {
						var local_usr = main.users[main.user_array[y]];
						if (local_usr.armies[fleet_name] != undefined) {
							fleet_exists = true;
						}
					}

					if (fleet_exists == false) {
						console.log(fleet_name + "'s existence could not be detected!");
						main.users.global.blockades[all_blockades[i]].splice(x, 1);
					}
				}
				for (var x = 0; x < main.users.global.blockade_arrays[all_blockades[i]].length; x++) {
					var user_has_navies_in_blockade = false;
					var local_usr = main.users[main.users.global.blockade_arrays[all_blockades[i]][x]];
					
					for (var y = 0; y < local_usr.armies.army_array.length; y++) {
						for (var z = 0; z < main.users.global.blockades[all_blockades[i]].length; z++) {
							if (local_usr.armies.army_array[y] == main.users.global.blockades[all_blockades[i]][z]) {
								user_has_navies_in_blockade = true;
							}
						}
					}

					if (user_has_navies_in_blockade == false) {
						console.log("User was not detecting as having navies in the blockade!");
						main.users.global.blockade_arrays[all_blockades[i]].splice(x, 1);
					}
				}
				if (main.users.global.blockade_arrays[all_blockades[i]].length == 0) {
					main.users[all_blockades[i]].blockaded = false;
					delete main.users.global.blockades[all_blockades[i]];
					delete main.users.global.blockade_arrays[all_blockades[i]];
				}
			}
		}
		
		function returnYear (arg0_number) {
			var current_year = arg0_number;
			//Check for seasons
			var last_digits = current_year % 1;
			var season = "";
			if (current_year >= 1914) {
				if (last_digits == 0) {
					season = "Winter ";
				} else if (last_digits == 0.25) {
					season = "Spring ";
				} else if (last_digits == 0.5) {
					season = "Summer ";
				} else if (last_digits == 0.75) {
					season = "Autumn ";
				}
			}
			
			return (season + Math.floor(current_year)).toString();
		}
		
		setTimeout(function(){
			console.log("[Triumph & Tragedy] is ready to recieve data requests!");
			setTimeout(function(){
				if (backup_loaded) {
					console.log("Conducting one-time force render!");
					forceRender("political");
				}
			},10000);
			setInterval(function(){
				//Check if a turn has passed
				if (main.lastTurn == undefined) {
					main.lastTurn = new Date().getTime();
				} else {
					var current_date = new Date().getTime();
					var time_difference = current_date - main.lastTurn;
					
					//Initialise global if not defined
					if (main.users.global == undefined) {
						initGlobal();
					}
					
					//World Market Up-Logic
					{
						if (main.user_array.length > 0) {
							var market = main.users.global;
							for (var i = 0; i < config.resource_list.length; i++) {
								var local_resource = config.resource_list[i][0];
								if (market[local_resource + "_buy_price"] < market[local_resource + "_sell_price"]*1.2) {
									market[local_resource + "_buy_price"] = Math.ceil(market[local_resource + "_buy_price"]*1.2);
								}
								
								if ((market[local_resource + "_buy_price"] < config.resource_min_buy_price) || isNaN(market[local_resource + "_buy_price"])) {
									market[local_resource + "_buy_price"] = config.resource_min_buy_price;
								}
								if ((market[local_resource + "_sell_price"] < config.resource_min_sell_price) || isNaN(market[local_resource + "_sell_price"])) {
									market[local_resource + "_sell_price"] = config.resource_min_sell_price;
								}
							}
						}
					}
					
					//War Logic, add casualties
					{
						checkWars();
						var all_wars = Object.keys(main.users.global.wars);
						//console.log("WARS: " + main.users.global.wars);
						//console.log("ALL WARS: " + all_wars);
						
						for (var i = 0; i < all_wars.length; i++) {
							main.users.global.wars[all_wars[i]].attacker_total_casualties = 0;
							main.users.global.wars[all_wars[i]].defender_total_casualties = 0;
							var attacker_war_exhaustion = 0;
							var defender_war_exhaustion = 0;
							
							for (var x = 0; x < main.users.global.wars[all_wars[i]].attackers.length; x++) {
								if (main.users.global.wars[all_wars[i]][main.users.global.wars[all_wars[i]].attackers[x] + "_casualties"] == undefined) {
									main.users.global.wars[all_wars[i]][main.users.global.wars[all_wars[i]].attackers[x] + "_casualties"] = 0;
								} else {
									main.users.global.wars[all_wars[i]].attacker_total_casualties = main.users.global.wars[all_wars[i]].attacker_total_casualties + main.users.global.wars[all_wars[i]][main.users.global.wars[all_wars[i]].attackers[x] + "_casualties"];
								}
								attacker_war_exhaustion = attacker_war_exhaustion + main.users[main.users.global.wars[all_wars[i]].attackers[x]].modifiers.war_exhaustion;
							}
							for (var x = 0; x < main.users.global.wars[all_wars[i]].defenders.length; x++) {
								if (main.users.global.wars[all_wars[i]][main.users.global.wars[all_wars[i]].defenders[x] + "_casualties"] == undefined) {
									main.users.global.wars[all_wars[i]][main.users.global.wars[all_wars[i]].defenders[x] + "_casualties"] = 0;
								} else {
									main.users.global.wars[all_wars[i]].defender_total_casualties = main.users.global.wars[all_wars[i]].defender_total_casualties + main.users.global.wars[all_wars[i]][main.users.global.wars[all_wars[i]].defenders[x] + "_casualties"];
								}
								defender_war_exhaustion = defender_war_exhaustion + main.users[main.users.global.wars[all_wars[i]].defenders[x]].modifiers.war_exhaustion;
							}
							
							//Ensure that user is not double crossing or in conflict with themselves
							for (var x = 0; x < main.users.global.wars[all_wars[i]].attackers.length; x++) {
								var is_on_both_sides = false;
								for (var y = 0; y < main.users.global.wars[all_wars[i]].defenders.length; y++) {
									if (main.users.global.wars[all_wars[i]].defenders[y] == main.users.global.wars[all_wars[i]].attackers[x]) {
										is_on_both_sides = true;
									}
								}
								
								if (is_on_both_sides) {
									//Check whether to keep it on the attacking or defending side
									if (main.users.global.wars[all_wars[i]].original_attacker == main.users.global.wars[all_wars[i]].attackers[x]) {
										removeParticipant(main.users.global.wars[all_wars[i]].attackers[x], all_wars[i], "defenders");
									} else { //Automatically the defender
										removeParticipant(main.users.global.wars[all_wars[i]].attackers[x], all_wars[i], "attackers");
									}
								}
							}
						}
						
						//Blockades
						var all_blockade_arrays = Object.keys(main.users.global.blockade_arrays);
						var all_blockades = Object.keys(main.users.global.blockades);
						
						for (var i = 0; i < all_blockade_arrays.length; i++) {
							if (main.users.global.blockade_arrays[all_blockade_arrays[i]].length == 0) {
								delete main.users.global.blockade_arrays[all_blockade_arrays[i]];
							}
						}
						for (var i = 0; i < all_blockades.length; i++) {
							if (main.users.global.blockades[all_blockades[i]].length == 0) {
								delete main.users.global.blockades[all_blockades[i]];
								main.users[all_blockades[i]].blockaded = false;
								returnChannels.send(war_channel, "**The blockade on <@" + main.users[all_blockades[i]].id + "> was lifted.**");
							}
						}
					}
					
					//Battle Logic/Battle Tick
					{
						var battle_difference = current_date - main.users.global.battle_tick;
						if (battle_difference > (turn_timer*1000)/10) {
							//Test if any armies between warring nations are in the same province
							main.users.global.battle_tick = current_date;
							
							cacheSVG();
							writeSave();
							for (var i = 0; i < main.user_array.length; i++) {
								var usr = main.users[main.user_array[i]];
								
								if (usr.armies.army_array.length > 0 && usr.at_war.length > 0) {
									for (var x = 0; x < usr.armies.army_array.length; x++) {
										var in_combat = false;
										//Check for hostile armies in the same province
										for (var y = 0; y < usr.at_war.length; y++) {
											for (var z = 0; z < main.user_array.length; z++) {
												for (var a = 0; a < main.users[main.user_array[z]].armies.army_array.length; a++) {
													if (main.users[main.user_array[z]].name == usr.at_war[y]) {
														//Checked that user is hostile, scan through each of their armies and see if they share a province position
														if (main.users[main.user_array[z]].armies[main.users[main.user_array[z]].armies.army_array[a]].province == usr.armies[usr.armies.army_array[x]].province) {
															//Conduct battle tick for province
															//function combat (arg0_user, arg1_army, arg2_user, arg3_army, arg4_province, arg5_msg) { 
															//$combat [@def. user] [army name] [@att. user] [army name] [province]
															var defending_user = "";
															var attacking_user = "";
															var defending_army = "";
															var attacking_army = "";
															
															if (main.users[main.user_array[z]].armies[main.users[main.user_array[z]].armies.army_array[a]].stationary_turns > usr.armies[usr.armies.army_array[x]].stationary_turns) {
																defending_user = main.user_array[z];
																defending_army = main.users[main.user_array[z]].armies.army_array[a];
																attacking_user = usr.id;
																attacking_army = usr.armies.army_array[x];
															} else {
																defending_user = usr.id;
																defending_army = usr.armies.army_array[x];
																attacking_user = main.user_array[z];
																attacking_army = main.users[main.user_array[z]].armies.army_array[a];
															}
															
															if (main.users[main.user_array[z]].armies[main.users[main.user_array[z]].armies.army_array[a]].name != "deleted-army" && usr.armies[usr.armies.army_array[x]].name != "deleted-army") {
																if (main.users[main.user_array[z]].armies[main.users[main.user_array[z]].armies.army_array[a]].type != "navy" && usr.armies[usr.armies.army_array[x]].type != "navy") {
																	combat(defending_user, defending_army, attacking_user, attacking_army, usr.armies[usr.armies.army_array[x]].province.toString(), "none");
																	in_combat = true;
																}
															}
														}
													}
												}
											}
										}
										
										var hostile_province = false;
										var hostile_owner = "";
										var army_obj = usr.armies[usr.armies.army_array[x]];
										
										for (var y = 0; y < usr.at_war.length; y++) {
											for (var z = 0; z < main.user_array.length; z++) {
												//Scan for all hostile enemies
												if (main.users[main.user_array[z]].name == usr.at_war[y]) {
													//Scan through all provinces
													for (var a = 0; a < main.users[main.user_array[z]].pops.pop_array.length; a++) {
														if (main.users[main.user_array[z]].pops.pop_array[a] == army_obj.province) {
															hostile_province = true;
															hostile_owner = main.user_array[z];
														}
													}
												}
											}
										}
										
										if (!in_combat && hostile_province) {
											var is_city = false;
											
											//Check if province is home to an enemy city
											try {
												for (var y = 0; y < main.users[hostile_owner].cities.city_array.length; y++) {
													var city_obj = main.users[hostile_owner].cities[main.users[hostile_owner].cities.city_array[y]];
													
													if (city_obj != undefined) {
														if (city_obj.province == army_obj.province) {
															is_city = true;
														}
													}
												}
												
												var already_occupied = false;
												
												for (var y = 0; y < main.users.global.occupations.length; y++) {
													if (main.users.global.occupations[y][0] == army_obj.province.toString() && main.users.global.occupations[y][2] == usr.id) {
														already_occupied = true;
														main.users.global.occupations.splice(y, 1);
														console.log(main.users.global.occupations);
													}
												}
												
												if (!already_occupied) {
													//Check to make sure that the user has enough occupation manpower to carry out its occupation
													var army_size_in_province = getTroopCountInProvince(army_obj.province.toString(), usr.id);
													
													//Error trapping in case of invalid pop objects
													if (army_size_in_province >= getProvince(army_obj.province.toString()).population*0.005) {
														main.users.global.occupations.push([army_obj.province.toString(), is_city, hostile_owner, usr.id]);
														transferProvince(hostile_owner, army_obj.province, usr.id, "none");
													}
												}
											} catch (e) {
												console.log(hostile_owner + " was not valid!");
												console.log(e);
											}
										}
									}
								}
							}
							
							destroyBlockades();
						}
					}
					
					if (time_difference > turn_timer*1000) {
						writeSave();
						
						if (main.roundCount == undefined) {
							main.roundCount = 0;
						} else {
							main.roundCount++;
						}
						
						if (main.year < 1750) {
							main.year = main.year + 2;
						} else {
							if (main.year >= 1914) {
								main.year = main.year + 0.25;
							} else {
								main.year++;
							}
						}
						
						if (main.user_array.length > 0) {
							for (var x = 0; x < main.user_array.length; x++) {
								if (main.users[main.user_array[x]].last_active_turn >= main.roundCount-config.inactive_turns || main.users[main.user_array[x]].at_war.length > 0) { 
									nextTurn(main.user_array[x]);
								}
								processEvents(main.user_array[x]);
							}
							writeSVGS();
						}
							
						//World Market Down-Logic
						{
							if (main.user_array.length > 0) {
								var market = main.users.global;
								for (var i = 0; i < config.resource_list.length; i++) {
									var local_resource = config.resource_list[i][0];
									
									//If no one cares about a good enough, the prices will come down
									if (market[local_resource + "_amount_sold"] < 5 && market[local_resource + "_stock"] >= Math.ceil(config.resource_base_stock*0.1)) {
										if (market[local_resource + "_buy_price"] > 100 && market[local_resource + "_sell_price"] > 100) {
											market[local_resource + "_buy_price"] = Math.ceil(market[local_resource + "_buy_price"]*0.8);
											market[local_resource + "_sell_price"] = Math.ceil(market[local_resource + "_sell_price"]*0.8);
										}
									} else {
										market[config.resource_list[i][0] + "_buy_price"] = Math.ceil(market[config.resource_list[i][0] + "_buy_price"]*(randomNumber(103, 108)/100));
										if (market[config.resource_list[i][0] + "_sell_price"] > 100 && market[local_resource + "_amount_sold"] < 5) market[config.resource_list[i][0] + "_sell_price"] = Math.ceil(market[config.resource_list[i][0] + "_sell_price"]*(randomNumber(92, 97)/100));
									}
									
									//Reset amount sold this turn
									market[local_resource + "_amount_sold"] = 0;
								}
							}
						}
							
						//console.log('[Country Battle] A turn has elapsed!');
						console.log(announcements_channel);
						returnChannels.send(announcements_channel, ping_role_id + " A turn has elapsed! It is now round **" + main.roundCount + "**.\nWelcome to the year of our Lord, **" + returnYear(main.year) + "**.");
						main.lastTurn = current_date;
							
						for (var x = 0; x < news.length; x++) {
							if (news[x].length > 0) returnChannels.send(announcements_channel, news[x]);
						}
						
						news = [];
						setTimeout(function(){
							cacheSVG();
							setTimeout(function(){
								for (var i = 0; i < map_channel.length; i++) {
									displaySVG(returnChannel(map_channel[i]));
								}
							},2000);
						},3000);
					}
				}
				
				for (var x = 0; x < main.user_array.length; x++) {
					initUser(main.user_array[x]);
				}
				
			}, 100);
			
			//3 Seconds, command queue logic loop
			setInterval(function(){
				//Send command every 3 seconds, if found
				if (command_queue.length > 0) {
					sendCommand(command_queue[0][0], command_queue[0][1], command_queue[0][2], command_queue[0][3]);
					command_queue.splice(0, 1);
				}
				returnChannel("878418099177680917").send("<@759981761609859072> <@904084665797845053>").then((msg) => { msg.delete(); });
			}, 3000);
			
			//30 Seconds, slower logic loop
			setInterval(function(){
				fs.writeFile('database.js', JSON.stringify(main), function (err,data) {
					if (err) {
						return console.log(err);
					}
					//console.log(data);
				});
			}, 30000);
		},3000);
	}
}

//Reaction Logic
{
	const removeReaction = async (m, msg, emoji) => {
		console.log(msg.author.id);
		try { m.reactions.cache.find(r => r.emoji.name == emoji).users.remove(msg.author.id); } catch (err) { console.log(err); }
	}

	function resetReactions (msg) {
		msg.reactions.removeAll().catch(error => console.error('Failed to clear reactions: ', error));
	}

	var help_page_array = []; //lmao
	var data_prompt_array = {
		current_key: 0
	};

	const awaitReactions = async (msg, m, options, filter) => {
		const { min, max, arg1_embeds, limit, type, data_id, prompt_string } = options;
		
		if (type == "help message") {
			m.awaitReactions(filter, { max: 1, time: limit, errors: ["time"] }).then(async (collected) => {
				async function arrowReset () {
					if (help_page_array[data_id] == min) {
						resetReactions(m);
						await m.react("➡️");
					} else if (help_page_array[data_id] == max) {
						resetReactions(m);
						await m.react("⬅️");
					} else {
						if (help_page_array[data_id] == min+1 || help_page_array[data_id] == max-1) {
							resetReactions(m);
							await m.react("⬅️");
							await m.react("➡️");
						}
					}
				}
				const reaction = collected.first();
				console.log("Page ID: " + data_id);
				
				if (reaction.emoji.name === "⬅️") {
					await removeReaction(m, msg, "⬅️");
					console.log("Page backwards");
					
					//Check if the page can go back
					if (help_page_array[data_id] != min) {
						help_page_array[data_id]--;
						await m.edit(arg1_embeds[help_page_array[data_id]]);
						arrowReset();
					}
					
					//Loop back and wait for a new reaction
					awaitReactions(msg, m, options, filter);
				} else if (reaction.emoji.name === "➡️") {
					await removeReaction(m, msg, "➡️");
					console.log("Page forwards");
					
					//Check if the page can go forwards
					if (help_page_array[data_id] != max) {
						help_page_array[data_id]++;
						await m.edit(arg1_embeds[help_page_array[data_id]]);
						arrowReset();
					}
					
					//Loop back and wait for a new reaction
					awaitReactions(msg, m, options, filter);
				} else {
					awaitReactions(msg, m, options, filter);
				}
				
				console.log(help_page_array[data_id]);
			}).catch((err) => { console.log(err) });
		}
	}
}

const removeReaction = async (m, msg, emoji) => {
	console.log(msg.author.id);
	try { m.reactions.cache.find(r => r.emoji.name == emoji).users.remove(msg.author.id); } catch (err) { console.log(err); }
}

function resetReactions (msg) {
	msg.reactions.removeAll().catch(error => console.error('Failed to clear reactions: ', error));
}

var help_page_array = []; //lmao
var data_prompt_array = {
	current_key: 0
};

const awaitReactions = async (msg, m, options, filter) => {
	const { min, max, arg1_embeds, limit, type, data_id, prompt_string } = options;
	
	if (type == "help message") {
		m.awaitReactions(filter, { max: 1, time: limit, errors: ["time"] }).then(async (collected) => {
			async function arrowReset () {
				if (help_page_array[data_id] == min) {
					resetReactions(m);
					await m.react("➡️");
				} else if (help_page_array[data_id] == max) {
					resetReactions(m);
					await m.react("⬅️");
				} else {
					if (help_page_array[data_id] == min+1 || help_page_array[data_id] == max-1) {
						resetReactions(m);
						await m.react("⬅️");
						await m.react("➡️");
					}
				}
			}
			const reaction = collected.first();
			console.log("Page ID: " + data_id);
			
			if (reaction.emoji.name === "⬅️") {
				await removeReaction(m, msg, "⬅️");
				console.log("Page backwards");
				
				//Check if the page can go back
				if (help_page_array[data_id] != min) {
					help_page_array[data_id]--;
					await m.edit(arg1_embeds[help_page_array[data_id]]);
					arrowReset();
				}
				
				//Loop back and wait for a new reaction
				awaitReactions(msg, m, options, filter);
			} else if (reaction.emoji.name === "➡️") {
				await removeReaction(m, msg, "➡️");
				console.log("Page forwards");
				
				//Check if the page can go forwards
				if (help_page_array[data_id] != max) {
					help_page_array[data_id]++;
					await m.edit(arg1_embeds[help_page_array[data_id]]);
					arrowReset();
				}
				
				//Loop back and wait for a new reaction
				awaitReactions(msg, m, options, filter);
			} else {
				awaitReactions(msg, m, options, filter);
			}
			
			console.log(help_page_array[data_id]);
		}).catch((err) => { console.log(err) });
	}
}

//Reaction Framework
async function scrollMessage (arg0_msg, arg1_embeds, arg2_starting_page) {
	var temp_page_id = help_page_array.length;
	
	var starting_page = 0;
	if (arg2_starting_page != undefined) {
		starting_page = arg2_starting_page;
	}
	
	help_page_array.push(starting_page);
	
	const options = {
		limit: 600 * 1000,
		min: 0,
		max: arg1_embeds.length-1,
		arg1_embeds: arg1_embeds,
		type: "help message",
		data_id: temp_page_id,
		prompt_string: ""
	}
	
	console.log("STARTING PAGE:");
	console.log(arg1_embeds[starting_page]);
	const m = await arg0_msg.channel.send(arg1_embeds[starting_page]);
	
	if (arg1_embeds.length > 1) {
		if (arg2_starting_page == 0) {
			await m.react("➡️");
		} else if (arg2_starting_page != 0 && arg2_starting_page != arg1_embeds.length-1) {
			await m.react("⬅️");
			await m.react("➡️");
		} else {
			await m.react("⬅️");
		}
	}
	
	const filter = (reaction, user) => {
		return ["⬅️", "➡️"].includes(reaction.emoji.name) && user.id == arg0_msg.author.id && user.id != client.user.id;
	}
							
	awaitReactions(arg0_msg, m, options, filter);
}

async function printNumberPrompt (arg0_msg, arg1_prompt, arg2_min, arg3_max, arg4_data_key) {
	//Number, [Debug], Confirmation
	
	const options = {
		limit: 600 * 1000,
		min: arg2_min,
		max: arg3_max,
		prompt_string: arg1_prompt
	}
	
	const m = await arg0_msg.channel.send(arg1_prompt + "\nType `cancel` to cancel this command.");
	
	//Text input as number
	console.log(arg0_msg.author.id);
	const stringFilter = a => a.author.id === arg0_msg.author.id;
	
	//Regular input
	const collector = arg0_msg.channel.createMessageCollector(stringFilter, { time: 60000000 });
	
	collector.on("collect", a => {
		console.log("Number collected: " + parseInt(a.content));
		if (a.content.indexOf(bot_prefix) == -1) {
			if (a.content.toLowerCase() == "cancel") {
				data_prompt_array[arg4_data_key] = "cancelled";
				data_prompt_array[arg0_msg.author.id + "_dialogue_open"] = false;
				data_prompt_array[arg0_msg.author.id + "_channel_open"] = "";
				collector.stop();
			} else if (Array.isArray(data_prompt_array[arg4_data_key])) {
				if (isNaN(parseInt(a.content))) {
					m.channel.send("You must specify a valid number!");
					console.log("Not recognised as number.");
				} else {
					console.log("Recognised as number.");
					if (parseInt(a.content) < options.min) {
						m.channel.send("The number you have specified was too small! The smallest number you can use is **" + options.min + "**.");
					} else if (parseInt(a.content) > options.max) {
						m.channel.send("The number you have specified was too large! The largest number you may use is **" + options.max + "**.");
					} else {
						console.log("Number output: " + Math.ceil(parseInt(a.content)));
						if (data_prompt_array[arg4_data_key] == undefined) {
							data_prompt_array[arg4_data_key] = [Math.ceil(parseInt(a.content))];
						} else {
							data_prompt_array[arg4_data_key].push(Math.ceil(parseInt(a.content)));
						}
						collector.stop();
					}
				}
			}
		}
	});
	
	collector.on("end", a => {
		if (a.size == 0) {
			data_prompt_array[arg4_data_key].push(arg2_min);
		}
	});
}

async function printStringPrompt (arg0_msg, arg1_prompt, arg2_minimum, arg3_maximum, arg4_data_key, arg5_mention) {
	//Number, [Debug], Confirmation
	
	const options = {
		limit: 600 * 1000
	}
	
	const m = await arg0_msg.channel.send(arg1_prompt + "\nType `cancel` to cancel this command.");
	
	//Text input
	console.log(arg0_msg.author.id);
	const stringFilter = a => a.author.id === arg0_msg.author.id;
	
	//Regular input
	const collector = arg0_msg.channel.createMessageCollector(stringFilter, { time: 60000000 });
	
	collector.on("collect", a => {
		if (a.content.indexOf(bot_prefix) == -1) {
			if (a.content.toLowerCase() == "cancel") {
				data_prompt_array[arg4_data_key] = "cancelled";
				data_prompt_array[arg0_msg.author.id + "_dialogue_open"] = false;
				data_prompt_array[arg0_msg.author.id + "_channel_open"] = "";
				collector.stop();
			} else if (Array.isArray(data_prompt_array[arg4_data_key])) {
				console.log(a.content + "\nLength: " + a.content.length);
				if (a.content.length >= arg2_minimum) {
					if (a.content.length <= arg3_maximum) {
						
						if (arg5_mention == undefined) {
							if (data_prompt_array[arg4_data_key] == undefined) {
								data_prompt_array[arg4_data_key] = [a.content];
								collector.stop();
							} else {
								data_prompt_array[arg4_data_key].push(a.content);
								console.log("Input collected: " + a.content);
								collector.stop();
							}
						} else {
							if (parseNumber(parseInt(returnMention(a.content))) != "NaN") {
								if (data_prompt_array[arg4_data_key] == undefined) {
									data_prompt_array[arg4_data_key] = [returnMention(a.content)];
									collector.stop();
								} else {
									console.log("Mention: " + returnMention(a.content));
									data_prompt_array[arg4_data_key].push(returnMention(a.content));
									console.log("Mention was returned as: " + returnMention(a.content));
									collector.stop();
								}
							} else {
								m.channel.send("You must ping a valid user!");
							}
						}
					} else {
						m.channel.send("The text you have specified exceeded the maximum of **" + arg3_maximum + "** characters!");
					}
				} else {
					m.channel.send("The text you have specified must at least be **" + arg2_minimum + "** characters in length!");
				}
			}
		}
	});
	
	collector.on("end", a => {
		if (Array.isArray(data_prompt_array[arg4_data_key])) {
			if (a.size == 0) {
				if (arg5_mention != true) {
					data_prompt_array[arg4_data_key].push("");
				} else {
					data_prompt_array[arg4_data_key].push("213287117017710593");
				}
			}
		}
	});
}

async function getArguments (arg0_msg, arg1_prompts, arg2_code) {
	var msg = arg0_msg;
	
	/*
	Building prompt (as an example):
	
	arg1_prompts: [
		["text", "**Which city would you like to place your buildings in?**\nUse `$city-list` for a list of cities."], 
		["text", "**Which building would you like to build?**\nUse `$build list` for a valid list of buildings."], 
		["number", "**How many buildings would you like to build?", "minimum: 1"]
	]
	*/
	
	//Logic Loop - Hacky, but convenient
	
	if (data_prompt_array[msg.author.id + "_dialogue_open"] == false || data_prompt_array[msg.author.id + "_dialogue_open"] == undefined) {
		var command_executed = false;
		var arguments_fetched = 0;
		var prompts_sent = [];
		var data_key = data_prompt_array.current_key;
		
		for (var i = 0; i < arg1_prompts.length; i++) {
			prompts_sent.push(false);
		}
		
		data_prompt_array.current_key++;
		data_prompt_array[data_key] = [];
		data_prompt_array[msg.author.id + "_dialogue_open"] = true;
		data_prompt_array[msg.author.id + "_channel_open"] = msg.channel.id;
		
		setInterval(function(){
			if (command_executed == false) {
				arguments_fetched = data_prompt_array[data_key].length;
				
				if (Array.isArray(data_prompt_array[data_key])) {
					if (arguments_fetched < arg1_prompts.length) {
						var argument_type = arg1_prompts[arguments_fetched][0];
						
						if (argument_type == "number") {
							var has_minimum = [false, 1]; //lol 64 bit limit
							var has_maximum = [false, 18446744073709551616];
							
							for (var i = 0; i < arg1_prompts[arguments_fetched].length; i++) {
								if (arg1_prompts[arguments_fetched][i].match(/(minimum:)+/)) {
									has_minimum[0] = true;
									has_minimum[1] = parseInt(arg1_prompts[arguments_fetched][i].replace(/(minimum:)+/, ""));
								} else if (arg1_prompts[arguments_fetched][i].match(/(maximum:)+/)) {
									has_maximum[0] = true;
									has_maximum[1] = parseInt(arg1_prompts[arguments_fetched][i].replace(/(maximum:)+/, ""));
								}
							}
							
							//Send numeric prompt only once
							if (prompts_sent[arguments_fetched] == false) {
								printNumberPrompt(msg, arg1_prompts[arguments_fetched][1].replace(/\$/g, bot_prefix), has_minimum[1], has_maximum[1], data_key);
							}
							prompts_sent[arguments_fetched] = true;
						} else if (argument_type == "text") {
							var has_minimum = [false, 1];
							var has_maximum = [false, 2000];
							
							for (var i = 0; i < arg1_prompts[arguments_fetched].length; i++) {
								if (arg1_prompts[arguments_fetched][i].match(/(minimum:)+/)) {
									has_minimum[0] = true;
									has_minimum[1] = parseInt(arg1_prompts[arguments_fetched][i].replace(/(minimum:)+/, ""));
								} else if (arg1_prompts[arguments_fetched][i].match(/(maximum:)+/)) {
									has_maximum[0] = true;
									has_maximum[1] = parseInt(arg1_prompts[arguments_fetched][i].replace(/(maximum:)+/, ""));
								}
							}
							
							//Send textual prompt only once
							if (prompts_sent[arguments_fetched] == false) {
								console.log("Minimum: " + has_minimum[1]);
								printStringPrompt(msg, arg1_prompts[arguments_fetched][1].replace(/\$/g, bot_prefix), has_minimum[1], has_maximum[1], data_key);
							}
							prompts_sent[arguments_fetched] = true;
						} else if (argument_type == "mention") {
							//Send mention prompt only once
							if (prompts_sent[arguments_fetched] == false) {
								printStringPrompt(msg, arg1_prompts[arguments_fetched][1].replace(/\$/g, bot_prefix), 1, 2000, data_key, true);
							}
							prompts_sent[arguments_fetched] = true;
						}
					} else {
						var author_id = (main.users.global.user_map[msg.author.id]) ? main.users.global.user_map[msg.author.id] : msg.author.id;
						var arg = data_prompt_array[data_key];
						
						eval(arg2_code);
						command_executed = true;
						data_prompt_array[msg.author.id + "_dialogue_open"] = false;
						data_prompt_array[msg.author.id + "_channel_open"] = "";
					}
				} else {
					msg.channel.send("<:cancel:725550245672517734> Command cancelled.");
					command_executed = true;
					data_prompt_array[msg.author.id + "_dialogue_open"] = false;
					data_prompt_array[msg.author.id + "_channel_open"] = "";
				}
			}
		},100);
	} else {
		msg.channel.send("<:cancel:725550245672517734> You already have a command open! Type `cancel` (in lowercase letters) in <#" + data_prompt_array[msg.author.id + "_channel_open"] + "> before issuing this command again!");
	}
}

//Reactions, mostly for the map viewer
client.on('messageReactionAdd', (reaction, user) => {
	var current_message = reaction.message.id;
	if (user.bot == false) {
		var is_map_viewer = [false, ""];
		var all_maps = Object.keys(open_maps);
		for (var i = 0; i < all_maps.length; i++) {
			for (var x = 0; x < open_maps[all_maps[i]].message_collectors.length; x++) {
				if (current_message == open_maps[all_maps[i]].message_collectors[x]) {
					is_map_viewer = [true, all_maps[i]];
				}
			}
		}
		
		if (is_map_viewer[0]) {
			var map_obj = open_maps[is_map_viewer[1]];
			
			if (map_obj.user == user.id) {
				if (reaction.emoji.name == "⬆️") {
					map_obj.up_arrow = true;
				} else if (reaction.emoji.name == "⬅️") {
					map_obj.left_arrow = true;
				} else if (reaction.emoji.name == "⬇️") {
					map_obj.down_arrow = true;
				} else if (reaction.emoji.name == "➡️") {
					map_obj.right_arrow = true;
				} else if (reaction.emoji.name == "zoom_in") {
					map_obj.zoom_in = true;
				} else if (reaction.emoji.name == "zoom_out") {
					map_obj.zoom_out = true;
				}
			}
			reaction.users.remove(user.id);
		}
		
		//Administrator
		console.log(user);
		if (user.id == "507021242663043082" && reaction.emoji.name == "❌") reaction.message.delete();
	}
});

client.on('message', async (message) => {
	//Get arguments
	var arg = [];
	
	//Initialisation end
	
	username = message.author.username;
	actual_id = message.author.id;
	user_id = message.author.id;
    input = message.content;
	
	//Check for override_id and user_map
	user_id = (override_id && user_id == bot_id) ? override_id : user_id;
	user_id = (main.users.global.user_map[user_id]) ? main.users.global.user_map[user_id] : user_id;
	
	//Parse arguments
	var temp_arg = message.content.replace(/ +(?= )/g, "");
	temp_arg = temp_arg.split("");
	
	//Check for quotation marks
	function splitCommandLine(commandLine) {
		var spaceMarker = '<SP>';
		while( commandLine.indexOf(spaceMarker) > -1 ) spaceMarker += '@';

		var noSpacesInQuotes = commandLine.replace(/"([^"]*)"?|“([^"]*)“?|“([^"]*)”?|”([^"]*)“?/g, (fullMatch, capture) => {
			return capture.replace(/ /g, spaceMarker);
		});
		
		var mangledParamArray = noSpacesInQuotes.split(/ +/) ;
		var paramArray = mangledParamArray.map((mangledParam) => {
			return mangledParam.replace(RegExp(spaceMarker, 'g'), ' ') ;
		});

		return paramArray;
	}
	
	arg = splitCommandLine(message.content);
	
	if (!message.author.bot) {
		console.log("Author: " + username);
		console.log(input);
		console.log("Arguments: " + arg.join(", "));
		console.log(bot_prefix);
	}
	
	var not_blacklisted = true;
	var ping_everyone = false;
	if (config.blacklist != undefined) {
		for (var i = 0; i < config.blacklist.length; i++) {
			if (config.blacklist[i] == returnMention(user_id)) {
				not_blacklisted = false;
			}
		}
	}
	
	if (message.content.indexOf("@everyone") != -1 || message.content.indexOf("@here") != -1) {
		ping_everyone = true;
	}
	
	//Artificially cache user
	if (main.users[returnMention(user_id)] && user_id != bot_id) main.users[returnMention(user_id)].username = username;
	
	var has_authorised_role = false;
	var has_player_role = false;
	var proper_channel = true;
	
	//Check if channel is proper if guild is Midnight
	proper_channel = !(message.guild.id == "548994743925997570" && !command_channel.includes(message.channel.id));
	
	for (var i = 0; i < authorised_role.length; i++) {
		if (hasRole(message, authorised_role[i])) {
			has_authorised_role = true;
			proper_channel = true;
		}
	}
	for (var i = 0; i < player_role.length; i++) {
		if (hasRole(message, player_role[i])) {
			has_player_role = true;
		}
	}
	
	if (arg[0].indexOf(bot_prefix) != -1 && not_blacklisted && ping_everyone == false && proper_channel) {
		if (main.users[returnMention(user_id)] != undefined) {
			var usr = main.users[returnMention(user_id)];
			usr.last_active_turn = main.roundCount;
		}
		//General commands
		{
			//Help commands
			{
				if (equalsIgnoreCase(arg[0], "customisation") || equalsIgnoreCase(arg[0], "customization") || equalsIgnoreCase(arg[0], "customise") || equalsIgnoreCase(arg[0], "customize") || equalsIgnoreCase(arg[0], "customisations") || equalsIgnoreCase(arg[0], "customizations")) { //$customisation
					var nation_warning = "";
					//Declare instance variables
					var locked_vassals_string = "",
						vassal_customisation_string = "";
						
					if (main.users[returnMention(user_id)] == undefined) {
						nation_warning = "_You don't have a nation yet! Type_ `" + bot_prefix + "found <nation name>` _to get started._\n\n";
					} else {
						var usr = main.users[returnMention(user_id)];
						
						if (usr.vassals.length > 0) {
							locked_vassals_string = (usr.vassal_customisation_locked) ? "---\n\n" + [
								"<:consciousness:758424911852470293> **You have decided to lock vassal customisation.** Your vassals will no longer be able to customise their nations or cities until you type `$unlock-vassal-customisation`.",
								""
							].join("\n").replace(/\$/g, bot_prefix) : "---\n\n" + [
								"<:checkmark:725550245051760671> **Vassal customisation is currently unlocked!** Your vassals are free to customise their nations and cities at any time until you type `$lock-vassal-customisation`.",
								""
							].join("\n").replace(/\$/g, bot_prefix);
							
							vassal_customisation_string = [
								"<:globe:716811246556545035> **Rename Vassal:** `$rename-vassal <vassal> <name>`",
								"Force 'em to change their name, free of charge!",
								"",
								"<:old_map:716821884867444746> **Rename Vassal City:** `$rename-vassal-city <city> <name>`",
								"Don't like the name of one of their cities? Change it, and assert your dominance.",
								"",
								"<:culture:758424912049864784> **Rename Vassal Culture:** `$rename-vassal-culture <vassal> <name>`",
								"Not a fan of their culture? Invent some new word for it.",
								"",
								"<:government:716817688693047306> **Change Vassal Colour:** `$set-vassal-colour <vassal> <r> <g> <b>`",
								"Now they'll be shown on the map in a glorious shade of ... uh, something.",
								"",
								"<:infamy:716817688453709905> **Change Vassal Flag:** `$set-vassal-flag <vassal> <image URL>`",
								"Nothing quite says you own them as much as slapping your flag on top of theirs.",
								"",
								"<:paper:759161240987369522> **Change Vassal Motto:** `$set-vassal-motto <vassal> <motto>`",
								"Decree that they use your motto!"
							].join("\n").replace(/\$/g, bot_prefix);
						}
					}
					
					var customisation_help_warning = [
						nation_warning + "<:old_map:716821884867444746> **Rename Your Nation:** `$rename <name>`", 
						"Messed up? Change your country's name.",
						"",
						"<:old_scroll:716828676880334881> **Change Your Motto:** `$set-motto <motto>`",
						"A new slogan to inspire the masses.",
						"",
						"<:infamy:716817688453709905> **Import A New Flag:** `$set-flag <image URL>`",
						"For that flag I die!",
						"",
						"<:government:716817688693047306> **Set Your Nation's Colour:** `$set-colour <r> <g> <b>`",
						"Change your nation's colour to something else using RGB colour codes.",
						"",
						"<:culture:758424912049864784> **Customise Your Culture:** `$rename-culture <name>`",
						"A new label by which to identify your people.",
						"",
						locked_vassals_string,
						vassal_customisation_string
					].join("\n").replace(/\$/g, bot_prefix);
					
					const embed_customisation = new Discord.MessageEmbed()
						.setColor('#a98ac7')
						.setAuthor('Triumph & Tragedy:', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
						.setTitle('**Customisation Menu:\n------------------**')
						.setThumbnail('https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
						.setDescription(customisation_help_warning)
						.setTimestamp()
						.setFooter('To access this menu again, type $customisation.', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png');
					
					message.channel.send(embed_customisation);
				}
				
				if (equalsIgnoreCase(arg[0], "help") || equalsIgnoreCase(arg[0], "commands")) { //$help
					var nation_warning = "";
					if (main.users[returnMention(user_id)] == undefined) {
						nation_warning = "_You don't have a nation yet! Type_ `" + bot_prefix + "found <nation name>` _to get started._\n\n";
					}
					
					var general_help_string = (nation_warning + "<:old_map:716821884867444746> **Nation Overview:** `$overview`\nAccess your nation's interface.\n\n<:old_scroll:716828676880334881> **Create A Nation:** `$found <name>`\nFound a new nation.\n> <:gold_mines:772296532930068540> **Claim An AI Country:** `$claim-country <name>`\n> Did an AI take your country already? Type out its name in order to claim it!\n\n<:building:716827579650408538> **Next Round:** `$next-round`\nCheck the amount of time remaining until the next round.\n\n<:knowledge:716797747193446441> **Read The Tutorial:** `$tutorial`\nMenu whisked by too fast? Read the tutorial again!\n\n<:provinces:716809229603700737> **View Province:** `$view-province <id>`\nTake a look at the availability and statistics of a province.").replace(/\$/g, bot_prefix);
					const embed_help = new Discord.MessageEmbed()
						.setColor('#a98ac7')
						.setAuthor('Triumph & Tragedy:', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
						.setTitle('**Help Menu:\n------------------**')
						.setThumbnail('https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
						.setDescription(general_help_string)
						.setTimestamp()
						.setFooter('To access this menu again, type $help.', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png');
								
					message.channel.send(embed_help);
				}
				
				if (equalsIgnoreCase(arg[0], "admin-help")) {
					if (has_authorised_role) {
						var admin_help_string = (":ship: `$blockade <@user>`\nToggle a user's blockade status.\n\n:guardsman: `$battle <@user> <attacking army> <@user> <defending army> <Province ID>`\nInitiate a battle in the selected province.\n\n:inbox_tray: `$create <@user> [number] <material>`\nGive resources to a player.\n\n:computer: `$eval <key> <value>`\nHighly unstable command used for editing player data values.\n\n:outbox_tray: `$remove <@user> [int] <material>`\nSubtract resources from a player's inventory.\n\n:clock: `$reset-rounds`\nReset the rounds on the server.\n\n:game_die: `$roll [min] <max>`\nRoll some dice.\n\n:speech_balloon: `$set-announcements-channel <Channel ID>`\nSet the announcements channel to a certain ID.\n\n:pencil: `$set-prefix <string>`\nChange the bot prefix. **Warning!** Help command strings will not be changed.\n\n:clock: `$set-round-time <seconds>`\nChange the round time.\n\n:park: `$transfer-province <@receiving country> <@original country> <Province ID>`\nTransfer a province between users.").replace(/\$/g, bot_prefix);
						const embed_help = new Discord.MessageEmbed()
							.setColor('#a98ac7')
							.setAuthor('Triumph & Tragedy:', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
							.setTitle('**Admin Help Menu:\n------------------**')
							.setThumbnail('https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png')
							.setDescription(admin_help_string)
							.setTimestamp()
							.setFooter('To access this menu again, type $admin-help.', 'https://media.discordapp.net/attachments/432295472598614028/712203943241056326/unknown.png');
								
						message.channel.send(embed_help);
					} else {
						message.channel.send("You do not have permissions to carry out this command!");
					}
				}
				
				if (equalsIgnoreCase(arg[0], "tutorial")) {
					if (arg.length == 1) {
						printTutorial(message);
					} else {
						printTutorial(message, arg[1]);
					}
				}
			}
			
			if (equalsIgnoreCase(arg[0], "roll")) { //$roll
				if (arg.length == 2) {
					//message.channel.send
					if (arg[1].indexOf("-") == -1) { //$roll arg1
						message.channel.send("You rolled a **" + randomNumber(1, parseInt(arg[1])) + "**.");
					} else { //$roll arg1-arg2
						var subargs = arg[1].split("-");
						message.channel.send("You rolled a **" + randomNumber(subargs[0], subargs[1]) + "**.");
					}
				} else if (arg.length == 3) {
					message.channel.send("You rolled a **" + randomNumber(parseInt(arg[1]), parseInt(arg[2])) + "**.");
				}
			}
			
			if (equalsIgnoreCase(arg[0], "parse-armies")) {
				if (arg.length > 1) {
					var full_name = [];
					for (var i = 1; i < arg.length; i++) {
						full_name.push(arg[i]);
					}
					message.channel.send(parseOrdinals(full_name.join(" ")));
				} else {
					getArguments(message,
						[
							["text", "**Please enter a valid army argument:**"],
						],
						'msg.channel.send(parseOrdinals(arg[0]));'
					);
				}
			}
		}
		
		//Administrative commands (Cheats)
		{
			if (has_authorised_role) {
				if (equalsIgnoreCase(arg[0], "add-pops")) { //$add-pops [@user] <number> <pops>
					if (arg.length == 3) {
						var target_user = returnMention(user_id);
						addPops(target_user, arg[1], arg[2]);
					} else if (arg.length > 3) {
						var target_user = returnMention(arg[1]);
						addPops(target_user, arg[2], arg[3]);
					} else {
						message.channel.send("Invalid amount of arguments.");
					}
				}
				
				if (equalsIgnoreCase(arg[0], "assume-control")) { //$assume-control [@user] <@user>
					if (arg.length == 2) {
						var target_user = returnMention(user_id);
						assumeControl(target_user, returnMention(arg[1]), message);
					} else if (arg.length > 2) {
						if (arg[1].match("^[0-9]+$")) {
							if (arg[1].length > 2) {
								assumeControl(arg[1], returnMention(arg[2]), message);
							} else {
								message.channel.send("Numeric IDs must have at least 3 characters in order to be accepted as valid!");
							}
						} else {
							message.channel.send("Please specify numeric IDs instead.");
						}
					} else {
						message.channel.send("Invalid amount of arguments specified.");
					}
				}
				
				if (equalsIgnoreCase(arg[0], "console")) { //$console <JS>
					var full_code = [];
					for (var i = 1; i < arg.length; i++) {
						full_code.push(arg[i]);
					}
					var quick_script = full_code.join(" ").toString();
					eval(quick_script);
					message.channel.send("Console command executed. Warning! This command can be highly unstable if not used correctly.");
				}
				
				if (equalsIgnoreCase(arg[0], "create")) { //$create @user int material
					if (arg.length > 1) {
						var target_user = returnMention(arg[1]);
						var material_exists = false;
						
						for (var i = 0; i < config.materials.length; i++) {
							if (config.materials[i] == arg[3]) {
								material_exists = true;
							}
						}
						
						if (material_exists) { //Execute command
							modifyItem(target_user, arg[2], arg[3], "add");
							console.log(JSON.stringify(main));
							message.channel.send("You gave " + arg[2] + " " + arg[3] + " to <@!" + target_user + ">.");
						} else {
							message.channel.send("Material '" + arg[3] + "' was not found.");
						}
					} else {
						message.channel.send("Invalid amount of arguments!");
					}
				}
				
				if (equalsIgnoreCase(arg[0], "create-all-materials")) { //$create-all-materials <@user> <int>
					var target_user = returnMention(user_id);
					if (arg.length == 2) {
						createAllMaterials(target_user, arg[1], message);
					} else if (arg.length > 2) {
						target_user = returnMention(arg[1]);
						createAllMaterials(target_user, arg[2], message);
					} else {
						message.channel.send("Invalid amount of arguments!");
					}
				}
				
				if (equalsIgnoreCase(arg[0], "create-wargoal")) { //$create-wargoal <@user> <wargoal>
					var target_user = returnMention(user_id);
					if (arg.length >= 3) {
						addWargoal(target_user, returnMention(arg[1]), arg[2], message);
					} else {
						message.channel.send("Invalid amount of arguments specified. Try typing `" + bot_prefix + "create-wargoal <@user> <wargoal name>`.");
					}
				}
				
				if (equalsIgnoreCase(arg[0], "delete-country") || equalsIgnoreCase(arg[0], "delete-nation")) { //$delete-country <@user>
					if (arg.length >= 2) {
						var target_user = returnMention(arg[1]);
						deleteCountry(target_user, message);
						message.channel.send("<@" + target_user + "> was deleted as a nation.");
					} else {
						message.channel.send("Invalid amount of arguments specified.");
					}
				}
				
				if (equalsIgnoreCase(arg[0], "deoublier") || equalsIgnoreCase(arg[0], "deoublien") || equalsIgnoreCase("normalise")) { //$deoublier <@user>
					if (arg.length > 1) {
						var target_user = returnMention(arg[1]);
						deoublier(target_user, message);
					} else {
						message.channel.send("Sperie improper! Sucen soi sted `" + bot_prefix + "deoublier <@Gleder>`.");
					}
				}
				
				if (equalsIgnoreCase(arg[0], "disable-cede")) {
					if (arg.length >= 1) {
						var target_user = returnMention(arg[1]);
						
						if (main.users[target_user].cede_disabled) {
							main.users[target_user].cede_disabled = false;
							message.channel.send("You have enabled cede-province for this user.");
						} else {
							main.users[target_user].cede_disabled = true;
							message.channel.send("You have disabled cede-province for this user.");
						}
					} else {
						message.channel.send("Invalid amount of arguments specified. Try typing `$disable-cede <@user>` instead.");
					}
				}
				
				if (equalsIgnoreCase(arg[0], "disable-demolish")) {
					if (arg.length >= 1) {
						var target_user = returnMention(arg[1]);
						
						if (main.users[target_user].demolish_disabled) {
							main.users[target_user].demolish_disabled = false;
							message.channel.send("You have enabled demolition for this user.");
						} else {
							main.users[target_user].demolish_disabled = true;
							message.channel.send("You have disabled demolition for this user.");
						}
					} else {
						message.channel.send("Invalid amount of arguments specified. Try typing `$disable-cede <@user>` instead.");
					}
				}
				
				if (equalsIgnoreCase(arg[0], "display-map")) { //$display-map
					var target_user = returnMention(user_id);
					writeSVGS();
					setTimeout(function(){
						cacheSVG();
					},500);
					setTimeout(function(){
						displaySVG(message.channel);
					},2000);
				}
				
				if (equalsIgnoreCase(arg[0], "eval")) { //$eval <@user> [property] [value]
					if (arg.length == 4) {
						var target_user = returnMention(arg[1]);
						eval("main.users['" + target_user + "']" + arg[2] + " = " + arg[3] + ";");
						message.channel.send("Eval command executed. Warning! This command can be highly unstable if not used correctly.");
					}
				}
				
				if (equalsIgnoreCase(arg[0], "force-rename")) { //$force-rename <@user> <name>
					var target_user = returnMention(user_id);
					
					if (arg.length > 2) {
						forceRename(returnMention(arg[1]), arg[2], message);
					} else if (arg.length == 2) {
						forceRename(target_user, arg[1], message);
					} else {
						message.channel.send("Invalid amount of arguments specified. Try using the command like so: `" + bot_prefix + "force-rename <@user> <new name>`.");
					}
				}
				
				if (equalsIgnoreCase(arg[0], "init-ai")) { //$init-ai <name>
					if (arg.length >= 2) {
						var full_name = [];
						for (var i = 1; i < arg.length; i++) {
							full_name.push(arg[i]);
						}
						var ai_initialisation = initAI(full_name.join(" "), true);
						message.channel.send("**" + full_name.join(" ") + "** has been successfully initiated as AI!");
					} else {
						getArguments(message,
							[
								["text", "**What is the ID of the AI you would like to initialise?**"]
							],
							'var ai_initialisation = initAI(arg[0], true); msg.channel.send("**" + arg[0] + "** successfully initialised as AI!");'
						);
					}
				}
				
				if (equalsIgnoreCase(arg[0], "init-all-ai")) { //$init-all-ai
					initAllAI(message);
				}
				
				if (equalsIgnoreCase(arg[0], "instant-build")) { //$instant-build <@user> <city> <number> <building>
					var target_user = returnMention(user_id);
					//instantBuild (arg0_user, arg1_city, arg2_amount, arg3_building, arg4_message)
					if (arg.length == 3) { //$instant-build <building> <city>
						instantBuild(target_user, arg[2], 1, arg[1], message);
					} else if (arg.length == 4) { //$instant-build <@user> <building> <city>
						target_user = returnMention(arg[1]);
						instantBuild(target_user, arg[3], 1, arg[2], message);
					} else if (arg.length > 4) { //$instant-build <@user> <amount> <building> <city>
						target_user = returnMention(arg[1]);
						instantBuild(target_user, arg[4], parseInt(arg[2]), arg[3], message);
					} else {
						message.channel.send("Invalid amount of arguments specified. Try using the command like so: `" + bot_prefix + "instant-build [@user] [number] <building> <city name>`.");
					}
				}
				
				if (equalsIgnoreCase(arg[0], "instant-research")) { //$instant-research <@user> <tech>
					var target_user = returnMention(user_id);
					if (arg.length == 2) {
						instantResearch(target_user, arg[1], message);
					} else if (arg.length > 2) {
						target_user = returnMention(arg[1]);
						instantResearch(target_user, arg[2], message);
					} else {
						message.channel.send("Invalid amount of arguments! Try using the command like this instead: `" + bot_prefix + "instant-research [@user] <technology>`.");
					}
				}
				
				if (equalsIgnoreCase(arg[0], "lett-delt") || equalsIgnoreCase(arg[0], "delete-msg") || equalsIgnoreCase("delete-message")) { //$delete-message <@user>
					if (arg.length > 1) {
						var message_id = arg[1];
						deleteMessage(message_id, message, (arg[2]) ? arg[2] : "ne");
					} else {
						message.channel.send("Sperie improper! Sucen soi sted `" + bot_prefix + "lett-delt <@Lett-ID> [Lett sper]`.");
					}
				}
				
				if (equalsIgnoreCase(arg[0], "lock-all")) { //$lock-all <@user>
					var target_user = returnMention(user_id);
					
					if (arg.length > 1) {
						lockAll(returnMention(arg[1]), "lock", message);
					} else {
						lockAll(target_user, "lock", message);
					}
				}
				
				if (equalsIgnoreCase(arg[0], "lock-colour")) { //$lock-colour <@user>
					var target_user = returnMention(user_id);
					
					if (arg.length > 1) {
						lockColour(returnMention(arg[1]), message);
					} else {
						lockColour(target_user, message);
					}
				}
				
				if (equalsIgnoreCase(arg[0], "lock-culture")) { //$lock-culture <@user>
					var target_user = returnMention(user_id);
					
					if (arg.length > 1) {
						lockCulture(returnMention(arg[1]), message);
					} else {
						lockCulture(target_user, message);
					}
				}
				
				if (equalsIgnoreCase(arg[0], "lock-flag")) { //$lock-flag <@user>
					var target_user = returnMention(user_id);
					
					if (arg.length > 1) {
						lockFlag(returnMention(arg[1]), message);
					} else {
						lockFlag(target_user, message);
					}
				}
				
				if (equalsIgnoreCase(arg[0], "lock-name")) { //$lock-name <@user>
					var target_user = returnMention(user_id);
					
					if (arg.length > 1) {
						lockName(returnMention(arg[1]), message);
					} else {
						lockName(target_user, message);
					}
				}
				
				if (equalsIgnoreCase(arg[0], "oublier") || equalsIgnoreCase(arg[0], "oublien") || equalsIgnoreCase("cordon-solitaire")) { //$oublier <@user>
					if (arg.length > 1) {
						var target_user = returnMention(arg[1]);
						oublier(target_user, message);
					} else {
						message.channel.send("Sperie improper! Sucen soi sted `" + bot_prefix + "oublier <@Gleder>`.");
					}
				}
				
				if (equalsIgnoreCase(arg[0], "pass-battle-tick")) { //$pass-battle-tick
					main.users.global.battle_tick = main.users.global.battle_tick-(turn_timer*1000);
					message.channel.send("**You have jumped to the next battle tick!**");
				}
				
				if (equalsIgnoreCase(arg[0], "pass-turn")) { //$pass-turn
					main.lastTurn = main.lastTurn-(turn_timer*1000);
					message.channel.send("**A turn has been skipped!**");
				}
				
				if (equalsIgnoreCase(arg[0], "unlock-all")) { //$unlock-all <@user>
					var target_user = returnMention(user_id);
					
					if (arg.length > 1) {
						lockAll(returnMention(arg[1]), "unlock", message);
					} else {
						lockAll(target_user, "unlock", message);
					}
				}
				
				if (equalsIgnoreCase(arg[0], "view-army")) { //$view-army <@user> <name>
					var target_user = returnMention(user_id);
					
					if (main.users[target_user] != undefined) {
						if (arg.length > 2) {
							target_user = returnMention(arg[1]);
							var full_name = [];
							for (var i = 2; i < arg.length; i++) {
								full_name.push(arg[i]);
							}
							printArmy(target_user, message, full_name.join(" ").toLowerCase());
						} else {
							getArguments(message,
								[
									["mention", "**Who's army would you like to see?**\nDo `$army-list` for a full list of your armies."],
									["text", "**Which army would you like to inspect?**\nDo `$army-list` for a full list of your armies."]
								],
								'printArmy(returnMention(arg[0]), msg, arg[1].toLowerCase());'
							);
						}
					} else {
						message.channel.send("You're currently stateless!");
					}
				}
				
				if (equalsIgnoreCase(arg[0], "remove")) { //$remove @user int material
					if (arg.length > 1) {
						var target_user = returnMention(arg[1]);
						var material_exists = false;
						
						for (var i = 0; i < config.materials.length; i++) {
							if (config.materials[i] == arg[3]) {
								material_exists = true;
							}
						}
						
						if (material_exists) { //Execute command
							modifyItem(target_user, arg[2], arg[3], "remove");
							console.log(JSON.stringify(main));
							message.channel.send("You deleted " + arg[2] + " " + arg[3] + " from <@!" + target_user + ">.");
						} else {
							message.channel.send("Material '" + arg[3] + "' was not found.");
						}
					} else {
						message.channel.send("Invalid amount of arguments!");
					}
				}
				
				if (equalsIgnoreCase(arg[0], "research-all")) { //$research-all
					var target_user = returnMention(user_id);
					researchAllTechs(target_user, message);
				}
				
				if (equalsIgnoreCase(arg[0], "spawn-units")) { //$spawn-units <@user> <number> <name>
					var target_user = returnMention(user_id);
					if (arg.length == 3) {
						spawnUnits(target_user, arg[1], arg[2], message);
					} else if (arg.length > 3) {
						target_user = returnMention(arg[1]);
						spawnUnits(target_user, arg[2], arg[3], message);
					} else {
						message.channel.send("Invalid amount of arguments! Try typing `" + bot_prefix + "spawn-units <@user> <number> <unit type>` instead.");
					}
				}
				
				if (equalsIgnoreCase(arg[0], "unlock-all-buildings")) { //$unlock-all-buildings <@user>
					if (arg.length == 1) {
						var target_user = returnMention(user_id);
						unlockAllBuildings(target_user, message);
					} else {
						var target_user = returnMention(arg[1]);
						unlockAllBuildings(target_user, message);
					}
				}
				
				if (equalsIgnoreCase(arg[0], "unlock-all-reforms")) { //$unlock-all-reforms <@user>
					if (arg.length == 1) {
						var target_user = returnMention(user_id);
						unlockAllReforms(target_user, message);
					} else {
						var target_user = returnMention(arg[1]);
						unlockAllReforms(target_user, message);
					}
				}
				
				//Combat functions
				{
					if (equalsIgnoreCase(arg[0], "transfer-province")) { //$transfer-province [@user] [@user] <id>
						if (arg.length == 4) {
							var target_user = returnMention(arg[1]);
							var receiving_user = returnMention(arg[2]);
							
							transferProvince(receiving_user, arg[3], target_user, message);
						} else {
							getArguments(message,
								[
									["mention", "**Mention the receiving country of the province:**"],
									["mention", "**Mention the original province owner:**"],
									["text", "**Please input the province in question:**"]
								],
								'transferProvince(arg[1], arg[2], arg[0], msg);'
							);
						}
					}
					
					if (equalsIgnoreCase(arg[0], "battle") || equalsIgnoreCase(arg[0], "combat")) { //$battle [@attacking user] [army name] [@defending user] [army name] [province]
					//function combat (defending arg0_user, defending arg1_army, attacking arg2_user, attacking arg3_army, arg4_province, arg5_msg)
						if (arg.length == 6) {
							var target_user = returnMention(arg[1]);
							var receiving_user = returnMention(arg[3]);
							
							combat(receiving_user, arg[4], target_user, arg[2], arg[5], message);
						} else {
							getArguments(message,
								[
									["mention", "**Mention the attacking user:**"],
									["mention", "**Mention the defending user:**"],
									["text", "**Please input the attacking user's army:**"],
									["text", "**Please input the defending user's army:**"],
									["text", "**Please input the province where the battle is occurring:**"]
								],
								'combat(arg[1], arg[3], arg[0], arg[2], arg[4], msg);'
							);
						}
					}
				}
			}
		}
		
		//Country commands
		{
			//Map command
			if (equalsIgnoreCase(arg[0], "map")) {
				var mode = "desktop";
				if (arg.length > 1) {
					if (arg[1].toLowerCase() == "mobile") {
						mode = "mobile";
					} else if (arg[1].toLowerCase() == "desktop") {
						mode = "desktop";
					}
				}
				
				var target_user = returnMention(user_id);
				writeSVGS();
				setTimeout(function(){
					initMap(target_user, mode, message);
				},500);
			}
			
			//Check Owner command
			if (equalsIgnoreCase(arg[0], "province") || equalsIgnoreCase(arg[0], "view-province") || equalsIgnoreCase(arg[0], "check-owner") || equalsIgnoreCase(arg[0], "check-province")) {
				if (arg.length > 1) {
					checkOwner(arg[1], message);
				} else {
					getArguments(message,
						[
							["text", "**Please input the province ID of the province that you would like to view.**"]
						],
						'checkOwner(arg[0], msg);'
					);
				}
			}
			
			//Resolve command
			if (equalsIgnoreCase(arg[0], "resolve")) { //$resolve <id>
				var target_user = returnMention(user_id);
				
				if (main.users[target_user] != undefined) {
					if (arg.length > 1) {
						resolveEvent(target_user, arg[1], message);
					} else {
						getArguments(message,
							[
								["text", "**Input the option of your choice:** (Check your DMs if you don't know what it is)."]
							],
							'resolveEvent(author_id, arg[0], msg);'
						);
					}
				}
			}
			
			//Player commands
			if (has_player_role || override_id) {
				if (equalsIgnoreCase(arg[0], "found") || equalsIgnoreCase(arg[0], "rename") || equalsIgnoreCase(arg[0], "name")) { //$found <country_name>
					var target_user = returnMention(user_id);
						console.log(target_user);
						console.log("User Object:");
						console.log(main.users[target_user]);
					var just_registered = false;
				
					if (arg.length > 1) {
						if (main.users[target_user] != undefined) {
							if (main.users[target_user].eliminated || (!main.users[target_user].ai_initialised && main.users[target_user].type == "ai")) {
								main.users[actual_id] = {};
								
								if (!main.users[target_user].ai_initialised && main.users[target_user].type == "ai" && !main.users[target_user].ai_disabled) main.users[target_user].ai_initialised = true;
								just_registered = true;
							}
						}
						just_registered = (!main.users[target_user]) ? true : just_registered;
						if (main.users.global.user_map[actual_id]) just_registered = false;
						
						initUser(target_user);
						
						var full_name = [];
						for (var i = 1; i < arg.length; i++) {
							full_name.push(arg[i]);
						}
						if (full_name.join(" ").length > 1) {
							if (full_name.join(" ").length <= 256) {
								var identical_name = false;
								for (var i = 0; i < main.user_array.length; i++) {
									if (main.users[main.user_array[i]].id != target_user) {
										if (main.users[main.user_array[i]].name.toLowerCase() == full_name.join(" ").toLowerCase().trim()) {
											identical_name = true;
										}
									}
								}
								
								if (main.users[target_user].at_war.length < 1) {
									if (!identical_name) {
										let user = client.users.cache.find(user => user.id.toString() == actual_id);
										main.users[target_user].name = full_name.join(" ");
										
										if (just_registered) {
											if (user != undefined) {
												user.send("You have successfully been registered as **" + main.users[target_user].name + "**!\nDo `" + bot_prefix + "government <government>` to set your government type. For a list of available government types, type `" + bot_prefix + "governments`.\n\nAfter you're done setting up your nation, type in `" + bot_prefix + "settle <Prov ID>` to inform the bot of where you want your capital city to be.\n\nAfterwards, make sure to found your capital city by typing in `" + bot_prefix + "city-new <Province ID> <city name>`.\nAfter typing all of these commands and thereby finishing setting up your nation, type `" + bot_prefix + "stats` to view your new country. Make sure that these commands are typed in a public channel! They will not work in DMs.\n");
											}
											
											message.channel.send("You have successfully been registered as **" + main.users[target_user].name + "**!");
											printTutorial(message, 2);
											main.users[target_user].culture = full_name.join(" ");
											main.users[target_user].accepted_cultures.push(full_name.join(" "));
											localisation.push(main.users[target_user].culture);
											printEvent(target_user, "emergence_of_a_nation");
											
											//Catch up in terms of research
											var highest_cost = 0;
											for (var i = 0; i < main.user_array.length; i++) {
												var local_usr = main.users[main.user_array[i]];
												
												if (local_usr.country_age >= 20) {
													if (local_usr.highest_tier < 11000) {
														highest_cost = highest_cost + local_usr.highest_tier;
													}
												}
											}
											
											if (config.additional_research) {
												researchUpTo(target_user, config.additional_research);
											}
											if (highest_cost > 0) {
												console.log("Highest Cost: " + Math.round(highest_cost/main.user_array.length));
												researchUpTo(target_user, Math.round(highest_cost/main.user_array.length));
											}
											
											//Set valid user_map (this is used to claim AI's and other tags as well)
											main.users.global.user_map[actual_id] = target_user;
										} else {
											if (user != undefined) {
												if (main.users[target_user].name_locked == false) {
													if (!main.users[target_user].customisation_locked) {
														if (full_name[0] == "city") {
															message.channel.send("Try typing `" + bot_prefix + "rename-city` instead, with a dash in between. Otherwise, you'll just end up renaming your country to city.");
														} else {
															user.send("You renamed your country to **" + main.users[target_user].name + "**.");
															message.channel.send("You renamed your country to **" + main.users[target_user].name + "**.");
															cacheSVG();
															setTimeout(function(){
																for (var i = 0; i < map_channel.length; i++) {
																	displaySVG(returnChannel(map_channel[i]));
																}
															}, 2000);
														}
													} else {
														message.channel.send("Your overlord has decreed that you may not change your country's name without prior assent!");
													}
												} else {
													message.channel.send("Your country name was locked into place via moderator action.");
												}
											}
										}
										for (var i = 0; i < config.resource_list.length; i++) {
											main.users.global[config.resource_list[i][0] + "_buy_price"] = Math.ceil(main.users.global[config.resource_list[i][0] + "_buy_price"]*0.9);
											main.users.global[config.resource_list[i][0] + "_sell_price"] = Math.ceil(main.users.global[config.resource_list[i][0] + "_sell_price"]*1.1);
										}
									} else {
										message.channel.send("You cannot carry the identical name of another user!");
									}
								} else {
									message.channel.send("You cannot change your name in times of war!");
								}
							} else {
								message.channel.send("Your name exceeded the maximum of 256 characters!");
							}
						} else {
							message.channel.send("Your nation needs to have a name!");
						}
					} else {
						message.channel.send("Your country must have a name!");
					}
				}
				
				if (equalsIgnoreCase(arg[0], "rename-culture") || equalsIgnoreCase(arg[0], "name-culture")) { //$rename-culture <name>
					var target_user = returnMention(user_id);
					if (main.users[target_user] != undefined) {
						if (main.users[target_user].culture_locked == false) {
							if (arg.length > 1) {
								var full_name = [];
								for (var i = 1; i < arg.length; i++) {
									full_name.push(arg[i]);
								}
								if (full_name.join(" ").length > 1) {
									renameCulture(target_user, full_name.join(" "), message);
								} else {
									message.channel.send("You must specify a valid name for your culture!");
								}
							} else {
								getArguments(message,
									[
										["text", "**What would you like your nation's culture to be named?**"],
									],
									'renameCulture(author_id, arg[0], msg);'
								);
							}
						} else {
							message.channel.send("Your culture name was locked by moderator action.");
						}
					} else {
						message.channel.send("You need a country in order to have a culture to rename!");
					}
				}
				
				if (equalsIgnoreCase(arg[0], "set-motto") || equalsIgnoreCase(arg[0], "motto")) { //$set-motto <motto>
					var target_user = returnMention(user_id);
					if (main.users[target_user] != undefined) {
						if (arg.length > 1) {
							if (!main.users[target_user].customisation_locked) {
								initUser(target_user);
								var full_name = [];
								for (var i = 1; i < arg.length; i++) {
									full_name.push(arg[i]);
								}
								if (full_name.join(" ").length < 251) {
									main.users[target_user].motto = full_name.join(" ");
									message.channel.send("You have set your motto to **" + main.users[target_user].motto + "**.");
								} else {
									message.channel.send("Your motto exceeded the maximum of 250 characters!");
								}
							} else {
								message.channel.send("You may no longer change the motto of your country without prior consent from your overlord!");
							}
						} else {
							getArguments(message,
								[
									["text", "**What would you like your country's motto to be?**", "minimum: 1", "maximum: 250"],
								],
								'main.users[author_id].motto = arg[0]; msg.channel.send("You have set your motto to **" + main.users[author_id].motto + "**.");'
							);
						}
					} else {
						message.channel.send("You first need a country in order to have a national motto!");
					}
				}
				
				if (equalsIgnoreCase(arg[0], "set-colour") || equalsIgnoreCase(arg[0], "set-color") || equalsIgnoreCase(arg[0], "colour") || equalsIgnoreCase(arg[0], "color") || equalsIgnoreCase(arg[0], "change-colour") || equalsIgnoreCase(arg[0], "change-color")) { //$set-colour r g b
					var target_user = returnMention(user_id);
					if (main.users[target_user] != undefined) {
						if (main.users[target_user].colour_locked == false) {
							if (arg.length > 3) {
								setColour(target_user, parseInt(arg[1]), parseInt(arg[2]), parseInt(arg[3]), message);
							} else {
								getArguments(message,
									[
										["number", "**Please insert the R code of your colour:**", "minimum: 20", "maximum: 255"],
										["number", "**Please insert the G code of your colour:**", "minimum: 20", "maximum: 255"],
										["number", "**Please insert the B code of your colour:**", "minimum: 20", "maximum: 255"],
									],
									'setColour(author_id, parseInt(arg[0]), parseInt(arg[1]), parseInt(arg[2]), msg);'
								);
							}
						} else {
							message.channel.send("Your colour was locked into place by moderator action. Sad!");
						}
					}
				}
				
				if (equalsIgnoreCase(arg[0], "set-flag") || equalsIgnoreCase(arg[0], "flag")) { //$set-flag <link>
					var target_user = returnMention(user_id);
					if (main.users[target_user] != undefined) {
						if (main.users[target_user].flag_locked == false) {
							if (!main.users[target_user].customisation_locked) {
								if (arg.length > 1) {
									if (arg[1].indexOf(".png") != -1 || arg[1].indexOf(".jpg") != -1 || arg[1].indexOf(".jpeg") != -1) {
										if (arg[1].indexOf("file:") == -1) {
											main.users[target_user].flag = arg[1];
											message.channel.send("**You have successfully changed your flag!** Type `" + bot_prefix + "stats` to view it.");
										} else {
											message.channel.send("Please copy/paste a valid image URL instead of a local file address!");
										}
									} else {
										message.channel.send("Your flag must be in .png, .jpg, or .jpeg form! Only URLs are accepted.");
									}
								} else {
									message.channel.send("You must specify a URL at the end of your command!");
								}
							} else {
								message.channel.send("Our overlord has issued a diktat saying that we may not change our standard without prior assent!");
							}
						} else {
							message.channel.send("You have been barred from changing your flag by moderators. Please try again later.");
						}
					} else {
						message.channel.send("You need to have a nation first before having a flag!");
					}
				}
				
				if (equalsIgnoreCase(arg[0], "government") || equalsIgnoreCase(arg[0], "choose-government")) { //$government [list¦government_type]
					var target_user = returnMention(user_id);
					if (arg.length == 2 && main.users[target_user] != undefined) {
						if (arg[1] == "list") {
							message.channel.send("Valid governments: " + config.government_list.join(", "));
						} else {
							var usr = main.users[target_user];
							if (main.users[target_user].government == "anarchy") {
								var government_exists = false;
								var government_valid = false;
								
								for (var i = 0; i < config.government_list.length; i++) {
									if (config.government_list[i].toLowerCase() == arg[1].toLowerCase()) {
										government_exists = true;
									}
								}
								
								for (var i = 0; i < main.users[target_user].available_governments.length; i++) {
									if (main.users[target_user].available_governments[i].toLowerCase() == arg[1].toLowerCase()) {
										government_valid = true;
									}
								}
								
								if (government_exists) {
									if (government_valid) {
										message.channel.send("Your government has been changed to: **" + config.governments[arg[1].toLowerCase()].name[0].toLowerCase() + "**.");
										setGovernment(main.users[target_user], arg[1].toLowerCase());
										main.users[target_user].politics[arg[1].toLowerCase()] = 100;
										
										var all_reform_categories = Object.keys(config.reforms);
										for (var i = 0; i < all_reform_categories.length; i++) {
											var all_reforms_in_category = Object.keys(config.reforms[all_reform_categories[i]]);
											for (var x = 0; x < all_reforms_in_category.length; x++) {
												if (all_reforms_in_category[x] == "name") {
													all_reforms_in_category.splice(x, 1);
												}
											}
											
											var reform_discontent_array = [];
											for (var x = 0; x < all_reforms_in_category.length; x++) {
												if (config.reforms[all_reform_categories[i]][all_reforms_in_category[x]].political_appeasement != undefined) {
													if (config.reforms[all_reform_categories[i]][all_reforms_in_category[x]].political_appeasement[usr.government + "_discontent"] != undefined) {
														reform_discontent_array.push([config.reforms[all_reform_categories[i]][all_reforms_in_category[x]].political_appeasement[usr.government + "_discontent"], all_reforms_in_category[x]]);
													} else {
														reform_discontent_array.push([0, all_reforms_in_category[x]]);
													}
												}
											}
											reform_discontent_array.sort(function(a, b){
												return a[0] - b[0];
											});
													
											var reform_obj = config.reforms[all_reform_categories[i]][reform_discontent_array[0][1]];
											enactReform(usr.id, reform_obj.name, "none", true);
										}
										
										usr.modifiers[usr.government + "_discontent"] = -20;
									} else {
										message.channel.send("You can't start off with those ideologies!");
									}
								} else {
									message.channel.send("That government does not exist!");
								}
							} else {
								message.channel.send("You can't change your government on a whim!");
							}
						}
					} else {
						var target_user = returnMention(user_id);
						printGovernmentList(target_user, message);
					}
				}
				
				if (equalsIgnoreCase(arg[0], "governments") || equalsIgnoreCase(arg[0], "goverments")) { //$governments
					var target_user = returnMention(user_id);
					printGovernmentList(target_user, message);
				}
				
				if (equalsIgnoreCase(arg[0], "cb")) { //$cb
					var target_user = returnMention(user_id);
					printCBList(target_user, message);
				}
				
				if (equalsIgnoreCase(arg[0], "politics")) { //$politics view <@user>
					if (arg.length > 1) {
						if (arg[1].toLowerCase() == "view") {
							if (arg.length == 2) {
								var target_user = returnMention(user_id);
								printInterface(target_user, message, 4);
							} else if (arg.length >= 3) {
								var target_user = returnMention(arg[2]);
								printInterface(target_user, message, 4);
							}
						} else if (arg[1].toLowerCase() == "support") { //$politics support <party>
							if (arg.length >= 3) {
								var target_user = returnMention(user_id);
								supportParty(target_user, arg[2].toLowerCase(), message);
							} else {
								getArguments(message,
									[
										["text", "**Which political party would you like to support?**"],
									],
									'supportParty(author_id, arg[0].toLowerCase(), msg);'
								);
							}
						}
					} else {
						var target_user = returnMention(user_id);
						printInterface(target_user, message, 4);
					}
				}
			
				if (equalsIgnoreCase(arg[0], "i") || equalsIgnoreCase(arg[0], "in") || equalsIgnoreCase(arg[0], "inv") || equalsIgnoreCase(arg[0], "inventory") || equalsIgnoreCase(arg[0], "resources") || equalsIgnoreCase(arg[0], "materials")) { //$inv <@user>
					if (arg.length == 1) {
						var target_user = returnMention(user_id);
						printInv(target_user, username, message);
					} else if (arg.length >= 2) {
						var target_user = returnMention(arg[1]);
						printInv(target_user, username, message);
					}
				}
				
				if (equalsIgnoreCase(arg[0], "industry") || equalsIgnoreCase(arg[0], "buildings")) { //$industry <@user>
					if (arg.length == 1) {
						var target_user = returnMention(user_id);
						printBuildings(target_user, username, message);
					} else if (arg.length >= 2) {
						var target_user = returnMention(arg[1]);
						printBuildings(target_user, username, message);
					}
				}
				
				if (equalsIgnoreCase(arg[0], "claim-ai") || equalsIgnoreCase(arg[0], "claim-country") || equalsIgnoreCase(arg[0], "claim-nation")) { //$claim-ai <@user>
					if (arg.length >= 2) {
						var target_user = returnMention(user_id);
						var full_name = [];
						for (var i = 1; i < arg.length; i++) {
							full_name.push(arg[i]);
						}
						console.log(target_user);
						claimAI(target_user, full_name.join(" "), message);
					} else {
						getArguments(message,
							[
								["text", "**What is the name of the country that you would like to claim?**"],
							],
							'claimAI(author_id, arg[0], msg);'
						);
					}
				}
				
				if (equalsIgnoreCase(arg[0], "craft") || equalsIgnoreCase(arg[0], "train") || equalsIgnoreCase(arg[0], "recruit")) { //$craft [int] <item>
					var target_user = returnMention(user_id);
					if (arg.length == 2) {
						var target_user = returnMention(user_id);
						if (arg[1] == "list") {
							printCraftList(target_user, message);
						} else {
							craft(target_user, message, arg[1].toLowerCase(), 1);
						}
					} else if (arg.length == 3) {
						craft(target_user, message, arg[2].toLowerCase(), arg[1]);
					} else {
						getArguments(message,
							[
								["text", "**What would you like to craft?**\nDo `$craft list` for a full list of recipes."],
								["number", "**How much of this unit would you like to craft?**"]
							],
							'craft(author_id, msg, arg[0].toLowerCase(), arg[1]);'
						);
					}
				}
				
				if (equalsIgnoreCase(arg[0], "build") || equalsIgnoreCase(arg[0], "building") || equalsIgnoreCase(arg[0], "construct")) { //$build [int] <building> <city>
					//arg0_user, arg1_msg, arg2_building, arg3_amount, arg4_city
					var target_user = returnMention(user_id);
					if (arg.length == 2 && arg[1] == "list") {
						printBuildList(target_user, message);
					} else if (arg.length == 3) {
						var target_user = returnMention(user_id);
						build(target_user, message, returnBuilding(arg[1].toLowerCase()), 1, arg[2]);
					} else if (arg.length > 3) {
						build(target_user, message, returnBuilding(arg[2].toLowerCase()), arg[1], arg[3]);
					} else {
						getArguments(message,
							[
								["text", "**What type of building would you like to build?**\nDo `$build list` for a full list of buildings."],
								["number", "**How many buildings do you wish to build?**"],
								["text", "**Which city should these buildings go in?**\nDo `$city-list` for a full list of your cities."]
							],
							'build(author_id, msg, returnBuilding(arg[0].toLowerCase()), arg[1], arg[2]); console.log(arg[0] + ", " + arg[1] + ", " + arg[2]);'
						);
					}
				}
				
				if (equalsIgnoreCase(arg[0], "mine")) { //$mine [int]
					var target_user = returnMention(user_id);
					if (main.users[target_user] != undefined) {
						if (arg.length == 1) {
							//(arg0_user, arg1_msg, arg2_actions)
							mine(target_user, message, 1);
						} else if (arg.length == 2) {
							mine(target_user, message, parseInt(arg[1]));
						} else {
							
							getArguments(message,
								[
									["number", "**How many times would you like to mine?**", "minimum: 1", "maximum: 1000"]
								],
								'mine(author_id, msg, arg[0]);'
							);
						}
					} else {
						message.channel.send("You don't even have a country!");
					}
				}
				
				if (equalsIgnoreCase(arg[0], "quarry") || equalsIgnoreCase(arg[0], "quarries")) {
					var target_user = returnMention(user_id);
					if (main.users[target_user] != undefined) {
						if (arg.length == 1) {
							//(arg0_user, arg1_msg, arg2_actions)
							quarry(target_user, message, 1);
						} else if (arg.length == 2) {
							quarry(target_user, message, parseInt(arg[1]));
						} else {
							
							getArguments(message,
								[
									["number", "**How many times would you like to mine stone?**", "minimum: 1", "maximum: 1000"]
								],
								'quarry(author_id, msg, arg[0]);'
							);
						}
					} else {
						message.channel.send("You don't even have a country!");
					}
				}
				
				if (equalsIgnoreCase(arg[0], "forage") || equalsIgnoreCase(arg[0], "chop") || equalsIgnoreCase(arg[0], "lumberjack") || equalsIgnoreCase(arg[0], "lumberjacks")) { //$forage [int]
					var target_user = returnMention(user_id);
					if (main.users[target_user] != undefined) {
						if (arg.length == 1) {
							//(arg0_user, arg1_msg, arg2_actions)
							forage(target_user, message, 1);
						} else if (arg.length == 2) {
							forage(target_user, message, parseInt(arg[1]));
						} else {
							getArguments(message,
								[
									["number", "**How much wood would you like to chop down?**", "minimum: 1", "maximum: 1000"]
								],
								'chop(author_id, msg, arg[0]);'
							);
						}
					} else {
						message.channel.send("You don't even have a country!");
					}
				}
				
				if (equalsIgnoreCase(arg[0], "ledger") || equalsIgnoreCase(arg[0], "leaderboard") || equalsIgnoreCase(arg[0], "country-list") || equalsIgnoreCase(arg[0], "nation-list") || equalsIgnoreCase(arg[0], "state-list") || equalsIgnoreCase(arg[0], "countries") || equalsIgnoreCase(arg[0], "nations") || equalsIgnoreCase(arg[0], "states")) { //$ledger
					var target_user = returnMention(user_id);
					
					printLedger(target_user, message);
				}
				
				if (equalsIgnoreCase(arg[0], "units") || equalsIgnoreCase(arg[0], "reserves")) { //$military <@user>
					if (arg.length == 1) {
						var target_user = returnMention(user_id);
						printMilitary(target_user, username, message);
					} else if (arg.length == 2) {
						var target_user = returnMention(arg[1]);
						printMilitary(target_user, arg[1], message);
					} else {
						getArguments(message,
							[
								["mention", "**Please ping a user:**"],
							],
							'printMilitary(arg[0], arg[0], message);'
						);
					}
				}
				
				if (equalsIgnoreCase(arg[0], "set-tax") || equalsIgnoreCase(arg[0], "settax") || equalsIgnoreCase(arg[0], "tax")) { //$set-tax [int]
					if (arg.length == 2) {
						var target_user = returnMention(user_id);
						var new_tax = Math.ceil(parseInt(arg[1]));
						if (main.users[target_user] != undefined) {
							var usr = main.users[target_user];
							if (new_tax/100 <= usr.max_tax) {
								if (new_tax >= 0) {
									if (isNaN(new_tax) == false) {
										main.users[target_user].tax_rate = new_tax/100;
										message.channel.send("Your tax rate has been set to **" + new_tax + "%**.");
									} else {
										message.channel.send("You must specify a number!");
									}
								}
							} else {
								message.channel.send("You have exceeded your maximum tax rate! You may only set your tax rate up to **" + (usr.max_tax*100) + "%**!");
							}
						} else {
							message.channel.send("Your government type doesn't allow for such a high tax rate!");
						}
					} else {
						getArguments(message,
							[
								["number", "**What would you like your tax rate to be set to (in percentage)?**", "minimum: 1", "maximum: 100"],
							],
							'main.users[author_id].tax_rate = Math.ceil(arg[0])/100; msg.channel.send("Your tax rate has been set to **" + Math.ceil(arg[0]) + "%**.");'
						);
					}
				}
				
				if (equalsIgnoreCase(arg[0], "coup") || equalsIgnoreCase(arg[0], "overthrow")) { //$coup
					var target_user = returnMention(user_id);
					if (main.users[target_user] != undefined) {
						if (arg.length == 2) {
							if (main.users[target_user].overthrow_this_turn == "") {
								coup(target_user, arg[1], message);
							} else {
								message.channel.send("A coup has already been initiated! It will occur next turn.");
							}
						} else {
							getArguments(message,
								[
									["text", "**Please specify an ideology:**"],
								],
								'coup(author_id, arg[0], msg);'
							);
						}
					}
				}
				
				if (equalsIgnoreCase(arg[0], "next-round") || equalsIgnoreCase(arg[0], "next-turn") || equalsIgnoreCase(arg[0], "nextround") || equalsIgnoreCase(arg[0], "nextturn") || equalsIgnoreCase(arg[0], "next")) { //$next-round
					var current_date = new Date().getTime();
					var time_difference = current_date - main.lastTurn;
					
					message.channel.send("It is currently round **" + main.roundCount + "**.\n" + parseMilliseconds((turn_timer*1000)-time_difference) + " remaining until the next turn.\nIt is also the year of our Lord, **" + returnYear(main.year) + "**.");
				}
				
				if (equalsIgnoreCase(arg[0], "disband") || equalsIgnoreCase(arg[0], "delete")) { //$disband <amount> <unit> arg0_user, arg1_msg, arg2_unit, arg3_amount
					var target_user = returnMention(user_id);
					if (arg.length == 3) {
						if (main.users[target_user] != undefined) {
							disband(target_user, message, returnCrafting(arg[2]), parseInt(arg[1]));
						} else {
							message.channel.send("You're stateless!");
						}
					} else if (arg.length == 2) {
						if (main.users[target_user] != undefined) {
							disband(target_user, message, returnCrafting(arg[1]), 1);
						} else {
							message.channel.send("You're stateless!");
						}
					} else {
						getArguments(message,
							[
								["text", "**Please specify a unit you wish to disband:**"],
								["number", "**Please specify the number of troops you wish to disband:**"]
							],
							'disband(author_id, msg, returnCrafting(arg[0]), parseInt(arg[1]));'
						);
					}
				}
				
				if (equalsIgnoreCase(arg[0], "demolish") || equalsIgnoreCase(arg[0], "destroy") || equalsIgnoreCase(arg[0], "delete-building")) { //$demolish <amount> <building> <city>
					var target_user = returnMention(user_id);
					if (arg.length == 4) {
						if (main.users[target_user] != undefined) {
							demolish(target_user, message, returnBuilding(arg[2]), parseInt(arg[1]), arg[3]);
						} else {
							message.channel.send("You're stateless!");
						}
					} else if (arg.length == 3) {
						if (main.users[target_user] != undefined) {
							demolish(target_user, message, returnBuilding(arg[1]), 1, arg[2]);
						} else {
							message.channel.send("You're stateless!");
						}
					} else {
						getArguments(message,
							[
								["text", "**Please specify the city in which you wish to demolish buildings.**\nType `$city-list` for a complete list of your cities."],
								["text", "**What type of building would you like to demolish?**\nType `$build list` for a complete list of buildings."],
								["number", "**Please specify the number of buildings you wish to demolish.**"]
							],
							'demolish(author_id, msg, returnBuilding(arg[1]), arg[2], arg[0]);'
						);
					}
				}
				
				if (equalsIgnoreCase(arg[0], "give") || equalsIgnoreCase(arg[0], "ship") || equalsIgnoreCase(arg[0], "export")) { //$give <@user> <int> <item>
					if (arg.length == 4) {
						var target_user = returnMention(arg[1]);
						var current_user = returnMention(user_id);
						console.log(target_user);
						if (main.users[target_user] != undefined && main.users[current_user] != undefined) {
							if (main.users[target_user].blockaded == undefined || main.users[current_user].blockaded == undefined) {
								give(current_user, target_user, arg[2], arg[3], "item", message);
							} else if (main.users[target_user].blockaded || main.users[current_user].blockaded == undefined) {
								message.channel.send("The person you are trying to send these items to is currently blockaded!");
							} else {
								give(current_user, target_user, arg[2], arg[3], "item", message);
							}
						}
					} else {
						//arg0_user, arg1_user2, arg2_amount, arg3_item, arg4_mode, arg5_message
						getArguments(message,
							[
								["number", "**How many items would you like to give?**"],
								["text", "**Please specify the item you wish to give:**"],
								["mention", "**Who are you planning to give these items to?**"]
							],
							'give(author_id, arg[2], arg[0], arg[1], "item", msg);'
						);
					}
				}
				
				//(arg0_user, arg1_msg, arg2_amount, arg3_type)
				if (equalsIgnoreCase(arg[0], "market") || equalsIgnoreCase(arg[0], "market-list")) {
					var target_user = returnMention(user_id);
					
					if (arg.length == 1) {
						printBuyList(target_user, message);
					} else {
						printBuyList(target_user, message, parseInt(arg[1]));
					}
				}
				
				if (equalsIgnoreCase(arg[0], "buy")) { //$buy <int> <item>
					var target_user = returnMention(user_id);
					
					if (main.users[target_user] != undefined) {
						if (arg.length == 3) {
							if (isNaN(parseInt(arg[2]))) {
								buy(target_user, message, parseInt(arg[1]), arg[2].toLowerCase());
							} else {
								printBuyList(target_user, message, parseInt(arg[2]));
							}
						} else if (arg.length == 2) {
							if (arg[1] == "list") {
								printBuyList(target_user, message);
							} else {
								buy(target_user, message, 1, arg[1].toLowerCase());
							} 
						} else {
							getArguments(message,
								[
									["text", "**What resource would you like to buy?**\nType `" + bot_prefix + "buy list` for a list of valid resources."],
									["number", "**How much would you like to buy?**"],
								],
								'buy(author_id, msg, arg[1], arg[0].toLowerCase());'
							);
						}
					}
				}
				
				if (equalsIgnoreCase(arg[0], "sell")) { //$sell <int> <item>
					var target_user = returnMention(user_id);
					
					if (arg.length == 2) {
						sell(target_user, message, 1, arg[1].toLowerCase());
					} else if (arg.length == 3) {
						sell(target_user, message, parseInt(arg[1]), arg[2].toLowerCase());
					} else {
						getArguments(message,
							[
								["text", "**What resource would you like to sell?**\nType `" + bot_prefix + "buy list` for a list of valid resources."],
								["number", "**How much would you like to sell?**"],
							],
							'sell(author_id, msg, arg[1], arg[0].toLowerCase());'
						);
					}
				}
				
				//Armies
				{
					//Air Orders
					{
						if (equalsIgnoreCase(arg[0], "air-raid") || equalsIgnoreCase(arg[0], "bomb")) { //$air-raid <@user> <province id> <air wing>
							if (arg.length > 3) {
								var target_user = returnMention(user_id);
								var receiving_user = returnMention(arg[1]);
								airRaid(target_user, arg[3], receiving_user, arg[2], message);
							} else {
								getArguments(message,
									[
										["mention", "**Please ping the user you'd like to bomb.**"],
										["text", "**What is the name of the air wing you would like to send on this mission?**"],
										["text", "**Please insert the Province ID of the designated target.**"]
									],
									'airRaid(author_id, arg[1], arg[0], arg[2], msg);'
								);
							}
						}
					}
					
					//Army Management Commands
					{
						if (equalsIgnoreCase(arg[0], "carpet-siege") || equalsIgnoreCase(arg[0], "full-occupy")) { //$carpet-siege <@user> <armies>
							var target_user = returnMention(user_id);
							
							if (arg.length == 2) { //$full-occupy <@user>
								var receiving_user = returnMention(arg[1]);
								carpetSiege(target_user, receiving_user, message);
							} else if (arg.length >= 3) { //$full-occupy <@user> <armies>
								var receiving_user = returnMention(arg[1]);
								var armies = [];
								for (var i = 2; i < arg.length; i++) {
									armies.push(arg[i]);
								}
								
								carpetSiege(target_user, receiving_user, message, armies.join(" "));
							} else {
								getArguments(message,
									[
										["mention", "**Please ping the user you'd like to fully occupy.**"],
										["text", "**Which armies would you like to manually assign, if any?** Type `none` to use available armies instead."]
									],
									'carpetSiege(author_id, arg[0], msg, arg[1]);'
								);
							}
						}
						
						if (equalsIgnoreCase(arg[0], "create-armies")) { //$create-armies <armies>
							var target_user = returnMention(user_id);
							
							if (arg.length > 1) {
								var armies = [];
								for (var i = 1; i < arg.length; i++) {
									armies.push(arg[i]);
								}
								
								createArmies(target_user, armies.join(" "), message);
							} else {
								getArguments(message,
									[
										["text", "**Please type out the names of the new armies you'd like to create en masse.**\nYou may specify armies like so: `I.-XX. Division`, `1st-20th Division`, `86th-79th, 92nd, 94th Field Artillery`; or any other combination you can imagine."]
									],
									'createArmies(author_id, arg[0], msg);'
								);
							}
						}
						
						if (equalsIgnoreCase(arg[0], "delete-all-armies")) { //$delete-armies <armies>
							var target_user = returnMention(user_id);
							deleteAllArmies(user_id, message);
						}
						
						if (equalsIgnoreCase(arg[0], "delete-armies")) { //$delete-armies <armies>
							var target_user = returnMention(user_id);
							
							if (arg.length > 1) {
								var armies = [];
								for (var i = 1; i < arg.length; i++) {
									armies.push(arg[i]);
								}
								
								deleteArmies(target_user, armies.join(" "), message);
							} else {
								getArguments(message,
									[
										["text", "**Please type out the names of the armies you'd like to delete en masse. Their men and equipment will be returned to your reserves.**\nYou may specify armies like so: `I.-XX. Division`, `1st-20th Division`, `86th-79th, 92nd, 94th Field Artillery`; or any other combination you can imagine."]
									],
									'deleteArmies(author_id, arg[0], msg);'
								);
							}
						}
						
						if (equalsIgnoreCase(arg[0], "garrison-cities") || equalsIgnoreCase(arg[0], "guard-cities")) { //$garrison-cities <armies>
							var target_user = returnMention(user_id);
							
							if (arg.length >= 2) {
								var armies = [];
								for (var i = 1; i < arg.length; i++) armies.push(arg[i]);
								
								garrisonCities(target_user, armies.join(" "), message);
							} else {
								getArguments(message,
									[
										["text", "**Which armies would you like to assign to guard your cities?**\nYou may specify armies like so: `I.-XX. Division`, `1st-20th Division`, `86th-79th, 92nd, 94th Field Artillery`; or any other combination you can imagine."]
									],
									'garrisonCities(author_id, arg[0], msg);'
								);
							}
						}
						
						if (equalsIgnoreCase(arg[0], "garrison-provinces") || equalsIgnoreCase(arg[0], "guard-provinces")) { //$garrison-cities <armies>
							var target_user = returnMention(user_id);
							
							if (arg.length >= 2) {
								var armies = [];
								for (var i = 1; i < arg.length; i++) armies.push(arg[i]);
								
								garrisonProvinces(target_user, armies.join(" "), message);
							} else {
								getArguments(message,
									[
										["text", "**Which armies would you like to assign to guard your provinces?**\nYou may specify armies like so: `I.-XX. Division`, `1st-20th Division`, `86th-79th, 92nd, 94th Field Artillery`; or any other combination you can imagine."]
									],
									'garrisonProvinces(author_id, arg[0], msg);'
								);
							}
						}
						
						if (equalsIgnoreCase(arg[0], "mass-deploy")) { //$mass-deploy <unit amount> <unit type> <armies>
							var target_user = returnMention(user_id);
							
							if (arg.length >= 4) { //$mass-deploy <unit amount> <unit type> <armies>
								var current_unit = returnCrafting(arg[2]);
								var armies = [];
								for (var i = 3; i < arg.length; i++) {
									armies.push(arg[i]);
								}
								
								massDeploy(target_user, armies.join(" "), parseInt(arg[1]), current_unit, message);
							} else if (arg.length == 3) { //$mass-deploy <unit type> <armies>
								var current_unit = returnCrafting(arg[1]);
								var armies = [];
								for (var i = 2; i < arg.length; i++) {
									armies.push(arg[i]);
								}
								
								massDeploy(target_user, armies.join(" "), 1, current_unit, message);
							} else {
								getArguments(message,
									[
										["text", "**Please type out the names of the armies you'd like to deploy troops to en masse.**\nYou may specify armies like so: `I.-XX. Division`, `1st-20th Division`, `86th-79th, 92nd, 94th Field Artillery`; or any other combination you can imagine."],
										["number", "**How many troops would you like to deploy in each of these armies?**"],
										["text", "**What type of unit do you wish to deploy in these armies?**"]
									],
									'massDeploy(author_id, arg[0], arg[1], arg[2], msg);'
								);
							}
						}
						
						if (equalsIgnoreCase(arg[0], "mass-relieve")) { //$mass-relieve <unit amount> <unit type> <armies>
							var target_user = returnMention(user_id);
							
							if (arg.length >= 4) { //$mass-relieve <unit amount> <unit type> <armies>
								var current_unit = returnCrafting(arg[2]);
								var armies = [];
								for (var i = 3; i < arg.length; i++) {
									armies.push(arg[i]);
								}
								
								massRelieve(target_user, armies.join(" "), parseInt(arg[1]), current_unit, message);
							} else if (arg.length == 3) { //$mass-relieve <unit type> <armies>
								var current_unit = returnCrafting(arg[1]);
								var armies = [];
								for (var i = 2; i < arg.length; i++) {
									armies.push(arg[i]);
								}
								
								massRelieve(target_user, armies.join(" "), 1, current_unit, message);
							} else {
								getArguments(message,
									[
										["text", "**Please type out the names of the armies you'd like to relieve troops from en masse. These units will be returned to your reserves.**\nYou may specify armies like so: `I.-XX. Division`, `1st-20th Division`, `86th-79th, 92nd, 94th Field Artillery`; or any other combination you can imagine."],
										["number", "**How many troops would you like to relieve in each of these armies?**"],
										["text", "**What type of unit do you wish to relieve in these armies?**"]
									],
									'massRelieve(author_id, arg[0], arg[1], arg[2], msg);'
								);
							}
						}
						
						if (equalsIgnoreCase(arg[0], "merge-armies")) { //$merge-armies <merging armies to> <merging armies from>
							var target_user = returnMention(user_id);
							
							if (arg.length >= 3) {
								var armies = [];
								for (var i = 2; i < arg.length; i++) {
									armies.push(arg[i]);
								}
								
								mergeArmies(target_user, armies.join(" "), arg[1], message);
							} else {
								getArguments(message,
									[
										["text", "**Please type out the names of the armies you'd like to merge.**\nYou may specify armies like so: `I.-XX. Division`, `1st-20th Division`, `86th-79th, 92nd, 94th Field Artillery`; or any other combination you can imagine."],
										["text", "**Please give the name of the army you would like for the armies previously specified to merge with.**"]
									],
									'mergeArmies(author_id, arg[0], arg[1], msg);'
								);
							}
						}
						
						if (equalsIgnoreCase(arg[0], "move-armies")) { //$move-armies <province id> <armies>
							var target_user = returnMention(user_id);
							
							if (arg.length >= 3) {
								var armies = [];
								for (var i = 2; i < arg.length; i++) {
									armies.push(arg[i]);
								}
								
								moveArmies(target_user, armies.join(" "), arg[1], message);
							} else {
								getArguments(message,
									[
										["text", "**Please type out the names of the armies you'd like to move.**\nYou may specify armies like so: `I.-XX. Division`, `1st-20th Division`, `86th-79th, 92nd, 94th Field Artillery`; or any other combination you can imagine."],
										["text", "**Which province would you like to move these armies to?**"]
									],
									'moveArmies(author_id, arg[0], arg[1], msg);'
								);
							}
						}
						
						if (equalsIgnoreCase(arg[0], "split-armies")) { //$split-army <original army> <new armies>
							var target_user = returnMention(user_id);
							
							if (arg.length >= 3) {
								var armies = [];
								for (var i = 2; i < arg.length; i++) {
									armies.push(arg[i]);
								}
								
								splitArmies(target_user, arg[1], armies.join(" "), message);
							} else {
								getArguments(message,
									[
										["text", "**Please give the name of the army you would like to split new armies out of.**"],
										["text", "**Please type out the names of the armies you'd like to create.**\nYou may create these new armies as such: `1-5. Landwehrkorps`, `Garrison Division A0-A25`, `86th-79th, 92nd, 94th Field Artillery`; or any other combination you can imagine."],
									],
									'splitArmies(author_id, arg[0], arg[1], msg);'
								);
							}
						}
					}
					
					//Army Orders
					{
						if (equalsIgnoreCase(arg[0], "merge-army") || equalsIgnoreCase(arg[0], "merge")) { //$merge-army <army1> <army2>
							var target_user = returnMention(user_id);
							
							if (arg.length > 2) {
								mergeArmy(target_user, message, arg[1], arg[2]);
							} else {
								getArguments(message,
									[
										["text", "**What is the name of the first army you would like to merge?**"],
										["text", "**What is the name of the second army you would like to move the first army into?**"]
									],
									'mergeArmy(author_id, msg, arg[0], arg[1]);'
								);
							}
						}
						
						if (equalsIgnoreCase(arg[0], "move") || equalsIgnoreCase(arg[0], "move-army") || equalsIgnoreCase(arg[0], "invade") || equalsIgnoreCase(arg[0], "attack")) { //$move-army <army name> <province>
							var target_user = returnMention(user_id);
							
							if (arg.length > 2) {
								moveArmy(target_user, message, arg[1], arg[2]);
							} else {
								getArguments(message,
									[
										["text", "**What is the name of the army you would like to move?**"],
										["text", "**Please specify the province ID you would like to move your army to.**"]
									],
									'moveArmy(author_id, msg, arg[0], arg[1]);'
								);
							}
						}
						
						if (equalsIgnoreCase(arg[0], "move-all") || equalsIgnoreCase(arg[0], "move-all-armies")) { //$move-all <province>
							var target_user = returnMention(user_id);
							
							if (arg.length >= 2) {
								moveAllArmies(target_user, message, arg[1]);
							} else {
								getArguments(message,
									[
										["text", "**Which province would you like to move all armies to?**"]
									],
									'moveAllArmies(author_id, msg, arg[0]);'
								);
							}
						}
					}
					
					//Army Option Orders
					{
						if (equalsIgnoreCase(arg[0], "avoid-attrition")) { //$avoid-attrition always/if possible/never
							var target_user = returnMention(user_id);
							getArguments(message,
								[
									["text", "**What would you like to set your policy on attrition non-avoidance to?** Please type either `always`, `if possible`, or `never`.\n\n'Always' means that units will use the shortest path regardless of attrition, whilst 'if possible' means that they will avoid walking through the province if at all possible, and 'never' means that your armies should never take attrition whilst moving."]
								],
								`
									main.users[author_id].avoid_attrition = (["always", "if possible", "never"].includes(arg[0].toLowerCase())) ? arg[0].toLowerCase() : main.users[author_id].avoid_attrition;
									msg.channel.send("<:checkmark:725550245051760671> You have successfully set your policy on attrition avoidance to **" + main.users[author_id].avoid_attrition + "**.");
								`
							);
						}
						
						if (equalsIgnoreCase(arg[0], "avoid-territorial-violation")) { //$avoid-territorial-violation always/if possible/never
							var target_user = returnMention(user_id);
							getArguments(message,
								[
									["text", "**What would you like to set your policy on territorial violation to?** Please type either `always`, `if possible`, or `never`.\n\n'Always' means that units will use the shortest path regardless of territorial violation, whilst 'if possible' means that they will only walk through the given territory if unavoidable, and 'never' means that your armies will no longer be capable of violating the territory of other nations."]
								],
								`
									main.users[author_id].avoid_territorial_violation = (["always", "if possible", "never"].includes(arg[0].toLowerCase())) ? arg[0].toLowerCase() : main.users[author_id].avoid_territorial_violation;
									msg.channel.send("<:checkmark:725550245051760671> You have successfully set your policy on territorial violation avoidance to **" + main.users[author_id].avoid_territorial_violation + "**.");
								`
							);
						}
						
						if (equalsIgnoreCase(arg[0], "ignore-orders-when-carpet-sieging")) { //$ignore-orders-when-carpet-sieging yes/no
							var target_user = returnMention(user_id);
							getArguments(message,
								[
									["text", "**Should only stationary armies be allowed to participate in general carpet sieges?** Please type either `yes`, or `no`."]
								],
								`
									main.users[author_id].ignore_orders_when_carpet_sieging = (arg[0].toLowerCase() == "yes") ? true : false;
									msg.channel.send("<:checkmark:725550245051760671> You have successfully changed your policy on whether units should ignore orders or not when carpet sieging.");
								`
							);
						}
					}
					
					//Naval Orders
					{
						if (equalsIgnoreCase(arg[0], "blockade")) { //$blockade <@user> <fleet>
							if (arg.length > 2) {
								var target_user = returnMention(user_id);
								var receiving_user = returnMention(arg[1]);
								blockade(target_user, receiving_user, arg[2], "add", message);
							} else {
								getArguments(message,
									[
										["mention", "**Who would you like to blockade?**"],
										["text", "**Please insert the name of the fleet you wish to institute this blockade:**"]
									],
									'blockade(author_id, arg[0], arg[1], "add", msg);'
								);
							}
						}
						
						if (equalsIgnoreCase(arg[0], "challenge-blockade") || equalsIgnoreCase(arg[0], "challenge")) { //$challenge-blockade <@user> <fleet>
							if (arg.length == 2) {
								var target_user = returnMention(user_id);
								challengeBlockade(target_user, target_user, arg[1], message);
							} else if (arg.length > 2) {
								var target_user = returnMention(user_id);
								var receiving_user = returnMention(arg[1]);
								challengeBlockade(target_user, receiving_user, arg[1], message);
							} else {
								getArguments(message,
									[
										["mention", "**Please ping the person you would like to free from the grips of a blockade.**"],
										["text", "**Please type out the name of the fleet you'd like to send on this endeavour.**"]
									],
									'challengeBlockade(author_id, arg[0], arg[1], msg);'
								);
							}
						}
						
						if (equalsIgnoreCase(arg[0], "convoy-raid") || equalsIgnoreCase(arg[0], "trade-interdiction") || equalsIgnoreCase(arg[0], "convoy")) { //$convoy-raid <@user> <name>
							if (arg.length > 1) {
								var target_user = returnMention(user_id);
								submarineRaid(target_user, arg[1], arg[2], "convoy", message);
							} else {
								getArguments(message,
									[
										["mention", "**Please ping the user you would like to raid.**"],
										["text", "**Please type out the name of the submarine flotilla you'd like to send on this mission.**"]
									],
									'submarineRaid(author_id, arg[0], arg[1], "convoy", msg);'
								);
							}
						}
						
						if (equalsIgnoreCase(arg[0], "harbour-raid") || equalsIgnoreCase(arg[0], "harbour")) { //$harbour-raid <@user> <name>
							if (arg.length > 1) {
								var target_user = returnMention(user_id);
								submarineRaid(target_user, arg[1], arg[2], "reserves", message);
							} else {
								getArguments(message,
									[
										["mention", "**Please ping the user you would like to raid.**"],
										["text", "**Please type out the name of the submarine flotilla you'd like to send on this mission.**"]
									],
									'submarineRaid(author_id, arg[0], arg[1], "reserves", msg);'
								);
							}
						}
						
						if (equalsIgnoreCase(arg[0], "lift-blockade") || equalsIgnoreCase(arg[0], "relieve-blockade")) { //$lift-blockade <@user> <fleet>
							if (arg.length > 2) {
								var target_user = returnMention(user_id);
								blockade(target_user, arg[1], arg[2], "remove", message);
							} else {
								getArguments(message,
									[
										["mention", "**Who would you like to lighten the blockade on?**"],
										["text", "**Please insert the name of the fleet you wish to relieve from having to enforce this blockade:**"]
									],
									'blockade(author_id, arg[0], arg[1], "remove", msg);'
								);
							}
						}
						
						if (equalsIgnoreCase(arg[0], "torpedo-fleet") || equalsIgnoreCase(arg[0], "torpedo")) { //$torpedo-fleet <@user> <name>
							if (arg.length > 1) {
								var target_user = returnMention(user_id);
								submarineRaid(target_user, arg[1], arg[2], "naval", message);
							} else {
								getArguments(message,
									[
										["mention", "**Please ping the user you would like to raid.**"],
										["text", "**Please type out the name of the submarine flotilla you'd like to send on this mission.**"]
									],
									'submarineRaid(author_id, arg[0], arg[1], "naval", msg);'
								);
							}
						}
					}
					
					if (equalsIgnoreCase(arg[0], "new-army") || equalsIgnoreCase(arg[0], "create-army") || equalsIgnoreCase(arg[0], "create-navy") || equalsIgnoreCase(arg[0], "create-air-wing") || equalsIgnoreCase(arg[0], "army-new")) { //$create-army <name>
						var target_user = returnMention(user_id);
						
						if (main.users[target_user] != undefined) {
							if (arg.length > 1) {
								var full_name = [];	
								for (var i = 1; i < arg.length; i++) {
									full_name.push(arg[i]);
								}
								if (full_name.join(" ").length <= 50) {
									newArmy(target_user, message, full_name.join(" "));
								} else {
									message.channel.send("Your name exceeded the maximum character limit of 50 characters!");
								}
							} else {
								getArguments(message,
									[
										["text", "**What would you like to call your new army?**"]
									],
									'newArmy(author_id, msg, arg[0]);'
								);
							}
						} else {
							message.channel.send("You're currently stateless!");
						}
					}
					
					if (equalsIgnoreCase(arg[0], "deploy") ||  equalsIgnoreCase(arg[0], "assign")) { //$transfer <int> <unit> <army> add-remove
						if (arg.length > 3) {
							var target_user = returnMention(user_id);
							if (main.users[target_user] != undefined) {
								var full_name = [];
								for (var i = 3; i < arg.length; i++) {
									full_name.push(arg[i]);
								}
								if (parseInt(arg[1])-parseInt(arg[1]) != 0) {
									message.channel.send("You must provide a number of units!");
								} else {
									if (parseInt(arg[1] < 0)) {
										message.channel.send("Stop trying to cheese the system!");
									} else {
										editArmy(target_user, message, full_name.join(" "), parseInt(arg[1]), returnCrafting(arg[2]), ["add"]);
									}
								}
							}
						} else if (arg.length == 3) { //$transfer <unit> <army>
							var target_user = returnMention(user_id);
							if (main.users[target_user] != undefined) {
								editArmy(target_user, message, 1, arg[2], returnCrafting(arg[1]), ["add"]);
							} else {
								message.channel.send("You don't even have a country yet!");
							}
						} else {
							getArguments(message,
								[
									["text", "**Which army would you like to deploy your units in?**\nDo `$army-list` for a full list of your armies."],
									["text", "**What type of unit do you wish to deploy?**"],
									["number", "**How many troops would you like to deploy?**", "minimum: 1"]
								],
								'editArmy(author_id, msg, arg[0], arg[2], returnCrafting(arg[1]), ["add"]);'
							);
						}
					}
					
					if (equalsIgnoreCase(arg[0], "split-army") || equalsIgnoreCase(arg[0], "split")) { //$split-army <army 1> <army 2>
						var target_user = returnMention(user_id);
						if (arg.length > 2) {
							var full_name = [];
							for (var i = 2; i < arg.length; i++) {
								full_name.push(arg[i]);
							}
							splitArmy(target_user, message, arg[1], full_name.join(" "));
						} else {
							getArguments(message,
								[
									["text", "**Which army would you like to split off?**\nDo `$army-list` for a full list of your armies."],
									["text", "**What would you like to name your new army?**"]
								],
								'splitArmy(author_id, msg, arg[0], arg[1]);'
							);
						}
					}
					
					if (equalsIgnoreCase(arg[0], "transfer") || equalsIgnoreCase(arg[0], "transfer-units")) { //$transfer <int> <unit> <army 1> <army 2>
						var target_user = returnMention(user_id);
						if (arg.length > 4) {
							if (main.users[target_user] != undefined) {
								var full_name = [];
								for (var i = 4; i < arg.length; i++) {
									full_name.push(arg[i]);
								}
								if (parseInt(arg[1])-parseInt(arg[1]) != 0) {
									message.channel.send("You must provide a number of units!");
								} else {
									if (parseInt(arg[1] < 0)) {
										message.channel.send("Stop trying to cheese the system!");
									} else {
										editArmy(target_user, message, full_name.join(" "), parseInt(arg[1]), returnCrafting(arg[2]), ["add", arg[3]]);
									}
								}
							} else {
								message.channel.send("You need to have a country first in order to transfer units between armies!");
							}
						} else if (arg.length == 4) { //$transfer <unit> <army 1> <army 2>
							if (main.users[target_user] != undefined) {
								editArmy(target_user, message, arg[3], 1, returnCrafting(arg[1]), arg[2]);
							} else {
								message.channel.send("You need to have a country first in order to transfer units between armies!");
							}
						} else {
							getArguments(message,
								[
									["text", "**Which army would you like to transfer your units from?**\nDo `$army-list` for a full list of your armies."],
									["text", "**Which army would you like to deploy your units in?**\nDo `$army-list` for a full list of your armies."],
									["text", "**What type of unit do you wish to deploy?**"],
									["number", "**How many troops would you like to deploy?**", "minimum: 1"]
								],
								'editArmy(author_id, msg, arg[1], arg[3], returnCrafting(arg[2]), ["add", arg[0]]);'
							);
						}
					}
					
					if (equalsIgnoreCase(arg[0], "relieve") || equalsIgnoreCase(arg[0], "relieve-units")) { //$relieve <int> <unit> <army> add-remove
						if (arg.length > 3) {
							var target_user = returnMention(user_id);
							var full_name = [];
							for (var i = 3; i < arg.length; i++) {
								full_name.push(arg[i]);
							}
							if (main.users[target_user] != undefined) {
								if (parseInt(arg[1])-parseInt(arg[1]) != 0) {
									message.channel.send("You must provide a number of units!");
								} else {
									if (parseInt(arg[1] > 0)) {
										message.channel.send("Stop trying to cheese the system!");
									} else {
										editArmy(target_user, message, full_name.join(" "), parseInt(arg[1]), returnCrafting(arg[2]), ["remove"]);
									}
								}
							}
						} else if (arg.length == 3) { //$transfer <unit> <army>
							var target_user = returnMention(user_id);
							if (main.users[target_user] != undefined) {
								editArmy(target_user, message, 1, returnCrafting(arg[2]), ["remove"]);
							} else {
								message.channel.send("You don't even have a country yet!");
							}
						} else {
							getArguments(message,
								[
									["text", "**Which army would you like to withdraw your units from?**\nDo `$army-list` for a full list of your armies."],
									["text", "**What type of unit do you wish to place back in the reserves?**"],
									["number", "**How many troops should go back into the reserves?**", "minimum: 1"]
								],
								'editArmy(author_id, msg, arg[0], arg[2], returnCrafting(arg[1]), ["remove"]);'
							);
						}
					}
					
					if (equalsIgnoreCase(arg[0], "army") || equalsIgnoreCase(arg[0], "navy") || equalsIgnoreCase(arg[0], "fleet") || equalsIgnoreCase(arg[0], "flotilla") || equalsIgnoreCase(arg[0], "airforce") || equalsIgnoreCase(arg[0], "air-wing") || equalsIgnoreCase(arg[0], "airwing") || equalsIgnoreCase(arg[0], "air")) { //$army <name>
						var target_user = returnMention(user_id);
						
						if (main.users[target_user] != undefined) {
							if (arg.length > 1) {
								var full_name = [];
								for (var i = 1; i < arg.length; i++) {
									full_name.push(arg[i]);
								}
								printArmy(target_user, message, full_name.join(" ").toLowerCase());
							} else {
								getArguments(message,
								[
									["text", "**Which army would you like to inspect?**\nDo `$army-list` for a full list of your armies."]
								],
								'printArmy(author_id, msg, arg[0].toLowerCase());'
							);
							}
						} else {
							message.channel.send("You're currently stateless!");
						}
					}
					
					if (equalsIgnoreCase(arg[0], "rename-army") || equalsIgnoreCase(arg[0], "rename-force") || equalsIgnoreCase(arg[0], "rename-military")) { //$rename-army <old_name> <new_name>
						var target_user = returnMention(user_id);
						
						if (main.users[target_user] != undefined) {
							if (arg.length >= 3) {
								
								//Get full new name
								var full_name = [];
								for (var i = 2; i < arg.length; i++) {
									full_name.push(arg[i]);
								}
								
								if (full_name.join(" ").length <= 50) {
									renameArmy(target_user, message, arg[1], full_name.join(" "));
								} else {
									message.channel.send("Your army name exceeded the maximum character limit of 50 characters!");
								}
							} else {
								getArguments(message,
								[
									["text", "**Which army would you like to rename?**\nDo `$army-list` for a full list of your armies."],
									["text", "**What do you want the new name to be?**"]
								],
								'renameArmy(author_id, msg, arg[0], arg[1]);'
							);
							}
						} else {
							message.channel.send("You don't even have a nation!");
						}
					}
					
					if (equalsIgnoreCase(arg[0], "disband-army") || equalsIgnoreCase(arg[0], "delete-army")) { //$disband-army <name>
						var target_user = returnMention(user_id);
						
						if (main.users[target_user] != undefined) {
							if (arg.length > 1) {
								var full_name = [];
								for (var i = 1; i < arg.length; i++) {
									full_name.push(arg[i]);
								}
								deleteArmy(target_user, message, full_name.join(" "));
							} else {
								getArguments(message,
									[
										["text", "**Which army do you wish to disband?**\nDo `$army-list` for a full list of your armies."]
									],
									'deleteArmy(author_id, msg, arg[0]);'
								);
							}
						} else {
							message.channel.send("You don't even have a nation!");
						}
					}
					
					if (equalsIgnoreCase(arg[0], "army-list") || equalsIgnoreCase(arg[0], "armies") || equalsIgnoreCase(arg[0], "armed-forces") || equalsIgnoreCase(arg[0], "forces")) { //$army-list
						console.log("Army list called!");
						var target_user = returnMention(user_id);
						if (arg.length == 1) {
							if (main.users[target_user] != undefined) {
								printArmies(target_user, message);
								console.log("printArmies invoked!");
							} else {
								message.channel.send("You don't even have a nation!");
							}
						} else if (arg.length == 2) {
							target_user = returnMention(arg[1]);
							if (main.users[target_user] != undefined) {
								printArmies(target_user, message);
							} else {
								message.channel.send("The user you have specified doesn't have a country!");
							}
						} else {
							getArguments(message,
								[
									["mention", "**Please ping a valid user:**"]
								],
								'printArmies(arg[0], msg);'
							);
						}
					}
					
					if (equalsIgnoreCase(arg[0], "mobilise") || equalsIgnoreCase(arg[0], "mobilize")) { //$mobilise
						var target_user = returnMention(user_id);
						if (main.users[target_user] != undefined) {
							mobilise(target_user, message);
						} else {
							message.channel.send("You don't even have a nation!");
						}
					}
					
					if (equalsIgnoreCase(arg[0], "demobilise") || equalsIgnoreCase(arg[0], "demobilize")) { //$demobilise
						var target_user = returnMention(user_id);
						if (main.users[target_user] != undefined) {
							demobilise(target_user, message);
						} else {
							message.channel.send("You don't even have a nation!");
						}
					}
				}
			
				//Cities
				{
					if (equalsIgnoreCase(arg[0], "city-new") || equalsIgnoreCase(arg[0], "new-city") || equalsIgnoreCase(arg[0], "add-city") || equalsIgnoreCase(arg[0], "found-city") || equalsIgnoreCase(arg[0], "create-city") || equalsIgnoreCase(arg[0], "build-city") || equalsIgnoreCase(arg[0], "settle-city")) { //$city-new [province] [name]
						var target_user = returnMention(user_id);

						var full_name = [];
						for (var i = 2; i < arg.length; i++) {
							full_name.push(arg[i]);
						}
						
						if (full_name.join(" ").length <= 100) {
							if (main.users[target_user] != undefined) {
								var capital_exists = false;
								
								if (main.users[target_user].cities.city_array.length > 0) {
									capital_exists = true;
								}
								
								if (arg.length > 2) {
									if (main.users[target_user] != undefined) {
										
										if (capital_exists) {
											newCity(target_user, full_name.join(" "), "city", message, arg[1]);
										} else {
											newCity(target_user, full_name.join(" "), "capital", message, arg[1]);
										}
									} else {
										message.channel.send("You're currently stateless! Try registering first.");
									}
								} else {
									getArguments(message,
										[
											["text", "**What would you like to name your city?**", "minimum: 1", "maximum: 100"],
											["text", "**Please specify a province on which to settle:**"]
										],
										'if (' + capital_exists + ') { newCity(author_id, arg[0], "city", msg, arg[1]); } else { newCity(author_id, arg[0], "capital", msg, arg[1]); }'
									);
								}
							} else {
								message.channel.send("You're currently stateless!");
							}
						} else {
							message.channel.send("Your city name exceeded the maximum character limit of 100 characters!");
						}
					}

					if (equalsIgnoreCase(arg[0], "city-rename") || equalsIgnoreCase(arg[0], "rename-city")) { //$city-rename <name> <new_name>
						var target_user = returnMention(user_id);

						var full_name = [];
						for (var i = 2; i < arg.length; i++) {
							full_name.push(arg[i]);
						}
						
						if (full_name.join(" ").length <= 100) {
							if (arg.length >= 2) {
								if (main.users[target_user] != undefined) {
									renameCity(target_user, message, arg[1], arg[2]);
								} else {
									message.channel.send("You don't even have a nation to begin with!");
								}
							} else {
								getArguments(message,
									[
										["text", "**Specify the city which you wish to rename:**"],
										["text", "**What would you like to rename this city to?**"]
									],
									'renameCity(author_id, msg, arg[0], arg[1]);'
								);
							}
						} else {
							message.channel.send("Your city name exceeded the maximum character limit of 100 characters!");
						}
					}

					if (equalsIgnoreCase(arg[0], "city") || equalsIgnoreCase(arg[0], "view-city")) { //$city <@user> <city>
						if (arg.length >= 2) {
							var target_user = returnMention(user_id);
							if (main.users[target_user] != undefined) {
								var full_name = [];
								for (var i = 1; i < arg.length; i++) {
									full_name.push(arg[i]);
								}

								printCity(target_user, full_name.join(" "), message);
							}
						} else {
							getArguments(message,
								[
									["text", "**Which city would you like to view?**"],
								],
								'printCity(author_id, arg[0], msg);'
							);
						}
					}

					if (equalsIgnoreCase(arg[0], "city-list") || equalsIgnoreCase(arg[0], "cities")) { //$city-list <@user>
						if (arg.length == 1) {
							var target_user = returnMention(user_id);
							if (main.users[target_user] != undefined) {
								printCities(target_user, message);
							}
						} else if (arg.length == 2) {
							var target_user = returnMention(arg[1]);
							if (main.users[target_user] != undefined) {
								printCities(target_user, message);
							}
						} else {
							msg.channel.send("Invalid amount of arguments.");
						}
					}
					
					if (equalsIgnoreCase(arg[0], "move-capital") || equalsIgnoreCase(arg[0], "capital-move")) { //$move-capital <city>
						if (arg.length > 1) {
							var target_user = returnMention(user_id);
							if (main.users[target_user] != undefined) {
								var full_name = [];
								for (var i = 1; i < arg.length; i++) {
									full_name.push(arg[i]);
								}
								moveCapital(target_user, full_name.join(" "), message);
							}
						} else {
							getArguments(message,
								[
									["text", "**Which city would you like to move your capital to?**"]
								],
								'moveCapital(author_id, arg[0], msg);'
							);
						}
					}
				
					if (equalsIgnoreCase(arg[0], "promote-urbanisation") || equalsIgnoreCase(arg[0], "promote-urbanization") || equalsIgnoreCase(arg[0], "develop")) { //$promote-urbanisation <city name> <building_category>
						var target_user = returnMention(user_id);
						if (arg.length > 2) {
							if (arg.length == 3) {
								promoteUrbanisation(target_user, arg[1], 1, arg[2], message);
							} else {
								//(arg0_user, arg1_city, arg2_amount, arg3_building_category, arg4_message) {
								if (isNaN(parseInt(arg[1])) == false) { //$promote-urbanisation <number> <building_category> <city_name> 
									promoteUrbanisation(target_user, arg[3], parseInt(arg[1]), arg[2], message);
								} else {
									message.channel.send("You must input an actual number! Try using the command like so: `" + bot_prefix + "promote-urbanisation [number] <building category> <city name> `, or alternatively, simply type `" + bot_prefix + "promote-urbanisation`.");
								}
							}
						} else {
							getArguments(message,
								[
									["text", "**Please type out the name of the city for which you wish to issue an urbanisation edict.** Type `" + bot_prefix + "city-list` for a valid list of current cities that you own."],
									["number", "**How many edicts would you like to issue for this city?**", "minimum: 1"],
									["text", "**Which building category in this city would you like to expand?** Type `" + bot_prefix + "build list` for a valid list of building categories, which are printed in **bold**."]
								],
								'promoteUrbanisation(author_id, arg[0], arg[1], arg[2], msg);'
							);
						}
					}
				}
				
				//Colonisation
				{
					if (equalsIgnoreCase(arg[0], "cancel-charter") || equalsIgnoreCase(arg[0], "cancel-colonisation") || equalsIgnoreCase(arg[0], "cancel-colonization")) { //$cancel-charter
						var target_user = returnMention(user_id);
						
						if (arg.length > 1) {
							cancelColonisation(user_id, arg[1], message);
						} else {
							getArguments(message,
								[
									["text", "**Please specify the ID of the colonial charter you wish to cancel.** Type `" + bot_prefix + "colonisation` for a list of current colonial charters."]
								],
								'cancelColonisation(author_id, arg[0], msg);'
							);
						}
					}
					
					if (equalsIgnoreCase(arg[0], "settle") || equalsIgnoreCase(arg[0], "colonise") || equalsIgnoreCase(arg[0], "colonize")) { //$settle <Prov1> <...> (arg0_user, arg1_msg, arg2_provs)
						var target_user = returnMention(user_id);
						if (arg.length > 1) {
							if (main.users[target_user] != undefined) {
								var temp_province_array = [];
								
								for (var i = 1; i < arg.length; i++) {
									temp_province_array.push(arg[i]);
								}
								
								settle(target_user, message, temp_province_array);
							} else {
								message.channel.send("You can't colonise, because you don't even have a nation!");
							}
						} else {
							message.channel.send("Invalid amount of arguments. Make sure to specify as many provinces as the unit is capable of settling.");
						}
					}
				}
				
				//Diplomacy
				{
					//Peace offers
					{
						if (equalsIgnoreCase(arg[0], "clear-peace-treaty") || equalsIgnoreCase(arg[0], "clear-peace-offer")) { //$clear-peace-offer <war name>
							if (arg.length == 2) {
								var target_user = returnMention(user_id);
								peaceOffer(target_user, arg[1], ["delete"], message);
							} else {
								getArguments(message,
									[
										["text", "**Please specify the name of the conflict for whom you wish to clear the peace offer:** Type `" + bot_prefix + "war-list` for a list of valid conflicts."]
									],
									'peaceOffer(author_id, arg[0], ["delete"], msg);'
								);
							}
						}
						
						if (equalsIgnoreCase(arg[0], "add-wargoal")) { //$add-wargoal <war> <wargoal> <arguments>
						
							/*
								Wargoal List (Data Structure):
								---
								status_quo: ["edit", "add", "status_quo"]
								install_government: ["edit", "add", "install_government", "nation"]
								cut_down_to_size: ["edit", "add", "cut_down_to_size", "nation"]
								liberation: ["edit", "add", "liberation"]
								puppet: ["edit", "add", "puppet", ["overlord", "puppet"]]
								retake_cores: ["edit", "add", "retake_cores", ["nation", "nation", "nation"]]
								annexation: ["edit", "add", "annexation", ["nation", ["prov1", "prov2", "prov3"]]]
							*/
							
							if (arg.length >= 2) {
								var target_user = returnMention(user_id);
								if (arg[2] == "status_quo") {
									peaceOffer(target_user, arg[1], ["edit", "add", "status_quo"], message);
								} else if (arg[2] == "install_government") {
									if (arg.length >= 4) {
										peaceOffer(target_user, arg[1], ["edit", "add", "install_government", returnMention(arg[3])], message);
									} else {
										getArguments(message,
											[
												["mention", "**Who would you like to install a friendly government in?** (Please ping a user):"]
											],
											'peaceOffer(author_id, "' + arg[1] + '", ["edit", "add", "install_government", arg[0]], msg);'
										);
									}
								} else if (arg[2] == "cut_down_to_size") {
									if (arg.length >= 4) {
										peaceOffer(target_user, arg[1], ["edit", "add", "cut_down_to_size", returnMention(arg[3])], message);
									} else {
										getArguments(message,
											[
												["mention", "**Who would you like to cut down to size?** (Please ping a user):"]
											],
											'peaceOffer(author_id, "' + arg[1] + '", ["edit", "add", "cut_down_to_size", arg[0]], msg);'
										);
									}
								} else if (arg[2] == "liberation") {
									peaceOffer(target_user, arg[1], ["edit", "add", "liberation"], message);
								} else if (arg[2] == "puppet") {
									if (arg.length >= 4) {
										peaceOffer(target_user, arg[1], ["edit", "add", "puppet", [returnMention(arg[3]), returnMention(arg[4])]], message);
									} else {
										getArguments(message,
											[
												["mention", "**Who would you like to puppet?** (Please ping a user):"],
												["mention", "**Who should be the overlord of this puppet?** (Please ping a user):"]
											],
											'peaceOffer(author_id, "' + arg[1] + '", ["edit", "add", "puppet", [arg[1], arg[0]]], msg);'
										);
									}
								} else if (arg[2] == "retake_cores") {
									if (arg.length >= 4) {
										var all_countries = [];
										for (var i = 2; i < arg.length; i++) {
											all_countries.push(returnMention(arg[i]));
										}
										peaceOffer(target_user, arg[1], ["edit", "add", "retake_cores", all_countries], message);
									} else {
										getArguments(message,
											[
												["text", "**Who should get their cores back?** Please separate user mentions by spaces:"]
											],
											'var all_countries = []; var split_array = arg[0].split(" "); for (var i = 0; i < split_array.length; i++) { all_countries.push(returnMention(split_array[i])); }  peaceOffer(author_id, "' + arg[1] + '", ["edit", "add", "retake_cores", all_countries], msg);'
										);
									}
								} else if (arg[2] == "annexation") {
									if (arg.length >= 4) {
										var all_provinces = [];
										for (var i = 4; i < arg.length; i++) {
											all_provinces.push(arg[i]);
										}
										//[[nation, [prov_1, prov_2, prov_3]]
										peaceOffer(target_user, arg[1], ["edit", "add", "annexation", [returnMention(arg[3]), all_provinces]], message);
									} else {
										getArguments(message,
											[
												["text", "**Which lands would you like to annex?** Please separate province IDs by spaces:"],
												["mention", "**Who should these lands be given to?** Please ping a valid user."]
											],
											'var all_provinces = []; var split_array = arg[0].split(" "); for (var i = 0; i < split_array.length; i++) { all_provinces.push(split_array[i]); }  peaceOffer(author_id, "' + arg[1] + '", ["edit", "add", "annexation", [arg[1], all_provinces]], msg);'
										);
									}
								} else {
									var help_wargoal_array = [];
									help_wargoal_array.push("**Oh no!** It appears that you've used this command incorrectly. Make sure to surround the war name (if it contains spaces) in quotes. Here's some example commands for various wargoals:");
									help_wargoal_array.push("---");
									help_wargoal_array.push("");
									help_wargoal_array.push("`" + bot_prefix + "add-wargoal <war> status_quo`");
									help_wargoal_array.push("`" + bot_prefix + "add-wargoal <war> install_government`");
									help_wargoal_array.push("`" + bot_prefix + "add-wargoal <war> cut_down_to_size`");
									help_wargoal_array.push("`" + bot_prefix + "add-wargoal <war> liberation`");
									help_wargoal_array.push("`" + bot_prefix + "add-wargoal <war> puppet`");
									help_wargoal_array.push("`" + bot_prefix + "add-wargoal <war> retake_cores`");
									help_wargoal_array.push("`" + bot_prefix + "add-wargoal <war> annexation`");
									message.channel.send(help_wargoal_array.join("\n"));
								}
							} else {
								var help_wargoal_array = [];
								help_wargoal_array.push("**Oh no!** It appears that you've used this command incorrectly. Make sure to surround the war name (if it contains spaces) in quotes. Here's some example commands for various wargoals:");
								help_wargoal_array.push("---");
								help_wargoal_array.push("");
								help_wargoal_array.push("`" + bot_prefix + "add-wargoal <war> status_quo`");
								help_wargoal_array.push("`" + bot_prefix + "add-wargoal <war> install_government`");
								help_wargoal_array.push("`" + bot_prefix + "add-wargoal <war> cut_down_to_size`");
								help_wargoal_array.push("`" + bot_prefix + "add-wargoal <war> liberation`");
								help_wargoal_array.push("`" + bot_prefix + "add-wargoal <war> puppet`");
								help_wargoal_array.push("`" + bot_prefix + "add-wargoal <war> retake_cores`");
								help_wargoal_array.push("`" + bot_prefix + "add-wargoal <war> annexation`");
								message.channel.send(help_wargoal_array.join("\n"));
							}
						}
						
						if (equalsIgnoreCase(arg[0], "remove-wargoal") || equalsIgnoreCase(arg[0], "delete-wargoal")) { //$remove-wargoal <war name> <wargoal>
							var target_user = returnMention(user_id);
							
							if (arg.length >= 3) {
								peaceOffer(target_user, arg[1], ["edit", "remove", arg[2], returnMention(arg[3])], message);
							} else {
								getArguments(message,
									[
										["text", "**Please type the name of the war you're drafting a peace treaty for.** Type `" + bot_prefix + "war-list` for a list of valid conflicts."],
										["text", "**Type the name of the wargoal you wish to drop from the eventual peace treaty.**"],
										["mention", "**Please mention who the original wargoal was for.**"]
									],
									'peaceOffer(author_id, arg[0], ["edit", "remove", arg[1], returnMention(arg[2])], msg);'
								);
							}
						}
						
						if (equalsIgnoreCase(arg[0], "send-peace-treaty") || equalsIgnoreCase(arg[0], "send-peace-offer")) {
							if (arg.length >= 2) {
								var target_user = returnMention(user_id);
								sendPeaceOffer(target_user, arg[1], message);
							} else {
								getArguments(message,
									[
										["text", "**Please type the name of the war you wish to send a peace offer for.** Type `" + bot_prefix + "war-list` for a list of valid conflicts."]
									],
									'sendPeaceOffer(author_id, arg[0], msg);'
								);
							}
						}
						
						if (equalsIgnoreCase(arg[0], "sign-peace-treaty") || equalsIgnoreCase(arg[0], "create-peace-offer")) { //$create-peace-offer <war name>
							if (arg.length >= 2) {
								var target_user = returnMention(user_id);
								peaceOffer(target_user, arg[1], ["create"], message);
							} else {
								getArguments(message,
									[
										["text", "**Please specify the name of the conflict you wish to resolve:** Type `" + bot_prefix + "war-list` for a list of valid conflicts."]
									],
									'peaceOffer(author_id, arg[0], ["create"], msg);'
								);
							}
						}
					
						if (equalsIgnoreCase(arg[0], "view-peace-treaty") || equalsIgnoreCase(arg[0], "view-peace-offer")) {
							if (arg.length == 2) { //$view-peace-offer <war name>
								var target_user = returnMention(user_id);
								viewPeaceOffer(target_user, arg[1], message);
							} else if (arg.length >= 3) { //$view-peace-offer <@user> <war name>
								var target_user = returnMention(arg[1]);
								viewPeaceOffer(target_user, arg[2], message);
							} else {
								getArguments(message,
									[
										["mention", "**Please ping the user proposing the peace treaty.**"],
										["text", "**Please specify a conflict you would like to view a peace proposal for.** Type `" + bot_prefix + "war-list` for a list of valid conflicts."]
									],
									'viewPeaceOffer(arg[0], arg[1], msg);'
								);
							}
						}
					}
					
					//War and Vassal customisation commands
					{
						if (equalsIgnoreCase(arg[0], "lock-vassal-customisation") || equalsIgnoreCase(arg[0], "lock-vassal-customization")) {
							var target_user = returnMention(user_id);
							lockVassalCustomisation(target_user, "lock", message);
						}
						
						if (equalsIgnoreCase(arg[0], "rename-vassal")) {
							if (arg.length >= 3) {
								var target_user = returnMention(user_id);
								var receiving_user = returnMention(arg[1]);
								var full_name = [];
								for (var i = 1; i < arg.length; i++) {
									full_name.push(arg[i]);
								}
								
								renameVassal(target_user, receiving_user, full_name.join(" "), message);
							} else {
								getArguments(message,
									[
										["mention", "**Please mention whose name you would like to forcibly change:** Type `" + bot_prefix + 'diplomacy-view ' + returnMention(user_id) + '` for a list of valid vassals.'],
										["text", "**Please type out a new country name for your vassal:**"]
									],
									'renameVassal(author_id, arg[0], arg[1], msg);'
								);
							}
						}
						
						if (equalsIgnoreCase(arg[0], "rename-vassal-city")) {
							if (arg.length >= 3) {
								var target_user = returnMention(user_id);
								var full_name = [];
								for (var i = 2; i < arg.length; i++) {
									full_name.push(arg[i]);
								}
								
								renameVassalCity(target_user, arg[1].toLowerCase(), full_name.join(" "), message);
							} else {
								getArguments(message,
									[
										["text", "**Which of your vassal's cities would you like to rename?**"],
										["text", "**Please type out a new name for the city:**"]
									],
									'renameVassalCity(author_id, arg[0].toLowerCase(), arg[1], msg);'
								);
							}
						}
						
						if (equalsIgnoreCase(arg[0], "rename-vassal-culture")) {
							if (arg.length >= 3) {
								var target_user = returnMention(user_id);
								var receiving_user = returnMention(arg[1]);
								var full_name = [];
								for (var i = 2; i < arg.length; i++) {
									full_name.push(arg[i]);
								}
								
								renameVassalCulture(target_user, receiving_user, full_name.join(" "), message);
							} else {
								getArguments(message,
									[
										["mention", "**Please mention the vassal of which you would like to change the culture name of:** Type `" + bot_prefix + 'diplomacy-view ' + returnMention(user_id) + '` for a list of valid vassals.'],
										["text", "**Please type out a new culture name for your vassal:**"]
									],
									'renameVassalCulture(author_id, arg[0], arg[1], msg);'
								);
							}
						}
						
						if (equalsIgnoreCase(arg[0], "rename-war")) {
							if (arg.length >= 3) {
								var target_user = returnMention(user_id);
								var full_name = [];
								for (var i = 2; i < arg.length; i++) {
									full_name.push(arg[i]);
								}
								
								renameWar(target_user, arg[1], full_name.join(" "), message);
							} else {
								getArguments(message,
									[
										["text", "**Please give the name of the war that you're involved in which you would like to rename:** Type `" + bot_prefix + "war-list` for a valid list of conflicts."],
										["text", "**What would you like to rename this war to?**"]
									],
									'renameWar(author_id, arg[0], arg[1], msg);'
								);
							}
						}
					
						if (equalsIgnoreCase(arg[0], "set-vassal-colour") || equalsIgnoreCase(arg[0], "set-vassal-color")) {
							if (arg.length >= 5) {
								var target_user = returnMention(user_id);
								var receiving_user = returnMention(arg[1]);
								
								setVassalColour(target_user, receiving_user, parseInt(arg[2]), parseInt(arg[3]), parseInt(arg[4]), message);
							} else {
								getArguments(message,
									[
										["mention", "**Please mention the vassal that you'd like to paint in a new shade:** Type `" + bot_prefix + 'diplomacy-view ' + returnMention(user_id) + '` for a list of valid vassals.'],
										["number", "**Please insert the R code of your colour:**", "minimum: 20", "maximum: 255"],
										["number", "**Please insert the G code of your colour:**", "minimum: 20", "maximum: 255"],
										["number", "**Please insert the B code of your colour:**", "minimum: 20", "maximum: 255"],
									],
									'setVassalColour(author_id, arg[0], parseInt(arg[1]), parseInt(arg[2]), parseInt(arg[3]), msg);'
								);
							}
						}
						
						if (equalsIgnoreCase(arg[0], "set-vassal-flag")) {
							if (arg.length >= 3) {
								var target_user = returnMention(user_id);
								var receiving_user = returnMention(arg[1]);
								
								setVassalFlag(target_user, receiving_user, arg[2], message);
							} else {
								getArguments(message,
									[
										["mention", "**Who would you like to change the flag of?** Type `" + bot_prefix + 'diplomacy-view ' + returnMention(user_id) + '` for a list of valid vassals.'],
										["text", "**Please enter the image URL for the new flag:**"]
									],
									'setVassalFlag(author_id, arg[0], arg[1], msg);'
								);
							}
						}
						
						if (equalsIgnoreCase(arg[0], "set-vassal-motto")) {
							if (arg.length >= 3) {
								var target_user = returnMention(user_id);
								var receiving_user = returnMention(arg[1]);
								var full_name = [];
								for (var i = 2; i < arg.length; i++) {
									full_name.push(arg[i]);
								}
								
								setVassalMotto(target_user, receiving_user, full_name.join(" "), message);
							} else {
								getArguments(message,
									[
										["mention", "**Whose motto would you like to change?** Type `" + bot_prefix + 'diplomacy-view ' + returnMention(user_id) + '` for a list of valid vassals.'],
										["text", "**Please enter in your vassal's new motto:**"]
									],
									'setVassalMotto(author_id, arg[0], arg[1], msg);'
								);
							}
						}
						
						if (equalsIgnoreCase(arg[0], "unlock-vassal-customisation") || equalsIgnoreCase(arg[0], "unlock-vassal-customization")) {
							var target_user = returnMention(user_id);
							lockVassalCustomisation(target_user, "unlock", message);
						}
					}
					
					if (equalsIgnoreCase(arg[0], "allow-cede") || equalsIgnoreCase(arg[0], "allow-ceding") || equalsIgnoreCase(arg[0], "accept-ceding")) {
						if (arg.length >= 2) {
							var target_user = returnMention(user_id);
							var receiving_user = returnMention(arg[1]);
							
							allowCeding(target_user, receiving_user, message);
						} else {
							getArguments(message,
								[
									["mention", "**Who would you like to accept provinces from?**"]
								],
								'allowCeding(author_id, arg[0], msg);'
							);
						}
					}
					
					if (equalsIgnoreCase(arg[0], "ally")) { //$ally <@user>
						if (arg.length >= 2) {
							var target_user = returnMention(user_id);
							var receiving_user = returnMention(arg[1]);
							
							ally(target_user, receiving_user, message);
						} else {
							getArguments(message,
								[
									["mention", "**Please specify who you would like to send a request for an alliance to:** Type `" + bot_prefix + "diplomacy` for a list of valid countries."]
								],
								'ally(author_id, arg[0], msg);'
							);
						}
					}
					
					if (equalsIgnoreCase(arg[0], "annex") || equalsIgnoreCase(arg[0], "annexation") || equalsIgnoreCase(arg[0], "anschluss")) { //$annex <@user>
						if (arg.length >= 2) {
							var target_user = returnMention(user_id);
							var receiving_user = returnMention(arg[1]);
							
							annex(target_user, receiving_user, message);
						} else {
							getArguments(message,
								[
									["mention", "**Please ping the owner of the vassal you wish to annex.** Type `" + bot_prefix + "diplomacy` for a list of valid countries."]
								],
								'annex(author_id, arg[0], msg);'
							);
						}
					}
					
					if (equalsIgnoreCase(arg[0], "break-ally") || equalsIgnoreCase(arg[0], "break-alliance") || equalsIgnoreCase(arg[0], "leave-faction")) { //$break-ally <@user>
						if (arg.length >= 2) {
							var target_user = returnMention(user_id);
							var receiving_user = returnMention(arg[1]);
							
							breakAlly(target_user, receiving_user, message);
						} else {
							getArguments(message,
								[
									["mention", "**Who's alliance do you wish to leave?** Type `" + bot_prefix + "diplomacy` for a list of valid countries."]
								],
								'breakAlly(author_id, arg[0], msg);'
							);
						}
					}
					
					if (equalsIgnoreCase(arg[0], "call-ally")) { //$call-ally <@user> <war name>
						var target_user = returnMention(user_id);
						if (arg.length > 2) {
							callAlly(target_user, returnMention(arg[1]), arg[2], message);
						} else {
							getArguments(message,
								[
									["mention", "**Who would you like to call in as an ally?** Type `" + bot_prefix + "diplomacy` for a list of valid countries."],
									["text", "**Which war do you wish to call them into?** Type `" + bot_prefix + "war-list` for a list of valid conflicts."]
								],
								'callAlly(author_id, arg[0], arg[1], msg);'
							);
						}
					}
					
					
					if (equalsIgnoreCase(arg[0], "cancel-justification") || equalsIgnoreCase(arg[0], "cancel-war") || equalsIgnoreCase(arg[0], "cancel-cb")) { //$cancel-wargoal <@user> <CB>
						if (arg.length == 2) {
							var target_user = returnMention(user_id);
							var receiving_user = returnMention(arg[0]);
							
							justifyWar(target_user, receiving_user, "", message);
						} else if (arg.length >= 3) {
							var target_user = returnMention(user_id);
							var local_cb = arg[0].toLowerCase();
							var receiving_user = returnMention(arg[1]);
							
							justifyWar(target_user, receiving_user, local_cb, message);
						} else {
							getArguments(message,
								[
									["mention", "**Which user would you like to cancel justification on?** Type `" + bot_prefix + "diplomacy` for a list of valid countries."],
									["text", "**Which CB did you use and would like to cancel?**"]
								],
								'cancelJustification(author_id, arg[0], arg[1].toLowerCase(), msg);'
							);
						}
					}
					
					if (equalsIgnoreCase(arg[0], "cancel-military-access")) { //$cancel-military-access <@user>
						if (arg.length == 2) {
							var target_user = returnMention(user_id);
							var receiving_user = returnMention(arg[1]);
							
							cancelMilitaryAccess(target_user, receiving_user, message);
						} else {
							getArguments(message,
								[
									["mention", "**Who would you like to deny military access to?** Type `" + bot_prefix + "diplomacy` for a list of valid countries."]
								],
								'cancelMilitaryAccess(author_id, arg[0], msg);'
							);
						}
					}
					
					if (equalsIgnoreCase(arg[0], "cede-province")) { //$cede-province <province> <@user>
						var target_user = returnMention(user_id);
						
						if (main.users[target_user].cede_disabled) {
							message.channel.send("You have been locked from nation ruining your country.");
						} else {
							if (arg.length > 2) {
								var ot_user = returnMention(arg[2]);
								cedeProvince(target_user, arg[1], ot_user, message);
							} else {
								getArguments(message,
									[
										["text", "**Which province would you like to cede?**"],
										["mention", "**Who would you like to cede this province to?**"]
									],
									'cedeProvince(author_id, arg[0], arg[1], msg);'
								);
							}
						}
					}
					
					if (equalsIgnoreCase(arg[0], "declare-war")) { //$declare-war <@user> <cb>
						if (arg.length == 3) {
							var target_user = returnMention(user_id);
							var receiving_user = returnMention(arg[1]);
							
							declareWar(target_user, receiving_user, arg[2], message);
						} else {
							getArguments(message,
								[
									["mention", "**Who would you like to declare war upon?**"],
									["text", "**Which CB would you like to use?** Type `" + bot_prefix + "view-wargoals <@user>` for a list of valid wargoals."]
								],
								'declareWar(author_id, arg[0], arg[1], msg);'
							);
						}
					}
					
					if (equalsIgnoreCase(arg[0], "disallow-cede") || equalsIgnoreCase(arg[0], "disallow-ceding") || equalsIgnoreCase(arg[0], "deny-ceding") || equalsIgnoreCase(arg[0], "deny-cede")) {
						if (arg.length >= 2) {
							var target_user = returnMention(user_id);
							var receiving_user = returnMention(arg[1]);
							
							denyCeding(target_user, receiving_user, message);
						} else {
							getArguments(message,
								[
									["mention", "**Who would you like to reject provinces from?**"]
								],
								'denyCeding(author_id, arg[0], msg);'
							);
						}
					}
					
					if (equalsIgnoreCase(arg[0], "send-insult") || equalsIgnoreCase(arg[0], "decrease-relations") || equalsIgnoreCase(arg[0], "decrease-opinion") || equalsIgnoreCase(arg[0], "suspend-diplomatic-relations") || equalsIgnoreCase(arg[0], "denounce")) { //$denounce <@user>
						if (arg.length == 2) {
							var target_user = returnMention(user_id);
							var receiving_user = returnMention(arg[1]);
							
							decreaseRelations(target_user, receiving_user, message);
						} else {
							getArguments(message,
								[
									["mention", "**Who would you like to suspend diplomatic relations with?** Type `" + bot_prefix + "diplomacy` for a list of valid countries."]
								],
								'decreaseRelations(author_id, arg[0], msg);'
							);
						}
					}
					
					if (equalsIgnoreCase(arg[0], "end-rivalry") || equalsIgnoreCase(arg[0], "thaw")) { //$end-rivalry <@user>
						if (arg.length == 2) {
							var target_user = returnMention(user_id);
							var receiving_user = returnMention(arg[1]);
							
							endRivalry(target_user, receiving_user, message);
						} else {
							getArguments(message,
								[
									["mention", "**Who would you like to end a rivalry with?** Type `" + bot_prefix + "diplomacy` for a list of valid countries."]
								],
								'endRivalry(author_id, arg[0], msg);'
							);
						}
					}
					
					if (equalsIgnoreCase(arg[0], "liberate")) { //$liberate <@user>
						if (arg.length == 2) {
							var target_user = returnMention(user_id);
							var receiving_user = returnMention(arg[1]);
							
							liberate(target_user, receiving_user, message);
						} else {
							getArguments(message,
								[
									["mention", "**Who, under your control, would you like to liberate?** Type `" + bot_prefix + "diplomacy` for a list of valid countries."]
								],
								'liberate(author_id, arg[0], msg);'
							);
						}
					}
					
					if (equalsIgnoreCase(arg[0], "improve-relations") || equalsIgnoreCase(arg[0], "improve-opinion")) { //$improve-relations <@user>
						if (arg.length == 2) {
							var target_user = returnMention(user_id);
							var receiving_user = returnMention(arg[1]);
							
							improveRelations(target_user, receiving_user, message);
						} else {
							getArguments(message,
								[
									["mention", "**Who would you like to improve relations with?** Type `" + bot_prefix + "diplomacy` for a list of valid countries."]
								],
								'improveRelations(author_id, arg[0], msg);'
							);
						}
					}
					
					if (equalsIgnoreCase(arg[0], "request-military-access") || equalsIgnoreCase(arg[0], "military-access") || equalsIgnoreCase(arg[0], "mil-access")) { //$request-military-access <@user>
						if (arg.length == 2) {
							var target_user = returnMention(user_id);
							var receiving_user = returnMention(arg[1]);
							
							militaryAccess(target_user, receiving_user, message);
						} else {
							getArguments(message,
								[
									["mention", "**Who would you like to request military access from?** Type `" + bot_prefix + "diplomacy` for a list of valid countries."]
								],
								'militaryAccess(author_id, arg[0], msg);'
							);
						}
					}
					
					if (equalsIgnoreCase(arg[0], "sign-non-aggression-pact") || equalsIgnoreCase(arg[0], "non-aggression-pact") || equalsIgnoreCase(arg[0], "non-agg-pact")) { //$non-aggression-pact <@user>
						if (arg.length >= 2) {
							var target_user = returnMention(user_id);
							var receiving_user = returnMention(arg[1]);
							
							nonAggressionPact(target_user, receiving_user, message);
						} else {
							getArguments(message,
								[
									["mention", "**Who would you like to sign a non-aggression pact with?** Type `" + bot_prefix + "diplomacy` for a list of valid countries."]
								],
								'nonAggressionPact(author_id, arg[0], msg);'
							);
						}
					}
					
					if (equalsIgnoreCase(arg[0], "justify-war") || equalsIgnoreCase(arg[0], "justify-wargoal") || equalsIgnoreCase(arg[0], "justify-cb")) { //$justify-wargoal <@user>
						if (arg.length == 3) {
							var target_user = returnMention(user_id);
							var receiving_user = returnMention(arg[1]);
							
							justifyWar(target_user, receiving_user, arg[2].toLowerCase(), message);
						} else {
							getArguments(message,
								[
									["mention", "**Who would you like to justify a wargoal on?** Type `" + bot_prefix + "diplomacy` for a list of valid countries."],
									["text", "**Which CB would you like to use in order to justify a war?** Type `" + bot_prefix + "view-cb <@user>` for a valid list of casus belli."]
								],
								'justifyWar(author_id, arg[0], arg[1].toLowerCase(), msg);'
							);
						}
					}
					
					if (equalsIgnoreCase(arg[0], "proclaim-guarantee") || equalsIgnoreCase(arg[0], "guarantee-independence")) { //$proclaim-guarantee <@user>
						if (arg.length == 2) {
							var target_user = returnMention(user_id);
							var receiving_user = returnMention(arg[1]);
							
							proclaimGuarantee(target_user, receiving_user, message);
						} else {
							getArguments(message,
								[
									["mention", "**Who's independence would you like to guarantee?** Type `" + bot_prefix + "diplomacy` for a list of valid countries."]
								],
								'proclaimGuarantee(author_id, arg[0], msg);'
							);
						}
					}
					
					if (equalsIgnoreCase(arg[0], "revoke-guarantee") || equalsIgnoreCase(arg[0], "stop-guaranteeing-independence")) { //$revoke-guarantee <@user>
						if (arg.length == 2) {
							var target_user = returnMention(user_id);
							var receiving_user = returnMention(arg[1]);
							
							revokeGuarantee(target_user, receiving_user, message);
						} else {
							getArguments(message,
								[
									["mention", "**Who's guarantee of independence would you wish to revoke?** Type `" + bot_prefix + "diplomacy` for a list of valid countries."]
								],
								'revokeGuarantee(author_id, arg[0], msg);'
							);
						}
					}
					
					if (equalsIgnoreCase(arg[0], "rival") || equalsIgnoreCase(arg[0], "declare-rivalry")) { //$declare-rivalry <@user>
						if (arg.length == 2) {
							var target_user = returnMention(user_id);
							var receiving_user = returnMention(arg[1]);
							
							rival(target_user, receiving_user, message);
						} else {
							getArguments(message,
								[
									["mention", "**Who would you like to declare a rivalry with?** Type `" + bot_prefix + "diplomacy` for a list of valid countries."]
								],
								'rival(author_id, arg[0], msg);'
							);
						}
					}
					
					if (equalsIgnoreCase(arg[0], "vassalise")) { //$vassalise <@user>
						if (arg.length == 2) {
							var target_user = returnMention(user_id);
							var receiving_user = returnMention(arg[1]);
							
							vassalise(target_user, receiving_user, message);
						} else {
							getArguments(message,
								[
									["mention", "**Who would you like to vassalise?** Type `" + bot_prefix + "diplomacy` for a list of valid countries."]
								],
								'vassalise(author_id, arg[0], msg);'
							);
						}
					}
				
					if (equalsIgnoreCase(arg[0], "view-cb")) { //$view-cb <@user>
						if (arg.length == 2) {
							var target_user = returnMention(user_id);
							var receiving_user = returnMention(arg[1]);
							
							printCBs(target_user, receiving_user, message);
						} else {
							getArguments(message,
								[
									["mention", "**Please ping the user that you would wish to see your CBs for.**"]
								],
								'printCBs(author_id, arg[0], msg);'
							);
						}
					}
					
					if (equalsIgnoreCase(arg[0], "view-diplomacy") || equalsIgnoreCase(arg[0], "diplomacy-view") || equalsIgnoreCase(arg[0], "relations") || equalsIgnoreCase(arg[0], "relation")) { //$view-diplomacy <@user>
						if (arg.length >= 2) {
							var target_user = returnMention(user_id);
							var full_name = [];
							for (var i = 1; i < arg.length; i++) {
								full_name.push(arg[i]);
							}
							
							viewDiplomacy(target_user, returnMention(full_name.join(" ")), message);
						} else {
							getArguments(message,
								[
									["mention", "**Who's diplomatic ties would you like to see?** Type `" + bot_prefix + "diplomacy` for a list of valid countries."]
								],
								'viewDiplomacy(author_id, arg[0], msg);'
							);
						}
					}
					
					if (equalsIgnoreCase(arg[0], "view-war") || equalsIgnoreCase(arg[0], "war")) { //$view-war <war name>
						var target_user = returnMention(user_id);
						if (arg.length > 1) {
							printWar(target_user, arg[1], message);
						} else {
							getArguments(message,
								[
									["text", "**Please enter the name of the conflict you would like to view.** Type `" + bot_prefix + "war-list` for a list of valid conflicts."]
								],
								'printWar(author_id, arg[0], msg);'
							);
						}
					}
					
					if (equalsIgnoreCase(arg[0], "view-wargoals")) { //$view-wargoals <@user>
						var target_user = returnMention(user_id);
						if (arg.length == 2) {
							printWargoals(target_user, returnMention(arg[1]), message);
						} else {
							getArguments(message,
								[
									["mention", "**Please mention who you would like to view a list of wargoals for.** Type `" + bot_prefix + "view-wargoals` for a list of valid wargoals."]
								],
								'printWargoals(author_id, arg[0], msg);'
							);
						}
					}
					
					if (equalsIgnoreCase(arg[0], "war-list")) { //$war-list
						printWars(message);
					}
				}
				
				//Interface and Modifiers Screen
				{
					if (equalsIgnoreCase(arg[0], "budget")) { //$budget <@user>
						if (arg.length == 1) {
							var target_user = returnMention(user_id);
							printInterface(target_user, message, 1);
						} else if (arg.length == 2) {
							var target_user = returnMention(arg[1]);
							printInterface(target_user, message, 1);
						} else {
							getArguments(message,
								[
									["mention", "**Please ping a user:**"]
								],
								'printInterface(arg[0], msg, 1);'
							);
						}
					}
					
					if (equalsIgnoreCase(arg[0], "colonisation") || equalsIgnoreCase(arg[0], "colonization") || equalsIgnoreCase(arg[0], "expeditions")) { //$expeditions <@user>
						if (arg.length == 1) {
							var target_user = returnMention(user_id);
							printInterface(target_user, message, 8);
						} else if (arg.length == 2) {
							var target_user = returnMention(arg[1]);
							printInterface(target_user, message, 8);
						} else {
							getArguments(message,
								[
									["mention", "**Please ping a user:**"]
								],
								'printInterface(arg[0], msg, 7);'
							);
						}
					}
					
					if (equalsIgnoreCase(arg[0], "construction") || equalsIgnoreCase(arg[0], "constructions") || equalsIgnoreCase(arg[0], "building-list") || equalsIgnoreCase(arg[0], "build-list") || equalsIgnoreCase(arg[0], "construction-list")) { //$constructions <@user>
						if (arg.length == 1) {
							var target_user = returnMention(user_id);
							printConstructions(target_user, message, 0);
						} else if (arg.length >= 2) {
							if (isNaN(parseInt(arg[1]))) { //Textual argument
								var full_name = [];
								for (var i = 1; i < arg.length; i++) full_name.push(arg[i]);
								var target_user = returnMention(full_name.join(" "));
								
								printConstructions(target_user, message, 0);
							} else { //Numeric argument, flip to specified page
								var target_user = returnMention(user_id);
								printConstructions(target_user, message, parseInt(arg[1]));
							}
						}
					}
					
					if (equalsIgnoreCase(arg[0], "diplomacy") || equalsIgnoreCase(arg[0], "deplomacy")) { //$diplomacy <@user>
						if (arg.length == 1) {
							var target_user = returnMention(user_id);
							printInterface(target_user, message, 7);
						} else if (arg.length == 2) {
							var target_user = returnMention(arg[1]);
							printInterface(target_user, message, 7);
						} else {
							getArguments(message,
								[
									["mention", "**Please ping a user:**"]
								],
								'printInterface(arg[0], msg, 6);'
							);
						}
					}
					
					if (equalsIgnoreCase(arg[0], "economy") || equalsIgnoreCase(arg[0], "econ")) { //$economy <@user>
						if (arg.length == 1) {
							var target_user = returnMention(user_id);
							printInterface(target_user, message, 2);
						} else if (arg.length == 2) {
							var target_user = returnMention(arg[1]);
							printInterface(target_user, message, 2);
						} else {
							getArguments(message,
								[
									["mention", "**Please ping a user:**"]
								],
								'printInterface(arg[0], msg, 2);'
							);
						}
					}
					
					if (equalsIgnoreCase(arg[0], "military")) { //$military <@user>
						if (arg.length == 1) {
							var target_user = returnMention(user_id);
							printInterface(target_user, message, 9);
						} else if (arg.length >= 2) {
							var target_user = returnMention(arg[1]);
							printInterface(target_user, message, 9);
						} else {
							getArguments(message,
								[
									["mention", "**Please ping a user:**"]
								],
								'printInterface(arg[0], msg, 9);'
							);
						}
					}
					
					if (equalsIgnoreCase(arg[0], "military-hq") || equalsIgnoreCase(arg[0], "military-headquarters")) { //$military-hq
						if (arg.length == 1) {
							var target_user = returnMention(user_id);
							printMilitaryHQ(target_user, message);
						} else {
							if (has_authorised_role) {
								var target_user = returnMention(arg[1]);
								printMilitaryHQ(target_user, message);
							}
						}
					}
					
					if (equalsIgnoreCase(arg[0], "modifiers")) { //$modifiers <@user>
						if (arg.length > 1) {
							var target_user = returnMention(arg[1]);
							printAllModifiers(target_user, message);
						} else {
							var target_user = returnMention(user_id);
							printAllModifiers(target_user, message);
						}
					}
					
					if (equalsIgnoreCase(arg[0], "pops") || equalsIgnoreCase(arg[0], "pops-view") || equalsIgnoreCase(arg[0], "population")) { //$pops <@user>
						if (arg.length == 1) {
							var target_user = returnMention(user_id);
							printInterface(target_user, message, 5);
						} else if (arg.length == 2) {
							if (arg[1] != "view") {
								var target_user = returnMention(arg[1]);
								printInterface(target_user, message, 5);
							}
						} else {
							if (arg[1] != "view") {
								getArguments(message,
									[
										["mention", "**Please ping a user:**"]
									],
									'printInterface(arg[0], msg, 5);'
								);
							}
						}
					}
					
					if (equalsIgnoreCase(arg[0], "stats") || equalsIgnoreCase(arg[0], "hotbar") || equalsIgnoreCase(arg[0], "info") || equalsIgnoreCase(arg[0], "overview") || equalsIgnoreCase(arg[0], "country")) { //$stats <@user>
						if (arg.length == 1) {
							var target_user = returnMention(user_id);
							if (main.users[target_user] != undefined) {
								printInterface(target_user, message);
							} else {
								message.channel.send("You don't even have a country yet!");
							}
						} else if (arg.length >= 2) {
							var target_user = returnMention(arg[1]);
							if (main.users[target_user] != undefined) {
								printInterface(target_user, message);
							} else {
								message.channel.send("The person you have specified doesn't even have a country!");
							}
						}
					}
					
					if (equalsIgnoreCase(arg[0], "technology") || equalsIgnoreCase(arg[0], "tech")) { //$technology <@user>
						if (arg.length == 1) {
							var target_user = returnMention(user_id);
							printInterface(target_user, message, 3);
						} else if (arg.length >= 2) {
							var target_user = returnMention(arg[1]);
							printInterface(target_user, message, 3);
						}
					}
					
					if (equalsIgnoreCase(arg[0], "trade")) { //$trade <@user>
						if (arg.length == 1) {
							var target_user = returnMention(user_id);
							printInterface(target_user, message, 6);
						} else if (arg.length >= 2) {
							var target_user = returnMention(arg[1]);
							printInterface(target_user, message, 6);
						}
					}
					
					if (equalsIgnoreCase(arg[0], "view-national-modifiers") || equalsIgnoreCase(arg[0], "view-national-spirits")) { //$view-national-modifiers <@user> <page>
						if (arg.length == 1) {
							var target_user = returnMention(user_id);
							printAllNationalSpirits(target_user, message);
						} else if (arg.length == 2) {
							var target_user = returnMention(user_id);
							printAllNationalSpirits(target_user, message, arg[1]);
						} else {
							var target_user = returnMention(arg[1]);
							printAllNationalSpirits(target_user, message, arg[2]);
						}
					}
				}
				
				//Politics
				{
					if (equalsIgnoreCase(arg[0], "enact")) { //$enact <reform>
						if (arg.length > 1) {
							var target_user = returnMention(user_id);
							enactReform(target_user, arg[1], message);
						} else {
							getArguments(message,
								[
									["text", "**What reform would you like to enact?**"]
								],
								'enactReform(author_id, arg[0], msg);'
							);
						}
					}
					
					if (equalsIgnoreCase(arg[0], "reforms")) { //$reforms <page>
						var target_user = returnMention(user_id);
						if (arg.length == 1) {
							printReforms(target_user, 1, message);
						} else {
							if (isNaN(parseInt(arg[1]))) {
								if (main.users[returnMention(arg[1])] != undefined) {
									target_user = returnMention(arg[1]);
									printReforms(target_user, 1, message);
								} else {
									printReforms(target_user, 1, message);
								}
							} else {
								printReforms(target_user, parseInt(arg[1]), message);
							}
						}
					}
					
					if (equalsIgnoreCase(arg[0], "stability")) { //$stability (raise)
						var target_user = returnMention(user_id);
						if (arg.length == 1) {
							printInterface(target_user, message, 4);
						} else if (arg.length == 2) {
							if (arg[1].toLowerCase() == "raise") {
								console.log("Stability raised!");
								if (main.users[target_user] != undefined) {
									raiseStability(target_user, message);
								} else {
									message.channel.send("You must register a country first! Use " + bot_prefix + "found <name> in order to register a country.");
								}
							}
						}
					}
				}
				
				//Population
				{
					if (equalsIgnoreCase(arg[0], "add-accepted-culture")) { //$add-accepted-culture <culture>
						if (arg.length > 1) {
							var target_user = returnMention(user_id);
							addAcceptedCulture(target_user, arg[1], message);
						} else {
							getArguments(message,
								[
									["text", "**What culture would you like to assimilate?**\nType `" + bot_prefix + "culture` for a list of valid cultures."]
								],
								'addAcceptedCulture(author_id, arg[0], msg);'
							);
						}
					}
					
					if (equalsIgnoreCase(arg[0], "assimilate")) { //$assimilate <province> <culture>
						if (arg.length == 2) {
							var target_user = returnMention(user_id);
							if (main.users[target_user] != undefined) {
								assimilate(target_user, arg[1], main.users[target_user].culture, message);
							}
						} else if (arg.length == 3) {
							var target_user = returnMention(user_id);
							assimilate(target_user, arg[1], arg[2], message);
						} else {
							getArguments(message,
								[
									["text", "**Which province would you like to assimilate? (Specify a Province ID).**"],
									["text", "**Which culture would you like to assimilate it to? (Specify an accepted culture).**\nType `" + bot_prefix + "culture` for a list of accepted cultures."]
								],
								'assimilate(author_id, arg[0], arg[1], msg);'
							);
						}
					}
					
					if (equalsIgnoreCase(arg[0], "assimilate-all")) { //$assimilate-all <assimilate culture> <core culture>
						if (arg.length >= 3) {
							var full_name = [];
							for (var i = 2; i < arg.length; i++) full_name.push(arg[i]);
							
							var target_user = returnMention(user_id);
							
							assimilateAll(target_user, arg[1], full_name.join(" "), message);
						} else {
							getArguments(message,
								[
									["text", "**Which culture would you like to assimilate? (Specify an unaccepted culture).**"],
									["text", "**Which culture would you like to assimilate them to? (Specify an accepted culture).**\nType `" + bot_prefix + "culture` for a list of accepted cultures."]
								],
								'assimilateAll(author_id, arg[0], arg[1], msg);'
							);
						}
					}
					
					if (equalsIgnoreCase(arg[0], "culture")) { //$culture
						if (arg.length == 1) {
							var target_user = returnMention(user_id);
							printCultures(target_user, message);
						} else if (arg.length > 1) {
							var target_user = returnMention(arg[1]);
							printCultures(target_user, message);
						}
					}
					
					if (equalsIgnoreCase(arg[0], "pops")) { //$pops
						if (arg.length == 2) {
							if (arg[1].toLowerCase() == "view") {
								var target_user = returnMention(user_id);
								viewPops(target_user, message);
							}
						} else if (arg.length > 2) {
							if (arg[1].toLowerCase() == "view") {
								var target_user = returnMention(arg[2]);
								viewPops(target_user, message);
							}
						}
					}
				
					if (equalsIgnoreCase(arg[0], "remove-accepted-culture")) { //$remove-accepted-culture <name>
						if (arg.length > 1) {
							var target_user = returnMention(user_id);
							removeAcceptedCulture(target_user, arg[1], message);
						} else {
							getArguments(message,
								[
									["text", "**What minority would you like to oppress?**\nType `" + bot_prefix + "culture` for a list of valid cultures."]
								],
								'removeAcceptedCulture(author_id, arg[0], msg);'
							);
						}
					}
				}
			
				//Technologies
				{
					if (equalsIgnoreCase(arg[0], "add-research-queue")) { //$add-research-queue
						if (arg.length > 1) {
							var target_user = returnMention(user_id);
							addResearchQueue(target_user, arg[1], message);
						} else {
							getArguments(message,
								[
									["text", "**What do you want to add to your research queue?**\nType `" + bot_prefix + "research list` for a list of valid technologies."]
								],
								'addResearchQueue(author_id, arg[0], msg);'
							);
						}
					}
					
					if (equalsIgnoreCase(arg[0], "cancel-research") || equalsIgnoreCase(arg[0], "research-cancel")) { //$cancel-research
						if (arg.length > 1) {
							var target_user = returnMention(user_id);
							cancelResearch(user_id, parseInt(arg[1]), message);
						} else {
							getArguments(message,
								[
									["number", "**Which research slot would you like to free up**\nType `" + bot_prefix + "research list` for a list of valid research slots."]
								],
								'cancelResearch(author_id, arg[0], msg);'
							);
						}
					}
					
					if (equalsIgnoreCase(arg[0], "cancel-research-queue") || equalsIgnoreCase(arg[0], "remove-research-queue")) { //$remove-research-queue
						if (arg.length > 1) {
							var target_user = returnMention(user_id);
							removeResearchQueue(target_user, arg[1], message);
						} else {
							getArguments(message,
								[
									["number", "**Which research slot do you wish to free up?**\nType `" + bot_prefix + "research-queue` for a list of valid slot IDs.", "minimum: 0", "maximum: 20"]
								],
								'removeResearchQueue(author_id, arg[0], msg);'
							);
						}
					}
					
					if (equalsIgnoreCase(arg[0], "research")) { //$research <option>
						var target_user = returnMention(user_id);
						if (arg.length == 1) {
							printResearch(target_user, message);
						} else if (arg.length == 2) {
							if (arg[1] == "list") {
								printTechList(target_user, message);
							} else {
								research(target_user, arg[1].toLowerCase(), message);
							}
						} else {
							getArguments(message,
								[
									["text", "**What would you like to research?**\nType `" + bot_prefix + "research list` for a list of valid technologies."]
								],
								'research(author_id, arg[0].toLowerCase(), msg);'
							);
						}
					}
					
					if (equalsIgnoreCase(arg[0], "research-queue") || equalsIgnoreCase(arg[0], "search-queue")) { //$research-queue <@user>
						var target_user = returnMention(user_id);
						if (arg.length == 1) {
							printResearchQueue(target_user, message);
						} else {
							target_user = returnMention(arg[1]);
							printResearchQueue(target_user, message);
						}
					}
				}
				
				//Trade
				{
					if (equalsIgnoreCase(arg[0], "auto-trade")) { //$auto-trade <@user> [number] <resource>
						var target_user = returnMention(user_id);
						if (arg.length == 3) {
							autoTrade(target_user, returnMention(arg[1]), 1, arg[3], message);
						} else if (arg.length > 3) {
							autoTrade(target_user, returnMention(arg[1]), parseInt(arg[2]), arg[3], message);
						} else {
							getArguments(message,
								[
									["mention", "**Who would you like to send items to?**\nType `" + bot_prefix + "diplomacy` for a list of valid countries."],
									["text", "**What resource would you like to send to this user?**\nType `" + bot_prefix + "inv` for a list of valid resources."],
									["number", "**How much of this item would you like to send?**"]
								],
								'autoTrade(author_id, arg[0], arg[2], arg[1], msg);'
							);
						}
					}
					
					if (equalsIgnoreCase(arg[0], "auto-trades")) { //$auto-trades [@user]
						var target_user = returnMention(user_id);
						if (arg.length == 1) {
							printAutoTrades(target_user, message);
						} else {
							target_user = returnMention(arg[1]);
							printAutoTrades(target_user, message);
						}
					}
					
					if (equalsIgnoreCase(arg[0], "exports") || equalsIgnoreCase(arg[0], "list-exports")) { //$exports [@user]
						var target_user = returnMention(user_id);
						if (arg.length == 1) {
							printExports(target_user, message);
						} else {
							target_user = returnMention(arg[1]);
							printExports(target_user, message);
						}
					}
					
					if (equalsIgnoreCase(arg[0], "imports") || equalsIgnoreCase(arg[0], "list-imports")) { //$imports [@user]
						var target_user = returnMention(user_id);
						if (arg.length == 1) {
							printImports(target_user, message);
						} else {
							target_user = returnMention(arg[1]);
							printImports(target_user, message);
						}
					}
					
					if (equalsIgnoreCase(arg[0], "remove-auto-trade") || equalsIgnoreCase(arg[0], "cancel-auto-trade")) { //$cancel-auto-trade <number>
						var target_user = returnMention(user_id);
						if (arg.length > 1) {
							cancelAutoTrade(target_user, parseInt(arg[1]), message);
						} else {
							getArguments(message,
								[
									["number", "**Please type the Auto-Trade ID of the automatic trade you would like to cancel.**\nType `" + bot_prefix + "auto-trades` for a list of valid IDs."]
								],
								'cancelAutoTrade(author_id, arg[0], msg);'
							);
						}
					}
				}
			}
		}
	}
})
